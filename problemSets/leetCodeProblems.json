[
    {
        "excercise": "You are given an integer array cards of length 4. You have four cards, each containing a number in the range [1, 9]. You should arrange the numbers on these cards in a mathematical expression using the operators ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24.\nYou are restricted with the following rules:\n\tThe division operator '/' represents real division, not integer division.\n\t\tFor example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.\n\tEvery operation done is between two numbers. In particular, we cannot use '-' as a unary operator.\n\t\tFor example, if cards = [1, 1, 1, 1], the expression \"-1 - 1 - 1 - 1\" is not allowed.\n\tYou cannot concatenate numbers together\n\t\tFor example, if cards = [1, 2, 1, 2], the expression \"12 + 12\" is not valid.\nReturn true if you can get such expression that evaluates to 24, and false otherwise.\nExample 1:\nInput: cards = [4,1,8,7]\nOutput: true\nExplanation: (8-4) * (7-1) = 24\nExample 2:\nInput: cards = [1,2,1,2]\nOutput: false\nConstraints:\n\tcards.length == 4\n\t1 <= cards[i] <= 9",
        "topics": [
            "Array",
            "Math",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/24-game/",
        "givenPythonCode": "class Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        ",
        "givenJsCode": "class Solution {\n    public boolean judgePoint24(int[] cards) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} cards\n * @return {boolean}\n */\nvar judgePoint24 = function(cards) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\nExample 2:\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\nExample 3:\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\nConstraints:\n\t3 <= nums.length <= 3000\n\t-10^5 <= nums[i] <= 10^5",
        "topics": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/3sum/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\n                while (lo < hi) {\n                    if (nums[lo] + nums[hi] == sum) {\n                        res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));\n                        while (lo < hi && nums[lo] == nums[lo + 1]) lo++;\n                        while (lo < hi && nums[hi] == nums[hi - 1]) hi--;\n                        lo++;\n                        hi--;\n                    } else if (nums[lo] + nums[hi] < sum) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n}\n\n",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\n\t0 <= i, j, k, l < n\n\tnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\nExample 1:\nInput: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\nOutput: 2\nExplanation:\nThe two tuples are:\n1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\nExample 2:\nInput: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\nOutput: 1\nConstraints:\n\tn == nums1.length\n\tn == nums2.length\n\tn == nums3.length\n\tn == nums4.length\n\t1 <= n <= 200\n\t-2^28 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 2^28",
        "topics": [
            "Array",
            "Hash Table"
        ],
        "url": "https://leetcode.com/problems/4sum-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number[]} nums3\n * @param {number[]} nums4\n * @return {number}\n */\nvar fourSumCount = function(nums1, nums2, nums3, nums4) {\n    \n};",
        "givenJsCode": "class Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\t0 <= a, b, c, d < n\n\ta, b, c, and d are distinct.\n\tnums[a] + nums[b] + nums[c] + nums[d] == target\nYou may return the answer in any order.\nExample 1:\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\nExample 2:\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\nConstraints:\n\t1 <= nums.length <= 200\n\t-10^9 <= nums[i] <= 10^9\n\t-10^9 <= target <= 10^9",
        "topics": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/4sum/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nvar fourSum = function(nums, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two binary strings a and b, return their sum as a binary string.\nExample 1:\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\nExample 2:\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\nConstraints:\n\t1 <= a.length, b.length <= 10^4\n\ta and b consist only of '0' or '1' characters.\n\tEach string does not contain leading zeros except for the zero itself.",
        "topics": [
            "Math",
            "String",
            "Bit Manipulation",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/add-binary/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} a\n * @param {string} b\n * @return {string}\n */\nvar addBinary = function(a, b) {\n    \n};",
        "givenJsCode": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String addBinary(String a, String b) {\n        \n    }\n}"
    },
    {
        "excercise": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.\nExample 1:\nInput: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"\nExample 2:\nInput: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"\nExample 3:\nInput: num1 = \"0\", num2 = \"0\"\nOutput: \"0\"\nConstraints:\n\t1 <= num1.length, num2.length <= 10^4\n\tnum1 and num2 consist of only digits.\n\tnum1 and num2 don't have any leading zeros except for the zero itself.",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/add-strings/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar addStrings = function(num1, num2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String addStrings(String num1, String num2) {\n        \n    }\n}"
    },
    {
        "excercise": "An additive number is a string whose digits can form an additive sequence.\nA valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\nGiven a string containing only digits, return true if it is an additive number or false otherwise.\nNote: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\nExample 1:\nInput: \"112358\"\nOutput: true\nExplanation: \nThe digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\nExample 2:\nInput: \"199100199\"\nOutput: true\nExplanation: \nThe additive sequence is: 1, 99, 100, 199. \n1 + 99 = 100, 99 + 100 = 199\nConstraints:\n\t1 <= num.length <= 35\n\tnum consists only of digits.\nFollow up: How would you handle overflow for very large input integers?",
        "topics": [
            "String",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/additive-number/",
        "givenPythonCode": "/**\n * @param {string} num\n * @return {boolean}\n */\nvar isAdditiveNumber = function(num) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isAdditiveNumber(String num) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\tFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\n\tFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\tFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\nThe test cases are generated so that the answer fits in 32-bit integer.\nExample 1:\nInput: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]\nExample 2:\nInput: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic.\nConstraints:\n\t1  <= nums.length <= 1000\n\t-2^31 <= nums[i] <= 2^31 - 1",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/arithmetic-slices-ii-subsequence/",
        "givenPythonCode": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int numberOfArithmeticSlices(int[] nums) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfArithmeticSlices = function(nums) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\tFor example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.\nGiven an integer array nums, return the number of arithmetic subarrays of nums.\nA subarray is a contiguous subsequence of the array.\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: 3\nExplanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.\nExample 2:\nInput: nums = [1]\nOutput: 0\nConstraints:\n\t1 <= nums.length <= 5000\n\t-1000 <= nums[i] <= 1000",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/arithmetic-slices/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfArithmeticSlices = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int numberOfArithmeticSlices(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].\nYou should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:\n\tThe first element in s[k] starts with the selection of the element nums[k] of index = k.\n\tThe next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.\n\tWe stop adding right before a duplicate element occurs in s[k].\nReturn the longest length of a set s[k].\nExample 1:\nInput: nums = [5,4,0,3,1,6,2]\nOutput: 4\nExplanation: \nnums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.\nOne of the longest sets s[k]:\ns[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}\nExample 2:\nInput: nums = [0,1,2]\nOutput: 1\nConstraints:\n\t1 <= nums.length <= 10^5\n\t0 <= nums[i] < nums.length\n\tAll the values of nums are unique.",
        "topics": [
            "Array",
            "Depth-First Search"
        ],
        "url": "https://leetcode.com/problems/array-nesting/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar arrayNesting = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def arrayNesting(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int arrayNesting(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\nExample 1:\nInput: g = [1,2,3], s = [1,1]\nOutput: 1\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\nExample 2:\nInput: g = [1,2], s = [1,2,3]\nOutput: 2\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\nConstraints:\n\t1 <= g.length <= 3 * 10^4\n\t0 <= s.length <= 3 * 10^4\n\t1 <= g[i], s[j] <= 2^31 - 1",
        "topics": [
            "Array",
            "Two Pointers",
            "Greedy",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/assign-cookies/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} g\n * @param {number[]} s\n * @return {number}\n */\nvar findContentChildren = function(g, s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string s which represents an expression, evaluate this expression and return its value. \nThe integer division should truncate toward zero.\nYou may assume that the given expression is always valid. All intermediate results will be in the range of [-2^31, 2^31 - 1].\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\nExample 1:\nInput: s = \"3+2*2\"\nOutput: 7\nExample 2:\nInput: s = \" 3/2 \"\nOutput: 1\nExample 3:\nInput: s = \" 3+5 / 2 \"\nOutput: 5\nConstraints:\n\t1 <= s.length <= 3 * 10^5\n\ts consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces.\n\ts represents a valid expression.\n\tAll the integers in the expression are non-negative integers in the range [0, 2^31 - 1].\n\tThe answer is guaranteed to fit in a 32-bit integer.",
        "topics": [
            "Math",
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/basic-calculator-ii/",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar calculate = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def calculate(self, s: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int calculate(String s) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an integer array prices where prices[i] is the price of a given stock on the i^th day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nExample 2:\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\nExample 3:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\nConstraints:\n\t1 <= prices.length <= 3 * 10^4\n\t0 <= prices[i] <= 10^4",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/",
        "givenPythonCode": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};",
        "givenJsCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\nFind the maximum profit you can achieve. You may complete at most two transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\nExample 3:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\nConstraints:\n\t1 <= prices.length <= 10^5\n\t0 <= prices[i] <= 10^5",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/",
        "givenPythonCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an integer array prices where prices[i] is the price of a given stock on the i^th day, and an integer k.\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\nExample 2:\nInput: k = 2, prices = [3,2,6,5,0,3]\nOutput: 7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nConstraints:\n\t1 <= k <= 100\n\t1 <= prices.length <= 1000\n\t0 <= prices[i] <= 1000",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/",
        "givenPythonCode": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "givenJsCode": "/**\n * @param {number} k\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(k, prices) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int maxProfit(int k, int[] prices) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\tAfter you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: prices = [1,2,3,0,2]\nOutput: 3\nExplanation: transactions = [buy, sell, cooldown, buy, sell]\nExample 2:\nInput: prices = [1]\nOutput: 0\nConstraints:\n\t1 <= prices.length <= 5000\n\t0 <= prices[i] <= 1000",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/",
        "givenPythonCode": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};",
        "givenJsCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\nExample 1:\nInput: left = 5, right = 7\nOutput: 4\nExample 2:\nInput: left = 0, right = 0\nOutput: 0\nExample 3:\nInput: left = 1, right = 2147483647\nOutput: 0\nConstraints:\n\t0 <= left <= right <= 2^31 - 1",
        "topics": [
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/",
        "givenPythonCode": "/**\n * @param {number} left\n * @param {number} right\n * @return {number}\n */\nvar rangeBitwiseAnd = function(left, right) {\n    \n};",
        "givenJsCode": "class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int rangeBitwiseAnd(int left, int right) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are playing the Bulls and Cows game with your friend.\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\n\tThe number of \"bulls\", which are digits in the guess that are in the correct position.\n\tThe number of \"cows\", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.\nGiven the secret number secret and your friend's guess guess, return the hint for your friend's guess.\nThe hint should be formatted as \"xAyB\", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.\nExample 1:\nInput: secret = \"1807\", guess = \"7810\"\nOutput: \"1A3B\"\nExplanation: Bulls are connected with a '|' and cows are underlined:\n\"1807\"\n  |\n\"7810\"\nExample 2:\nInput: secret = \"1123\", guess = \"0111\"\nOutput: \"1A1B\"\nExplanation: Bulls are connected with a '|' and cows are underlined:\n\"1123\"        \"1123\"\n  |      or     |\n\"0111\"        \"0111\"\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\nConstraints:\n\t1 <= secret.length, guess.length <= 1000\n\tsecret.length == guess.length\n\tsecret and guess consist of digits only.",
        "topics": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/bulls-and-cows/",
        "givenPythonCode": "/**\n * @param {string} secret\n * @param {string} guess\n * @return {string}\n */\nvar getHint = function(secret, guess) {\n    \n};",
        "givenJsCode": "class Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String getHint(String secret, String guess) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\nIf you burst the i^th balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\nReturn the maximum coins you can collect by bursting the balloons wisely.\nExample 1:\nInput: nums = [3,1,5,8]\nOutput: 167\nExplanation:\nnums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\nExample 2:\nInput: nums = [1,5]\nOutput: 10\nConstraints:\n\tn == nums.length\n\t1 <= n <= 300\n\t0 <= nums[i] <= 100",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/burst-balloons/",
        "givenPythonCode": "class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int maxCoins(int[] nums) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxCoins = function(nums) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an array routes representing bus routes where routes[i] is a bus route that the i^th bus repeats forever.\n\tFor example, if routes[0] = [1, 5, 7], this means that the 0^th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.\nYou will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.\nReturn the least number of buses you must take to travel from source to target. Return -1 if it is not possible.\nExample 1:\nInput: routes = [[1,2,7],[3,6,7]], source = 1, target = 6\nOutput: 2\nExplanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\nExample 2:\nInput: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\nOutput: -1\nConstraints:\n\t1 <= routes.length <= 500.\n\t1 <= routes[i].length <= 10^5\n\tAll the values of routes[i] are unique.\n\tsum(routes[i].length) <= 10^5\n\t0 <= routes[i][j] < 10^6\n\t0 <= source, target < 10^6",
        "topics": [
            "Array",
            "Hash Table",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/bus-routes/",
        "givenPythonCode": "class Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int numBusesToDestination(int[][] routes, int source, int target) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[][]} routes\n * @param {number} source\n * @param {number} target\n * @return {number}\n */\nvar numBusesToDestination = function(routes, source, target) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\n\tEach child must have at least one candy.\n\tChildren with a higher rating get more candies than their neighbors.\nReturn the minimum number of candies you need to have to distribute the candies to the children.\nExample 1:\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\nExample 2:\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\nConstraints:\n\tn == ratings.length\n\t1 <= n <= 2 * 10^4\n\t0 <= ratings[i] <= 2 * 10^4",
        "topics": [
            "Array",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/candy/",
        "givenPythonCode": "class Solution:\n    def candy(self, ratings: List[int]) -> int:",
        "givenJsCode": "/**\n * @param {number[]} ratings\n * @return {number}\n */\nvar candy = function(ratings) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int candy(int[] ratings) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\nYou may assume that you have an infinite number of each kind of coin.\nThe answer is guaranteed to fit into a signed 32-bit integer.\nExample 1:\nInput: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nExample 2:\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.\nExample 3:\nInput: amount = 10, coins = [10]\nOutput: 1\nConstraints:\n\t1 <= coins.length <= 300\n\t1 <= coins[i] <= 5000\n\tAll the values of coins are unique.\n\t0 <= amount <= 5000",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/coin-change-ii/",
        "givenPythonCode": "/**\n * @param {number} amount\n * @param {number[]} coins\n * @return {number}\n */\nvar change = function(amount, coins) {\n    \n};",
        "givenJsCode": "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int change(int amount, int[] coins) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.\nExample 1:\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\nExample 2:\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\nConstraints:\n\t1 <= candidates.length <= 100\n\t1 <= candidates[i] <= 50\n\t1 <= target <= 30",
        "topics": [
            "Array",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/combination-sum-ii/",
        "givenPythonCode": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\n\tOnly numbers 1 through 9 are used.\n\tEach number is used at most once.\nReturn a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\nExample 1:\nInput: k = 3, n = 7\nOutput: [[1,2,4]]\nExplanation:\n1 + 2 + 4 = 7\nThere are no other valid combinations.\nExample 2:\nInput: k = 3, n = 9\nOutput: [[1,2,6],[1,3,5],[2,3,4]]\nExplanation:\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\nExample 3:\nInput: k = 4, n = 1\nOutput: []\nExplanation: There are no valid combinations.\nUsing 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.\nConstraints:\n\t2 <= k <= 9\n\t1 <= n <= 60",
        "topics": [
            "Array",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/combination-sum-iii/",
        "givenPythonCode": "/**\n * @param {number} k\n * @param {number} n\n * @return {number[][]}\n */\nvar combinationSum3 = function(k, n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\nThe test cases are generated so that the answer can fit in a 32-bit integer.\nExample 1:\nInput: nums = [1,2,3], target = 4\nOutput: 7\nExplanation:\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\nExample 2:\nInput: nums = [9], target = 3\nOutput: 0\nConstraints:\n\t1 <= nums.length <= 200\n\t1 <= nums[i] <= 1000\n\tAll the elements of nums are unique.\n\t1 <= target <= 1000\nFollow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/combination-sum-iv/",
        "givenPythonCode": "class Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar combinationSum4 = function(nums, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int combinationSum4(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\nExample 1:\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\nExample 2:\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\nExample 3:\nInput: candidates = [2], target = 1\nOutput: []\nConstraints:\n\t1 <= candidates.length <= 30\n\t2 <= candidates[i] <= 40\n\tAll elements of candidates are distinct.\n\t1 <= target <= 40",
        "topics": [
            "Array",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/combination-sum/",
        "givenPythonCode": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        ",
        "givenJsCode": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function(candidates, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.\nExample 1:\nInput: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\nExample 2:\nInput: n = 1, k = 1\nOutput: [[1]]\nExplanation: There is 1 choose 1 = 1 total combination.\nConstraints:\n\t1 <= n <= 20\n\t1 <= k <= n",
        "topics": [
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/combinations/",
        "givenPythonCode": "/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two version strings, version1 and version2, compare them. A version string consists of revisions separated by dots '.'. The value of the revision is its integer conversion ignoring leading zeros.\nTo compare version strings, compare their revision values in left-to-right order. If one of the version strings has fewer revisions, treat the missing revision values as 0.\nReturn the following:\n\tIf version1 < version2, return -1.\n\tIf version1 > version2, return 1.\n\tOtherwise, return 0.\nExample 1:\nInput: version1 = \"1.2\", version2 = \"1.10\"\nOutput: -1\nExplanation:\nversion1's second revision is \"2\" and version2's second revision is \"10\": 2 < 10, so version1 < version2.\nExample 2:\nInput: version1 = \"1.01\", version2 = \"1.001\"\nOutput: 0\nExplanation:\nIgnoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\".\nExample 3:\nInput: version1 = \"1.0\", version2 = \"1.0.0.0\"\nOutput: 0\nExplanation:\nversion1 has less revisions, which means every missing revision are treated as \"0\".\nConstraints:\n\t1 <= version1.length, version2.length <= 500\n\tversion1 and version2 only contain digits and '.'.\n\tversion1 and version2 are valid version numbers.\n\tAll the given revisions in version1 and version2 can be stored in a 32-bit integer.",
        "topics": [
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/compare-version-numbers/",
        "givenPythonCode": "/**\n * @param {string} version1\n * @param {string} version2\n * @return {number}\n */\nvar compareVersion = function(version1, version2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int compareVersion(String version1, String version2) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A complex number can be represented as a string on the form \"real+imaginaryi\" where:\n\treal is the real part and is an integer in the range [-100, 100].\n\timaginary is the imaginary part and is an integer in the range [-100, 100].\n\ti^2 == -1.\nGiven two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications.\nExample 1:\nInput: num1 = \"1+1i\", num2 = \"1+1i\"\nOutput: \"0+2i\"\nExplanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.\nExample 2:\nInput: num1 = \"1+-1i\", num2 = \"1+-1i\"\nOutput: \"0+-2i\"\nExplanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.\nConstraints:\n\tnum1 and num2 are valid complex numbers.",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/complex-number-multiplication/",
        "givenPythonCode": "/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar complexNumberMultiply = function(num1, num2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String complexNumberMultiply(String num1, String num2) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.\nExample 1:\nInput: nums = [1,2,3,1], k = 3\nOutput: true\nExample 2:\nInput: nums = [1,0,1,1], k = 1\nOutput: true\nExample 3:\nInput: nums = [1,2,3,1,2,3], k = 2\nOutput: false\nConstraints:\n\t1 <= nums.length <= 10^5\n\t-10^9 <= nums[i] <= 10^9\n\t0 <= k <= 10^5",
        "topics": [
            "Array",
            "Hash Table",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/contains-duplicate-ii/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {boolean}\n */\nvar containsNearbyDuplicate = function(nums, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: true\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: false\nExample 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\nConstraints:\n\t1 <= nums.length <= 10^5\n\t-10^9 <= nums[i] <= 10^9",
        "topics": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/contains-duplicate/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar containsDuplicate = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.\nExample 1:\nInput: nums = [0,1]\nOutput: 2\nExplanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\nExample 2:\nInput: nums = [0,1,0]\nOutput: 2\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\nConstraints:\n\t1 <= nums.length <= 10^5\n\tnums[i] is either 0 or 1.",
        "topics": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/contiguous-array/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxLength = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findMaxLength(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findMaxLength(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer num, return a string representing its hexadecimal representation. For negative integers, two\u00e2\u20ac\u2122s complement method is used.\nAll the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.\nNote: You are not allowed to use any built-in library method to directly solve this problem.\nExample 1:\nInput: num = 26\nOutput: \"1a\"\nExample 2:\nInput: num = -1\nOutput: \"ffffffff\"\nConstraints:\n\t-2^31 <= num <= 2^31 - 1",
        "topics": [
            "Math",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/convert-a-number-to-hexadecimal/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} num\n * @return {string}\n */\nvar toHex = function(num) {\n    \n};",
        "givenJsCode": "class Solution:\n    def toHex(self, num: int) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String toHex(int num) {\n        \n    }\n}"
    },
    {
        "excercise": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\tcountAndSay(1) = \"1\"\n\tcountAndSay(n) is the run-length encoding of countAndSay(n - 1).\nRun-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string \"3322251\" we replace \"33\" with \"23\", replace \"222\" with \"32\", replace \"5\" with \"15\" and replace \"1\" with \"11\". Thus the compressed string becomes \"23321511\".\nGiven a positive integer n, return the n^th element of the count-and-say sequence.\nExample 1:\nInput: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = RLE of \"1\" = \"11\"\ncountAndSay(3) = RLE of \"11\" = \"21\"\ncountAndSay(4) = RLE of \"21\" = \"1211\"\nExample 2:\nInput: n = 1\nOutput: \"1\"\nExplanation:\nThis is the base case.\nConstraints:\n\t1 <= n <= 30\nFollow up: Could you solve it iteratively?",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/count-and-say/",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {string}\n */\nvar countAndSay = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String countAndSay(int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n.\nExample 1:\nInput: n = 2\nOutput: 91\nExplanation: The answer should be the total numbers in the range of 0 \u00e2\u2030\u00a4 x < 100, excluding 11,22,33,44,55,66,77,88,99\nExample 2:\nInput: n = 0\nOutput: 1\nConstraints:\n\t0 <= n <= 8",
        "topics": [
            "Math",
            "Dynamic Programming",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/count-numbers-with-unique-digits/",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar countNumbersWithUniqueDigits = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int countNumbersWithUniqueDigits(int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\nExample 1:\nInput: n = 2\nOutput: [0,1,1]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\nExample 2:\nInput: n = 5\nOutput: [0,1,1,2,1,2]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\nConstraints:\n\t0 <= n <= 10^5\nFollow up:\n\tIt is very easy to come up with a solution with a runtime of O(n log n). Can you do it in linear time O(n) and possibly in a single pass?\n\tCan you do it without using any built-in function (i.e., like __builtin_popcount in C++)?",
        "topics": [
            "Dynamic Programming",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/counting-bits/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {number[]}\n */\nvar countBits = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] countBits(int n) {\n        \n    }\n}"
    },
    {
        "excercise": "There are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the i^th course should be taken continuously for durationi days and must be finished before or on lastDayi.\nYou will start on the 1^st day and you cannot take two or more courses simultaneously.\nReturn the maximum number of courses that you can take.\nExample 1:\nInput: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]\nOutput: 3\nExplanation: \nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1^st course, it costs 100 days so you will finish it on the 100^th day, and ready to take the next course on the 101^st day.\nSecond, take the 3^rd course, it costs 1000 days so you will finish it on the 1100^th day, and ready to take the next course on the 1101^st day. \nThird, take the 2^nd course, it costs 200 days so you will finish it on the 1300^th day. \nThe 4^th course cannot be taken now, since you will finish it on the 3300^th day, which exceeds the closed date.\nExample 2:\nInput: courses = [[1,2]]\nOutput: 1\nExample 3:\nInput: courses = [[3,2],[4,3]]\nOutput: 0\nConstraints:\n\t1 <= courses.length <= 10^4\n\t1 <= durationi, lastDayi <= 10^4",
        "topics": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/course-schedule-iii/",
        "givenPythonCode": "class Solution:\n    def scheduleCourse(self, courses: List[List[int]]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[][]} courses\n * @return {number}\n */\nvar scheduleCourse = function(courses) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int scheduleCourse(int[][] courses) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A message containing letters from A-Z can be encoded into numbers using the following mapping:\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\nTo decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\n\t\"AAJF\" with the grouping (1 1 10 6)\n\t\"KJF\" with the grouping (11 10 6)\nNote that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".\nIn addition to the mapping above, an encoded message may contain the '*' character, which can represent any digit from '1' to '9' ('0' is excluded). For example, the encoded message \"1*\" may represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\". Decoding \"1*\" is equivalent to decoding any of the encoded messages it can represent.\nGiven a string s consisting of digits and '*' characters, return the number of ways to decode it.\nSince the answer may be very large, return it modulo 10^9 + 7.\nExample 1:\nInput: s = \"*\"\nOutput: 9\nExplanation: The encoded message can represent any of the encoded messages \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", or \"9\".\nEach of these can be decoded to the strings \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", and \"I\" respectively.\nHence, there are a total of 9 ways to decode \"*\".\nExample 2:\nInput: s = \"1*\"\nOutput: 18\nExplanation: The encoded message can represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\".\nEach of these encoded messages have 2 ways to be decoded (e.g. \"11\" can be decoded to \"AA\" or \"K\").\nHence, there are a total of 9 * 2 = 18 ways to decode \"1*\".\nExample 3:\nInput: s = \"2*\"\nOutput: 15\nExplanation: The encoded message can represent any of the encoded messages \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", or \"29\".\n\"21\", \"22\", \"23\", \"24\", \"25\", and \"26\" have 2 ways of being decoded, but \"27\", \"28\", and \"29\" only have 1 way.\nHence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode \"2*\".\nConstraints:\n\t1 <= s.length <= 10^5\n\ts[i] is a digit or '*'.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/decode-ways-ii/",
        "givenPythonCode": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int numDecodings(String s) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar numDecodings = function(s) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.\nIn one step, you can delete exactly one character in either string.\nExample 1:\nInput: word1 = \"sea\", word2 = \"eat\"\nOutput: 2\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".\nExample 2:\nInput: word1 = \"leetcode\", word2 = \"etco\"\nOutput: 4\nConstraints:\n\t1 <= word1.length, word2.length <= 500\n\tword1 and word2 consist of only lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/delete-operation-for-two-strings/",
        "givenPythonCode": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nvar minDistance = function(word1, word2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int minDistance(String word1, String word2) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\tAll letters in this word are capitals, like \"USA\".\n\tAll letters in this word are not capitals, like \"leetcode\".\n\tOnly the first letter in this word is capital, like \"Google\".\nGiven a string word, return true if the usage of capitals in it is right.\nExample 1:\nInput: word = \"USA\"\nOutput: true\nExample 2:\nInput: word = \"FlaG\"\nOutput: false\nConstraints:\n\t1 <= word.length <= 100\n\tword consists of lowercase and uppercase English letters.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/detect-capital/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} word\n * @return {boolean}\n */\nvar detectCapitalUse = function(word) {\n    \n};",
        "givenJsCode": "class Solution:\n    def detectCapitalUse(self, word: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean detectCapitalUse(String word) {\n        \n    }\n}"
    },
    {
        "excercise": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\nThe test cases are generated so that the answer fits on a 32-bit signed integer.\nExample 1:\nInput: s = \"rabbbit\", t = \"rabbit\"\nOutput: 3\nExplanation:\nAs shown below, there are 3 ways you can generate \"rabbit\" from s.\nrabbbit\nrabbbit\nrabbbit\nExample 2:\nInput: s = \"babgbag\", t = \"bag\"\nOutput: 5\nExplanation:\nAs shown below, there are 5 ways you can generate \"bag\" from s.\nbabgbag\nbabgbag\nbabgbag\nbabgbag\nbabgbag\nConstraints:\n\t1 <= s.length, t.length <= 1000\n\ts and t consist of English letters.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/distinct-subsequences/",
        "givenPythonCode": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar numDistinct = function(s, t) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int numDistinct(String s, String t) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u00e2\u02c6\u20192^31, 2^31 \u00e2\u02c6\u2019 1]. For this problem, if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1, and if the quotient is strictly less than -2^31, then return -2^31.\nExample 1:\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\nExample 2:\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\nConstraints:\n\t-2^31 <= dividend, divisor <= 2^31 - 1\n\tdivisor != 0",
        "topics": [
            "Math",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/divide-two-integers/",
        "givenPythonCode": "/**\n * @param {number} dividend\n * @param {number} divisor\n * @return {number}\n */\nvar divide = function(dividend, divisor) {\n    \n};",
        "givenJsCode": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int divide(int dividend, int divisor) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\tInsert a character\n\tDelete a character\n\tReplace a character\nExample 1:\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\nExample 2:\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\nConstraints:\n\t0 <= word1.length, word2.length <= 500\n\tword1 and word2 consist of lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/edit-distance/",
        "givenPythonCode": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nvar minDistance = function(word1, word2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int minDistance(String word1, String word2) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:\n\tThe valid operators are '+', '-', '*', and '/'.\n\tEach operand may be an integer or another expression.\n\tThe division between two integers always truncates toward zero.\n\tThere will not be any division by zero.\n\tThe input represents a valid arithmetic expression in a reverse polish notation.\n\tThe answer and all the intermediate calculations can be represented in a 32-bit integer.\nExample 1:\nInput: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\nExample 2:\nInput: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\nExample 3:\nInput: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\nOutput: 22\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\nConstraints:\n\t1 <= tokens.length <= 10^4\n\ttokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200].",
        "topics": [
            "Array",
            "Math",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/evaluate-reverse-polish-notation/",
        "givenPythonCode": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {string[]} tokens\n * @return {number}\n */\nvar evalRPN = function(tokens) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int evalRPN(String[] tokens) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\nFor example:\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\nExample 1:\nInput: columnTitle = \"A\"\nOutput: 1\nExample 2:\nInput: columnTitle = \"AB\"\nOutput: 28\nExample 3:\nInput: columnTitle = \"ZY\"\nOutput: 701\nConstraints:\n\t1 <= columnTitle.length <= 7\n\tcolumnTitle consists only of uppercase English letters.\n\tcolumnTitle is in the range [\"A\", \"FXSHRXW\"].",
        "topics": [
            "Math",
            "String"
        ],
        "url": "https://leetcode.com/problems/excel-sheet-column-number/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} columnTitle\n * @return {number}\n */\nvar titleToNumber = function(columnTitle) {\n    \n};",
        "givenJsCode": "class Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int titleToNumber(String columnTitle) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.\nFor example:\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\nExample 1:\nInput: columnNumber = 1\nOutput: \"A\"\nExample 2:\nInput: columnNumber = 28\nOutput: \"AB\"\nExample 3:\nInput: columnNumber = 701\nOutput: \"ZY\"\nConstraints:\n\t1 <= columnNumber <= 2^31 - 1",
        "topics": [
            "Math",
            "String"
        ],
        "url": "https://leetcode.com/problems/excel-sheet-column-title/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        ",
        "givenJsCode": "/**\n * @param {number} columnNumber\n * @return {string}\n */\nvar convertToTitle = function(columnNumber) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public String convertToTitle(int columnNumber) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value.\nNote that operands in the returned expressions should not contain leading zeros.\nExample 1:\nInput: num = \"123\", target = 6\nOutput: [\"1*2*3\",\"1+2+3\"]\nExplanation: Both \"1*2*3\" and \"1+2+3\" evaluate to 6.\nExample 2:\nInput: num = \"232\", target = 8\nOutput: [\"2*3+2\",\"2+3*2\"]\nExplanation: Both \"2*3+2\" and \"2+3*2\" evaluate to 8.\nExample 3:\nInput: num = \"3456237490\", target = 9191\nOutput: []\nExplanation: There are no expressions that can be created from \"3456237490\" to evaluate to 9191.\nConstraints:\n\t1 <= num.length <= 10\n\tnum consists of only digits.\n\t-2^31 <= target <= 2^31 - 1",
        "topics": [
            "Math",
            "String",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/expression-add-operators/",
        "givenPythonCode": "class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        ",
        "givenJsCode": "class Solution {\n    public List<String> addOperators(String num, int target) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} num\n * @param {number} target\n * @return {string[]}\n */\nvar addOperators = function(num, target) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\nExample 1:\nInput: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.\nExample 2:\nInput: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.\nExample 3:\nInput: n = 0\nOutput: 0\nConstraints:\n\t0 <= n <= 10^4\nFollow up: Could you write a solution that works in logarithmic time complexity?",
        "topics": [
            "Math"
        ],
        "url": "https://leetcode.com/problems/factorial-trailing-zeroes/",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar trailingZeroes = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int trailingZeroes(int n) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: s = \"cbaebabacd\", p = \"abc\"\nOutput: [0,6]\nExplanation:\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\nExample 2:\nInput: s = \"abab\", p = \"ab\"\nOutput: [0,1,2]\nExplanation:\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\nConstraints:\n\t1 <= s.length, p.length <= 3 * 10^4\n\ts and p consist of lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/find-all-anagrams-in-a-string/",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {string} p\n * @return {number[]}\n */\nvar findAnagrams = function(s, p) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.\nYou must write an algorithm that runs in O(n) time and uses only constant extra space.\nExample 1:\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [2,3]\nExample 2:\nInput: nums = [1,1,2]\nOutput: [1]\nExample 3:\nInput: nums = [1]\nOutput: []\nConstraints:\n\tn == nums.length\n\t1 <= n <= 10^5\n\t1 <= nums[i] <= n\n\tEach element in nums appears once or twice.",
        "topics": [
            "Array",
            "Hash Table"
        ],
        "url": "https://leetcode.com/problems/find-all-duplicates-in-an-array/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar findDuplicates = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.\nExample 1:\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]\nExample 2:\nInput: nums = [1,1]\nOutput: [2]\nConstraints:\n\tn == nums.length\n\t1 <= n <= 10^5\n\t1 <= nums[i] <= n\nFollow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.",
        "topics": [
            "Array",
            "Hash Table"
        ],
        "url": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar findDisappearedNumbers = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order.\nA group of duplicate files consists of at least two files that have the same content.\nA single directory info string in the input list has the following format:\n\t\"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"\nIt means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory \"root/d1/d2/.../dm\". Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.\nThe output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:\n\t\"directory_path/file_name.txt\"\nExample 1:\nInput: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]\nOutput: [[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\nExample 2:\nInput: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]\nOutput: [[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\nConstraints:\n\t1 <= paths.length <= 2 * 10^4\n\t1 <= paths[i].length <= 3000\n\t1 <= sum(paths[i].length) <= 5 * 10^5\n\tpaths[i] consist of English letters, digits, '/', '.', '(', ')', and ' '.\n\tYou may assume no files or directories share the same name in the same directory.\n\tYou may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info.\nFollow up:\n\tImagine you are given a real file system, how will you search files? DFS or BFS?\n\tIf the file content is very large (GB level), how will you modify your solution?\n\tIf you can only read the file by 1kb each time, how will you modify your solution?\n\tWhat is the time complexity of your modified solution? What is the most time-consuming part and memory-consuming part of it? How to optimize?\n\tHow to make sure the duplicated files you find are not false positive?",
        "topics": [
            "Array",
            "Hash Table",
            "String"
        ],
        "url": "https://leetcode.com/problems/find-duplicate-file-in-system/",
        "givenPythonCode": "/**\n * @param {string[]} paths\n * @return {string[][]}\n */\nvar findDuplicate = function(paths) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findDuplicate(self, paths: List[str]) -> List[List[str]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<String>> findDuplicate(String[] paths) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\nConstraints:\n\t0 <= nums.length <= 10^5\n\t-10^9 <= nums[i] <= 10^9\n\tnums is a non-decreasing array.\n\t-10^9 <= target <= 10^9",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/",
        "givenPythonCode": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar searchRange = function(nums, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\nExample 1:\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]]\nExplanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\nExample 2:\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [[1,1],[1,1]]\nExplanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\nConstraints:\n\t1 <= nums1.length, nums2.length <= 10^5\n\t-10^9 <= nums1[i], nums2[i] <= 10^9\n\tnums1 and nums2 both are sorted in non-decreasing order.\n\t1 <= k <= 10^4\n\tk <= nums1.length * nums2.length",
        "topics": [
            "Array",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/find-k-pairs-with-smallest-sums/",
        "givenPythonCode": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number[][]}\n */\nvar kSmallestPairs = function(nums1, nums2, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "The distance of a pair of integers a and b is defined as the absolute difference between a and b.\nGiven an integer array nums and an integer k, return the k^th smallest distance among all the pairs nums[i] and nums[j] where 0 <= i < j < nums.length.\nExample 1:\nInput: nums = [1,3,1], k = 1\nOutput: 0\nExplanation: Here are all the pairs:\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\nThen the 1^st smallest distance pair is (1,1), and its distance is 0.\nExample 2:\nInput: nums = [1,1,1], k = 2\nOutput: 0\nExample 3:\nInput: nums = [1,6,1], k = 3\nOutput: 5\nConstraints:\n\tn == nums.length\n\t2 <= n <= 10^4\n\t0 <= nums[i] <= 10^6\n\t1 <= k <= n * (n - 1) / 2",
        "topics": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/find-k-th-smallest-pair-distance/",
        "givenPythonCode": "class Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar smallestDistancePair = function(nums, k) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:\n\t[4,5,6,7,0,1,4] if it was rotated 4 times.\n\t[0,1,4,4,5,6,7] if it was rotated 7 times.\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums that may contain duplicates, return the minimum element of this array.\nYou must decrease the overall operation steps as much as possible.\nExample 1:\nInput: nums = [1,3,5]\nOutput: 1\nExample 2:\nInput: nums = [2,2,2,0,1]\nOutput: 0\nConstraints:\n\tn == nums.length\n\t1 <= n <= 5000\n\t-5000 <= nums[i] <= 5000\n\tnums is sorted and rotated between 1 and n times.\nFollow up: This problem is similar to Find Minimum in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/",
        "givenPythonCode": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int findMin(int[] nums) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function(nums) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\t[4,5,6,7,0,1,2] if it was rotated 4 times.\n\t[0,1,2,4,5,6,7] if it was rotated 7 times.\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\nExample 2:\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\nExample 3:\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times. \nConstraints:\n\tn == nums.length\n\t1 <= n <= 5000\n\t-5000 <= nums[i] <= 5000\n\tAll the integers of nums are unique.\n\tnums is sorted and rotated between 1 and n times.",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findMin(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u00e2\u02c6\u017e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\nExample 2:\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\nConstraints:\n\t1 <= nums.length <= 1000\n\t-2^31 <= nums[i] <= 2^31 - 1\n\tnums[i] != nums[i + 1] for all valid i.",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/find-peak-element/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findPeakElement = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findPeakElement(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\nThe right interval for an interval i is an interval j such that startj >= endi and startj is minimized. Note that i may equal j.\nReturn an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.\nExample 1:\nInput: intervals = [[1,2]]\nOutput: [-1]\nExplanation: There is only one interval in the collection, so it outputs -1.\nExample 2:\nInput: intervals = [[3,4],[2,3],[1,2]]\nOutput: [-1,0,1]\nExplanation: There is no right interval for [3,4].\nThe right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is >= end1 = 3.\nThe right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is >= end2 = 2.\nExample 3:\nInput: intervals = [[1,4],[2,3],[3,4]]\nOutput: [-1,2,-1]\nExplanation: There is no right interval for [1,4] and [3,4].\nThe right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is >= end1 = 3.\nConstraints:\n\t1 <= intervals.length <= 2 * 10^4\n\tintervals[i].length == 2\n\t-10^6 <= starti <= endi <= 10^6\n\tThe start point of each interval is unique.",
        "topics": [
            "Array",
            "Binary Search",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/find-right-interval/",
        "givenPythonCode": "/**\n * @param {number[][]} intervals\n * @return {number[]}\n */\nvar findRightInterval = function(intervals) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] findRightInterval(int[][] intervals) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given two strings s and t.\nString t is generated by random shuffling string s and then add one more letter at a random position.\nReturn the letter that was added to t.\nExample 1:\nInput: s = \"abcd\", t = \"abcde\"\nOutput: \"e\"\nExplanation: 'e' is the letter that was added.\nExample 2:\nInput: s = \"\", t = \"y\"\nOutput: \"y\"\nConstraints:\n\t0 <= s.length <= 1000\n\tt.length == s.length + 1\n\ts and t consist of lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/find-the-difference/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {character}\n */\nvar findTheDifference = function(s, t) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public char findTheDifference(String s, String t) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this repeated number.\nYou must solve the problem without modifying the array nums and uses only constant extra space.\nExample 1:\nInput: nums = [1,3,4,2,2]\nOutput: 2\nExample 2:\nInput: nums = [3,1,3,4,2]\nOutput: 3\nExample 3:\nInput: nums = [3,3,3,3,3]\nOutput: 3\nConstraints:\n\t1 <= n <= 10^5\n\tnums.length == n + 1\n\t1 <= nums[i] <= n\n\tAll the integers in nums appear only once except for precisely one integer which appears two or more times.\nFollow up:\n\tHow can we prove that at least one duplicate number must exist in nums?\n\tCan you solve the problem in linear runtime complexity?",
        "topics": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/find-the-duplicate-number/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDuplicate = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findDuplicate(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\nExample 1:\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\nExample 2:\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\nExample 3:\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.\nConstraints:\n\t1 <= nums.length <= 10^5\n\t-2^31 <= nums[i] <= 2^31 - 1",
        "topics": [
            "Array",
            "Hash Table"
        ],
        "url": "https://leetcode.com/problems/first-missing-positive/",
        "givenPythonCode": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar firstMissingPositive = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n, return a string array answer (1-indexed) where:\n\tanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\n\tanswer[i] == \"Fizz\" if i is divisible by 3.\n\tanswer[i] == \"Buzz\" if i is divisible by 5.\n\tanswer[i] == i (as a string) if none of the above conditions are true.\nExample 1:\nInput: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]\nExample 2:\nInput: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\nExample 3:\nInput: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\nConstraints:\n\t1 <= n <= 10^4",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/fizz-buzz/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {string[]}\n */\nvar fizzBuzz = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<String> fizzBuzz(int n) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format.\nThe final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1.\nExample 1:\nInput: expression = \"-1/2+1/2\"\nOutput: \"0/1\"\nExample 2:\nInput: expression = \"-1/2+1/2+1/3\"\nOutput: \"1/3\"\nExample 3:\nInput: expression = \"1/3-1/2\"\nOutput: \"-1/6\"\nConstraints:\n\tThe input string only contains '0' to '9', '/', '+' and '-'. So does the output.\n\tEach fraction (input and output) has the format \u00c2\u00b1numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted.\n\tThe input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1, 10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.\n\tThe number of given fractions will be in the range [1, 10].\n\tThe numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/fraction-addition-and-subtraction/",
        "givenPythonCode": "/**\n * @param {string} expression\n * @return {string}\n */\nvar fractionAddition = function(expression) {\n    \n};",
        "givenJsCode": "class Solution:\n    def fractionAddition(self, expression: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String fractionAddition(String expression) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, return any of them.\nIt is guaranteed that the length of the answer string is less than 10^4 for all the given inputs.\nExample 1:\nInput: numerator = 1, denominator = 2\nOutput: \"0.5\"\nExample 2:\nInput: numerator = 2, denominator = 1\nOutput: \"2\"\nExample 3:\nInput: numerator = 4, denominator = 333\nOutput: \"0.(012)\"\nConstraints:\n\t-2^31 <= numerator, denominator <= 2^31 - 1\n\tdenominator != 0",
        "topics": [
            "Hash Table",
            "Math",
            "String"
        ],
        "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/",
        "givenPythonCode": "/**\n * @param {number} numerator\n * @param {number} denominator\n * @return {string}\n */\nvar fractionToDecimal = function(numerator, denominator) {\n    \n};",
        "givenJsCode": "class Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\nGiven a list of stones positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\nIf the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\nExample 1:\nInput: stones = [0,1,3,5,6,8,12,17]\nOutput: true\nExplanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\nExample 2:\nInput: stones = [0,1,2,3,4,8,9,11]\nOutput: false\nExplanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\nConstraints:\n\t2 <= stones.length <= 2000\n\t0 <= stones[i] <= 2^31 - 1\n\tstones[0] == 0\n\tstones is sorted in a strictly increasing order.",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/frog-jump/",
        "givenPythonCode": "class Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        ",
        "givenJsCode": "class Solution {\n    public boolean canCross(int[] stones) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} stones\n * @return {boolean}\n */\nvar canCross = function(stones) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "There are n gas stations along a circular route, where the amount of gas at the i^th station is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the i^th station to its next (i + 1)^th station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique\nExample 1:\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\nExample 2:\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\nConstraints:\n\tn == gas.length == cost.length\n\t1 <= n <= 10^5\n\t0 <= gas[i], cost[i] <= 10^4",
        "topics": [
            "Array",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/gas-station/",
        "givenPythonCode": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} gas\n * @param {number[]} cost\n * @return {number}\n */\nvar canCompleteCircuit = function(gas, cost) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "An n-bit gray code sequence is a sequence of 2^n integers where:\n\tEvery integer is in the inclusive range [0, 2^n - 1],\n\tThe first integer is 0,\n\tAn integer appears no more than once in the sequence,\n\tThe binary representation of every pair of adjacent integers differs by exactly one bit, and\n\tThe binary representation of the first and last integers differs by exactly one bit.\nGiven an integer n, return any valid n-bit gray code sequence.\nExample 1:\nInput: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit\nExample 2:\nInput: n = 1\nOutput: [0,1]\nConstraints:\n\t1 <= n <= 16",
        "topics": [
            "Math",
            "Backtracking",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/gray-code/",
        "givenPythonCode": "class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        ",
        "givenJsCode": "/**\n * @param {number} n\n * @return {number[]}\n */\nvar grayCode = function(n) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public List<Integer> grayCode(int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\nExample 2:\nInput: strs = [\"\"]\nOutput: [[\"\"]]\nExample 3:\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\nConstraints:\n\t1 <= strs.length <= 10^4\n\t0 <= strs[i].length <= 100\n\tstrs[i] consists of lowercase English letters.",
        "topics": [
            "Array",
            "Hash Table",
            "String",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/group-anagrams/",
        "givenPythonCode": "/**\n * @param {string[]} strs\n * @return {string[][]}\n */\nvar groupAnagrams = function(strs) {\n    \n};",
        "givenJsCode": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their i^th paper and citations is sorted in ascending order, return the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\nYou must write an algorithm that runs in logarithmic time.\nExample 1:\nInput: citations = [0,1,3,5,6]\nOutput: 3\nExplanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\nExample 2:\nInput: citations = [1,2,100]\nOutput: 2\nConstraints:\n\tn == citations.length\n\t1 <= n <= 10^5\n\t0 <= citations[i] <= 1000\n\tcitations is sorted in ascending order.",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/h-index-ii/",
        "givenPythonCode": "/**\n * @param {number[]} citations\n * @return {number}\n */\nvar hIndex = function(citations) {\n    \n};",
        "givenJsCode": "class Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int hIndex(int[] citations) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, return the Hamming distance between them.\nExample 1:\nInput: x = 1, y = 4\nOutput: 2\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       \u00e2\u2020\u2018   \u00e2\u2020\u2018\nThe above arrows point to positions where the corresponding bits are different.\nExample 2:\nInput: x = 3, y = 1\nOutput: 1\nConstraints:\n\t0 <= x, y <= 2^31 - 1",
        "topics": [
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/hamming-distance/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nvar hammingDistance = function(x, y) {\n    \n};",
        "givenJsCode": "class Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int hammingDistance(int x, int y) {\n        \n    }\n}"
    },
    {
        "excercise": "Write an algorithm to determine if a number n is happy.\nA happy number is a number defined by the following process:\n\tStarting with any positive integer, replace the number by the sum of the squares of its digits.\n\tRepeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n\tThose numbers for which this process ends in 1 are happy.\nReturn true if n is a happy number, and false if not.\nExample 1:\nInput: n = 19\nOutput: true\nExplanation:\n1^2 + 9^2 = 82\n8^2 + 2^2 = 68\n6^2 + 8^2 = 100\n1^2 + 0^2 + 0^2 = 1\nExample 2:\nInput: n = 2\nOutput: false\nConstraints:\n\t1 <= n <= 2^31 - 1",
        "topics": [
            "Hash Table",
            "Math",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/happy-number/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {boolean}\n */\nvar isHappy = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isHappy(int n) {\n        \n    }\n}"
    },
    {
        "excercise": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\nInput: nums = [1,2,3]\nOutput: 3\nConstraints:\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 1000",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/house-robber-ii/",
        "givenPythonCode": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int rob(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 400",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/house-robber/",
        "givenPythonCode": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int rob(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.\nExample 1:\nInput: nums = [1,2,3,4,5]\nOutput: true\nExplanation: Any triplet where i < j < k is valid.\nExample 2:\nInput: nums = [5,4,3,2,1]\nOutput: false\nExplanation: No triplet exists.\nExample 3:\nInput: nums = [2,1,5,0,4,6]\nOutput: true\nExplanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.\nConstraints:\n\t1 <= nums.length <= 5 * 10^5\n\t-2^31 <= nums[i] <= 2^31 - 1\nFollow up: Could you implement a solution that runs in O(n) time complexity and O(1) space complexity?",
        "topics": [
            "Array",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/increasing-triplet-subsequence/",
        "givenPythonCode": "class Solution:\n    def increasingTriplet(self, nums: List[int]) -> bool:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar increasingTriplet = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public boolean increasingTriplet(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the i^th interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nNote that you don't need to modify intervals in-place. You can make a new array and return it.\nExample 1:\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\nExample 2:\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\nConstraints:\n\t0 <= intervals.length <= 10^4\n\tintervals[i].length == 2\n\t0 <= starti <= endi <= 10^5\n\tintervals is sorted by starti in ascending order.\n\tnewInterval.length == 2\n\t0 <= start <= end <= 10^5",
        "topics": [
            "Array"
        ],
        "url": "https://leetcode.com/problems/insert-interval/",
        "givenPythonCode": "/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nvar insert = function(intervals, newInterval) {\n    \n};",
        "givenJsCode": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.\nReturn the maximum product you can get.\nExample 1:\nInput: n = 2\nOutput: 1\nExplanation: 2 = 1 + 1, 1 \u00c3\u2014 1 = 1.\nExample 2:\nInput: n = 10\nOutput: 36\nExplanation: 10 = 3 + 3 + 4, 3 \u00c3\u2014 3 \u00c3\u2014 4 = 36.\nConstraints:\n\t2 <= n <= 58",
        "topics": [
            "Math",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/integer-break/",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar integerBreak = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def integerBreak(self, n: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int integerBreak(int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.\nExample 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2,2]\nExample 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [4,9]\nExplanation: [9,4] is also accepted.\nConstraints:\n\t1 <= nums1.length, nums2.length <= 1000\n\t0 <= nums1[i], nums2[i] <= 1000\nFollow up:\n\tWhat if the given array is already sorted? How would you optimize your algorithm?\n\tWhat if nums1's size is small compared to nums2's size? Which algorithm is better?\n\tWhat if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?",
        "topics": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/intersection-of-two-arrays-ii/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersect = function(nums1, nums2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        \n    }\n}"
    },
    {
        "excercise": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\nExample 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]\nExample 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4]\nExplanation: [4,9] is also accepted.\nConstraints:\n\t1 <= nums1.length, nums2.length <= 1000\n\t0 <= nums1[i], nums2[i] <= 1000",
        "topics": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/intersection-of-two-arrays/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersection = function(nums1, nums2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        \n    }\n}"
    },
    {
        "excercise": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\nYou are given n projects where the i^th project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\nThe answer is guaranteed to fit in a 32-bit signed integer.\nExample 1:\nInput: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\nOutput: 4\nExplanation: Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\nExample 2:\nInput: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\nOutput: 6\nConstraints:\n\t1 <= k <= 10^5\n\t0 <= w <= 10^9\n\tn == profits.length\n\tn == capital.length\n\t1 <= n <= 10^5\n\t0 <= profits[i] <= 10^4\n\t0 <= capital[i] <= 10^9",
        "topics": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/ipo/",
        "givenPythonCode": "class Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} k\n * @param {number} w\n * @param {number[]} profits\n * @param {number[]} capital\n * @return {number}\n */\nvar findMaximizedCapital = function(k, w, profits, capital) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\nExample 1:\nInput: s = \"abc\", t = \"ahbgdc\"\nOutput: true\nExample 2:\nInput: s = \"axc\", t = \"ahbgdc\"\nOutput: false\nConstraints:\n\t0 <= s.length <= 100\n\t0 <= t.length <= 10^4\n\ts and t consist only of lowercase English letters.\nFollow up: Suppose there are lots of incoming s, say s1, s2, ..., sk where k >= 10^9, and you want to check one by one to see if t has its subsequence. In this scenario, how would you change your code?",
        "topics": [
            "Two Pointers",
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/is-subsequence/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isSubsequence = function(s, t) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        \n    }\n}"
    },
    {
        "excercise": "Given two strings s and t, determine if they are isomorphic.\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\nExample 1:\nInput: s = \"egg\", t = \"add\"\nOutput: true\nExample 2:\nInput: s = \"foo\", t = \"bar\"\nOutput: false\nExample 3:\nInput: s = \"paper\", t = \"title\"\nOutput: true\nConstraints:\n\t1 <= s.length <= 5 * 10^4\n\tt.length == s.length\n\ts and t consist of any valid ascii character.",
        "topics": [
            "Hash Table",
            "String"
        ],
        "url": "https://leetcode.com/problems/isomorphic-strings/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isIsomorphic = function(s, t) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        \n    }\n}"
    },
    {
        "excercise": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n\t0 <= j <= nums[i] and\n\ti + j < n\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\nExample 1:\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\nExample 2:\nInput: nums = [2,3,0,1,4]\nOutput: 2\nConstraints:\n\t1 <= nums.length <= 10^4\n\t0 <= nums[i] <= 1000\n\tIt's guaranteed that you can reach nums[n - 1].",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/jump-game-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int jump(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1:\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\nExample 2:\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\nConstraints:\n\t1 <= nums.length <= 10^4\n\t0 <= nums[i] <= 10^5",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/jump-game/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean canJump(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\n\t0 <= i, j < nums.length\n\ti != j\n\t|nums[i] - nums[j]| == k\nNotice that |val| denotes the absolute value of val.\nExample 1:\nInput: nums = [3,1,4,1,5], k = 2\nOutput: 2\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).\nAlthough we have two 1s in the input, we should only return the number of unique pairs.\nExample 2:\nInput: nums = [1,2,3,4,5], k = 1\nOutput: 4\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\nExample 3:\nInput: nums = [1,3,1,5,4], k = 0\nOutput: 1\nExplanation: There is one 0-diff pair in the array, (1, 1).\nConstraints:\n\t1 <= nums.length <= 10^4\n\t-10^7 <= nums[i] <= 10^7\n\t0 <= k <= 10^7",
        "topics": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/k-diff-pairs-in-an-array/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findPairs = function(nums, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findPairs(self, nums: List[int], k: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findPairs(int[] nums, int k) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.length and nums[i] > nums[j].\nGiven two integers n and k, return the number of different arrays consisting of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 10^9 + 7.\nExample 1:\nInput: n = 3, k = 0\nOutput: 1\nExplanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs.\nExample 2:\nInput: n = 3, k = 1\nOutput: 2\nExplanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.\nConstraints:\n\t1 <= n <= 1000\n\t0 <= k <= 1000",
        "topics": [
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/k-inverse-pairs-array/",
        "givenPythonCode": "class Solution:\n    def kInversePairs(self, n: int, k: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int kInversePairs(int n, int k) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar kInversePairs = function(n, k) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:\n\tanswer[i] % answer[j] == 0, or\n\tanswer[j] % answer[i] == 0\nIf there are multiple solutions, return any of them.\nExample 1:\nInput: nums = [1,2,3]\nOutput: [1,2]\nExplanation: [1,3] is also accepted.\nExample 2:\nInput: nums = [1,2,4,8]\nOutput: [1,2,4,8]\nConstraints:\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 2 * 10^9\n\tAll the integers in nums are unique.",
        "topics": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/largest-divisible-subset/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar largestDivisibleSubset = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<Integer> largestDivisibleSubset(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.\nSince the result may be very large, so you need to return a string instead of an integer.\nExample 1:\nInput: nums = [10,2]\nOutput: \"210\"\nExample 2:\nInput: nums = [3,30,34,5,9]\nOutput: \"9534330\"\nConstraints:\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 10^9",
        "topics": [
            "Array",
            "String",
            "Greedy",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/largest-number/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {string}\n */\nvar largestNumber = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String largestNumber(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digits integers. Since the answer can be very large, return it modulo 1337.\nExample 1:\nInput: n = 2\nOutput: 987\nExplanation: 99 x 91 = 9009, 9009 % 1337 = 987\nExample 2:\nInput: n = 1\nOutput: 9\nConstraints:\n\t1 <= n <= 8",
        "topics": [
            "Math",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/largest-palindrome-product/",
        "givenPythonCode": "class Solution:\n    def largestPalindrome(self, n: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int largestPalindrome(int n) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar largestPalindrome = function(n) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.\nExample 1:\nInput: s = \"Hello World\"\nOutput: 5\nExplanation: The last word is \"World\" with length 5.\nExample 2:\nInput: s = \"   fly me   to   the moon  \"\nOutput: 4\nExplanation: The last word is \"moon\" with length 4.\nExample 3:\nInput: s = \"luffy is still joyboy\"\nOutput: 6\nExplanation: The last word is \"joyboy\" with length 6.\nConstraints:\n\t1 <= s.length <= 10^4\n\ts consists of only English letters and spaces ' '.\n\tThere will be at least one word in s.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/length-of-last-word/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLastWord = function(s) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int lengthOfLastWord(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.\nWe want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.\nReturn the reformatted license key.\nExample 1:\nInput: s = \"5F3Z-2e-9-w\", k = 4\nOutput: \"5F3Z-2E9W\"\nExplanation: The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\nExample 2:\nInput: s = \"2-5g-3-J\", k = 2\nOutput: \"2-5G-3J\"\nExplanation: The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\nConstraints:\n\t1 <= s.length <= 10^5\n\ts consists of English letters, digits, and dashes '-'.\n\t1 <= k <= 10^4",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/license-key-formatting/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar licenseKeyFormatting = function(s, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String licenseKeyFormatting(String s, int k) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums, return the length of the longest strictly increasing subsequence.\nExample 1:\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\nExample 2:\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\nExample 3:\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\nConstraints:\n\t1 <= nums.length <= 2500\n\t-10^4 <= nums[i] <= 10^4\nFollow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?",
        "topics": [
            "Array",
            "Binary Search",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/longest-increasing-subsequence/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar lengthOfLIS = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.\nLetters are case sensitive, for example, \"Aa\" is not considered a palindrome.\nExample 1:\nInput: s = \"abccccdd\"\nOutput: 7\nExplanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7.\nExample 2:\nInput: s = \"a\"\nOutput: 1\nExplanation: The longest palindrome that can be built is \"a\", whose length is 1.\nConstraints:\n\t1 <= s.length <= 2000\n\ts consists of lowercase and/or uppercase English letters only.",
        "topics": [
            "Hash Table",
            "String",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/longest-palindrome/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def longestPalindrome(self, s: str) -> int:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestPalindrome = function(s) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int longestPalindrome(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string s, find the longest palindromic subsequence's length in s.\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\nInput: s = \"bbbab\"\nOutput: 4\nExplanation: One possible longest palindromic subsequence is \"bbbb\".\nExample 2:\nInput: s = \"cbbd\"\nOutput: 2\nExplanation: One possible longest palindromic subsequence is \"bb\".\nConstraints:\n\t1 <= s.length <= 1000\n\ts consists only of lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/longest-palindromic-subsequence/",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestPalindromeSubseq = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int longestPalindromeSubseq(String s) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s, return the longest palindromic substring in s.\nExample 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\nExample 2:\nInput: s = \"cbbd\"\nOutput: \"bb\"\nConstraints:\n\t1 <= s.length <= 1000\n\ts consist of only digits and English letters.",
        "topics": [
            "Two Pointers",
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/longest-palindromic-substring/",
        "givenPythonCode": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public String longestPalindrome(String s) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\nExample 1:\nInput: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.\nExample 2:\nInput: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.\nConstraints:\n\t1 <= s.length <= 10^5\n\ts consists of only uppercase English letters.\n\t0 <= k <= s.length",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/longest-repeating-character-replacement/",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar characterReplacement = function(s, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int characterReplacement(String s, int k) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s, find the length of the longest substring without repeating characters.\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\nExample 3:\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\nConstraints:\n\t0 <= s.length <= 5 * 10^4\n\ts consists of English letters, digits, symbols and spaces.",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
        "givenPythonCode": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If no such uncommon subsequence exists, return -1.\nAn uncommon subsequence between two strings is a string that is a subsequence of exactly one of them.\nExample 1:\nInput: a = \"aba\", b = \"cdc\"\nOutput: 3\nExplanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\".\nNote that \"cdc\" is also a longest uncommon subsequence.\nExample 2:\nInput: a = \"aaa\", b = \"bbb\"\nOutput: 3\nExplanation: The longest uncommon subsequences are \"aaa\" and \"bbb\".\nExample 3:\nInput: a = \"aaa\", b = \"aaa\"\nOutput: -1\nExplanation: Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a. So the answer would be -1.\nConstraints:\n\t1 <= a.length, b.length <= 100\n\ta and b consist of lower-case English letters.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/longest-uncommon-subsequence-i/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        ",
        "givenJsCode": "/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nvar findLUSlength = function(a, b) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int findLUSlength(String a, String b) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1.\nAn uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others.\nA subsequence of a string s is a string that can be obtained after deleting any number of characters from s.\n\tFor example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string).\nExample 1:\nInput: strs = [\"aba\",\"cdc\",\"eae\"]\nOutput: 3\nExample 2:\nInput: strs = [\"aaa\",\"aaa\",\"aa\"]\nOutput: -1\nConstraints:\n\t2 <= strs.length <= 50\n\t1 <= strs[i].length <= 10\n\tstrs[i] consists of lowercase English letters.",
        "topics": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "String",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/longest-uncommon-subsequence-ii/",
        "givenPythonCode": "/**\n * @param {string[]} strs\n * @return {number}\n */\nvar findLUSlength = function(strs) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findLUSlength(self, strs: List[str]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findLUSlength(String[] strs) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\nExample 1:\nInput: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".\nExample 2:\nInput: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".\nExample 3:\nInput: s = \"\"\nOutput: 0\nConstraints:\n\t0 <= s.length <= 3 * 10^4\n\ts[i] is '(', or ')'.",
        "topics": [
            "String",
            "Dynamic Programming",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/longest-valid-parentheses/",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestValidParentheses = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int longestValidParentheses(String s) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\nExample 1:\nInput: s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"]\nOutput: \"apple\"\nExample 2:\nInput: s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"]\nOutput: \"a\"\nConstraints:\n\t1 <= s.length <= 1000\n\t1 <= dictionary.length <= 1000\n\t1 <= dictionary[i].length <= 1000\n\ts and dictionary[i] consist of lowercase English letters.",
        "topics": [
            "Array",
            "Two Pointers",
            "String",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {string[]} dictionary\n * @return {string}\n */\nvar findLongestWord = function(s, dictionary) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findLongestWord(self, s: str, dictionary: List[str]) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String findLongestWord(String s, List<String> dictionary) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an integer array of size n, find all elements that appear more than \u00e2\u0152\u0160 n/3 \u00e2\u0152\u2039 times.\nExample 1:\nInput: nums = [3,2,3]\nOutput: [3]\nExample 2:\nInput: nums = [1]\nOutput: [1]\nExample 3:\nInput: nums = [1,2]\nOutput: [1,2]\nConstraints:\n\t1 <= nums.length <= 5 * 10^4\n\t-10^9 <= nums[i] <= 10^9\nFollow up: Could you solve the problem in linear time and in O(1) space?",
        "topics": [
            "Array",
            "Hash Table",
            "Sorting",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/majority-element-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar majorityElement = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a binary array nums, return the maximum number of consecutive 1's in the array.\nExample 1:\nInput: nums = [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\nExample 2:\nInput: nums = [1,0,1,1,0,1]\nOutput: 2\nConstraints:\n\t1 <= nums.length <= 10^5\n\tnums[i] is either 0 or 1.",
        "topics": [
            "Array"
        ],
        "url": "https://leetcode.com/problems/max-consecutive-ones/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxConsecutiveOnes = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.\nExample 1:\nInput: words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]\nOutput: 16\nExplanation: The two words can be \"abcw\", \"xtfn\".\nExample 2:\nInput: words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]\nOutput: 4\nExplanation: The two words can be \"ab\", \"cd\".\nExample 3:\nInput: words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\nOutput: 0\nExplanation: No such pair of words.\nConstraints:\n\t2 <= words.length <= 1000\n\t1 <= words[i].length <= 1000\n\twords[i] consists only of lowercase English letters.",
        "topics": [
            "Array",
            "String",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/maximum-product-of-word-lengths/",
        "givenPythonCode": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar maxProduct = function(words) {\n    \n};",
        "givenJsCode": "class Solution:\n    def maxProduct(self, words: List[str]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int maxProduct(String[] words) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, find a subarray that has the largest product, and return the product.\nThe test cases are generated so that the answer will fit in a 32-bit integer.\nExample 1:\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.\nExample 2:\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.\nConstraints:\n\t1 <= nums.length <= 2 * 10^4\n\t-10 <= nums[i] <= 10\n\tThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/maximum-product-subarray/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxProduct = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int maxProduct(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with maximum sum and return them.\nReturn the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.\nExample 1:\nInput: nums = [1,2,1,2,6,7,5,1], k = 2\nOutput: [0,3,5]\nExplanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\nWe could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.\nExample 2:\nInput: nums = [1,2,1,2,1,2,1,2,1], k = 2\nOutput: [0,2,4]\nConstraints:\n\t1 <= nums.length <= 2 * 10^4\n\t1 <= nums[i] < 2^16\n\t1 <= k <= floor(nums.length / 3)",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/",
        "givenPythonCode": "class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        ",
        "givenJsCode": "class Solution {\n    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSumOfThreeSubarrays = function(nums, k) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\nExample 1:\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\nExample 2:\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\nConstraints:\n\t1 <= intervals.length <= 10^4\n\tintervals[i].length == 2\n\t0 <= starti <= endi <= 10^4",
        "topics": [
            "Array",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/merge-intervals/",
        "givenPythonCode": "/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nvar merge = function(intervals) {\n    \n};",
        "givenJsCode": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\nExample 2:\nInput: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].\nExample 3:\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\nConstraints:\n\tnums1.length == m + n\n\tnums2.length == n\n\t0 <= m, n <= 200\n\t1 <= m + n <= 200\n\t-10^9 <= nums1[i], nums2[j] <= 10^9\nFollow up: Can you come up with an algorithm that runs in O(m + n) time?",
        "topics": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/merge-sorted-array/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function(nums1, m, nums2, n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        ",
        "givenJavaCode": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        \n    }\n}"
    },
    {
        "excercise": "There are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the i^th worker and wage[i] is the minimum wage expectation for the i^th worker.\nWe want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:\n\tEvery worker in the paid group must be paid at least their minimum wage expectation.\n\tIn the group, each worker's pay must be directly proportional to their quality. This means if a worker\u00e2\u20ac\u2122s quality is double that of another worker in the group, then they must be paid twice as much as the other worker.\nGiven the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10^-5 of the actual answer will be accepted.\nExample 1:\nInput: quality = [10,20,5], wage = [70,50,30], k = 2\nOutput: 105.00000\nExplanation: We pay 70 to 0^th worker and 35 to 2^nd worker.\nExample 2:\nInput: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\nOutput: 30.66667\nExplanation: We pay 4 to 0^th worker, 13.33333 to 2^nd and 3^rd workers separately.\nConstraints:\n\tn == quality.length == wage.length\n\t1 <= k <= n <= 10^4\n\t1 <= quality[i], wage[i] <= 10^4",
        "topics": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/minimum-cost-to-hire-k-workers/",
        "givenPythonCode": "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        ",
        "givenJsCode": "class Solution {\n    public double mincostToHireWorkers(int[] quality, int[] wage, int k) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} quality\n * @param {number[]} wage\n * @param {number} k\n * @return {number}\n */\nvar mincostToHireWorkers = function(quality, wage, k) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.\nSuppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.\n\tFor example, \"AACCGGTT\" --> \"AACCGGTA\" is one mutation.\nThere is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\nGiven the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.\nNote that the starting point is assumed to be valid, so it might not be included in the bank.\nExample 1:\nInput: startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\nOutput: 1\nExample 2:\nInput: startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\nOutput: 2\nConstraints:\n\t0 <= bank.length <= 10\n\tstartGene.length == endGene.length == bank[i].length == 8\n\tstartGene, endGene, and bank[i] consist of only the characters ['A', 'C', 'G', 'T'].",
        "topics": [
            "Hash Table",
            "String",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/minimum-genetic-mutation/",
        "givenPythonCode": "/**\n * @param {string} startGene\n * @param {string} endGene\n * @param {string[]} bank\n * @return {number}\n */\nvar minMutation = function(startGene, endGene, bank) {\n    \n};",
        "givenJsCode": "class Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int minMutation(String startGene, String endGene, String[] bank) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\nIn one move, you can increment or decrement an element of the array by 1.\nTest cases are designed so that the answer will fit in a 32-bit integer.\nExample 1:\nInput: nums = [1,2,3]\nOutput: 2\nExplanation:\nOnly two moves are needed (remember each move increments or decrements one element):\n[1,2,3]  =>  [2,2,3]  =>  [2,2,2]\nExample 2:\nInput: nums = [1,10,2,9]\nOutput: 16\nConstraints:\n\tn == nums.length\n\t1 <= nums.length <= 10^5\n\t-10^9 <= nums[i] <= 10^9",
        "topics": [
            "Array",
            "Math",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/",
        "givenPythonCode": "class Solution:\n    def minMoves2(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minMoves2 = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int minMoves2(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\nIn one move, you can increment n - 1 elements of the array by 1.\nExample 1:\nInput: nums = [1,2,3]\nOutput: 3\nExplanation: Only three moves are needed (remember each move increments two elements):\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]\nExample 2:\nInput: nums = [1,1,1]\nOutput: 0\nConstraints:\n\tn == nums.length\n\t1 <= nums.length <= 10^5\n\t-10^9 <= nums[i] <= 10^9\n\tThe answer is guaranteed to fit in a 32-bit integer.",
        "topics": [
            "Array",
            "Math"
        ],
        "url": "https://leetcode.com/problems/minimum-moves-to-equal-array-elements/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minMoves = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def minMoves(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int minMoves(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\nExample 1:\nInput: points = [[10,16],[2,8],[1,6],[7,12]]\nOutput: 2\nExplanation: The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].\n- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].\nExample 2:\nInput: points = [[1,2],[3,4],[5,6],[7,8]]\nOutput: 4\nExplanation: One arrow needs to be shot for each balloon for a total of 4 arrows.\nExample 3:\nInput: points = [[1,2],[2,3],[3,4],[4,5]]\nOutput: 2\nExplanation: The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].\n- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].\nConstraints:\n\t1 <= points.length <= 10^5\n\tpoints[i].length == 2\n\t-2^31 <= xstart < xend <= 2^31 - 1",
        "topics": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/",
        "givenPythonCode": "/**\n * @param {number[][]} points\n * @return {number}\n */\nvar findMinArrowShots = function(points) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findMinArrowShots(int[][] points) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A car travels from a starting position to a destination which is target miles east of the starting position.\nThere are gas stations along the way. The gas stations are represented as an array stations where stations[i] = [positioni, fueli] indicates that the i^th gas station is positioni miles east of the starting position and has fueli liters of gas.\nThe car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\nReturn the minimum number of refueling stops the car must make in order to reach its destination. If it cannot reach the destination, return -1.\nNote that if the car reaches a gas station with 0 fuel left, the car can still refuel there. If the car reaches the destination with 0 fuel left, it is still considered to have arrived.\nExample 1:\nInput: target = 1, startFuel = 1, stations = []\nOutput: 0\nExplanation: We can reach the target without refueling.\nExample 2:\nInput: target = 100, startFuel = 1, stations = [[10,100]]\nOutput: -1\nExplanation: We can not reach the target (or even the first gas station).\nExample 3:\nInput: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]\nOutput: 2\nExplanation: We start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2.\nConstraints:\n\t1 <= target, startFuel <= 10^9\n\t0 <= stations.length <= 500\n\t1 <= positioni < positioni+1 < target\n\t1 <= fueli < 10^9",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Greedy",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/minimum-number-of-refueling-stops/",
        "givenPythonCode": "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} target\n * @param {number} startFuel\n * @param {number[][]} stations\n * @return {number}\n */\nvar minRefuelStops = function(target, startFuel, stations) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\nExample 1:\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\nExample 2:\nInput: target = 4, nums = [1,4,4]\nOutput: 1\nExample 3:\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\nConstraints:\n\t1 <= target <= 10^9\n\t1 <= nums.length <= 10^5\n\t1 <= nums[i] <= 10^4\nFollow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).",
        "topics": [
            "Array",
            "Binary Search",
            "Sliding Window",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/minimum-size-subarray-sum/",
        "givenPythonCode": "/**\n * @param {number} target\n * @param {number[]} nums\n * @return {number}\n */\nvar minSubArrayLen = function(target, nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference between any two time-points in the list.\nExample 1:\nInput: timePoints = [\"23:59\",\"00:00\"]\nOutput: 1\nExample 2:\nInput: timePoints = [\"00:00\",\"23:59\",\"00:00\"]\nOutput: 0\nConstraints:\n\t2 <= timePoints.length <= 2 * 10^4\n\ttimePoints[i] is in the format \"HH:MM\".",
        "topics": [
            "Array",
            "Math",
            "String",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/minimum-time-difference/",
        "givenPythonCode": "/**\n * @param {string[]} timePoints\n * @return {number}\n */\nvar findMinDifference = function(timePoints) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findMinDifference(self, timePoints: List[str]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findMinDifference(List<String> timePoints) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\nThe testcases will be generated such that the answer is unique.\nExample 1:\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\nExample 2:\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\nExample 3:\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\nConstraints:\n\tm == s.length\n\tn == t.length\n\t1 <= m, n <= 10^5\n\ts and t consist of uppercase and lowercase English letters.\nFollow up: Could you find an algorithm that runs in O(m + n) time?",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/minimum-window-substring/",
        "givenPythonCode": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        ",
        "givenJsCode": "class Solution {\n    public String minWindow(String s, String t) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\nExample 1:\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\nExample 2:\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\nExample 3:\nInput: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8\nExplanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\nConstraints:\n\tn == nums.length\n\t1 <= n <= 10^4\n\t0 <= nums[i] <= n\n\tAll the numbers of nums are unique.\nFollow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?",
        "topics": [
            "Array",
            "Hash Table",
            "Math",
            "Binary Search",
            "Bit Manipulation",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/missing-number/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar missingNumber = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int missingNumber(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\nExample 1:\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\nExample 2:\nInput: nums = [0]\nOutput: [0]\nConstraints:\n\t1 <= nums.length <= 10^4\n\t-2^31 <= nums[i] <= 2^31 - 1\nFollow up: Could you minimize the total number of operations done?",
        "topics": [
            "Array",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/move-zeroes/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "givenJavaCode": "class Solution {\n    public void moveZeroes(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\nExample 1:\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\nExample 2:\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\nConstraints:\n\t1 <= num1.length, num2.length <= 200\n\tnum1 and num2 consist of digits only.\n\tBoth num1 and num2 do not contain any leading zero, except the number 0 itself.",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/multiply-strings/",
        "givenPythonCode": "/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar multiply = function(num1, num2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String multiply(String num1, String num2) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a positive integer n, find the smallest integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive integer exists, return -1.\nNote that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return -1.\nExample 1:\nInput: n = 12\nOutput: 21\nExample 2:\nInput: n = 21\nOutput: -1\nConstraints:\n\t1 <= n <= 2^31 - 1",
        "topics": [
            "Math",
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/next-greater-element-iii/",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar nextGreaterElement = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int nextGreaterElement(int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\tFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\tFor example, the next permutation of arr = [1,2,3] is [1,3,2].\n\tSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\n\tWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.\nExample 1:\nInput: nums = [1,2,3]\nOutput: [1,3,2]\nExample 2:\nInput: nums = [3,2,1]\nOutput: [1,2,3]\nExample 3:\nInput: nums = [1,1,5]\nOutput: [1,5,1]\nConstraints:\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 100",
        "topics": [
            "Array",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/next-permutation/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar nextPermutation = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "givenJavaCode": "class Solution {\n    public void nextPermutation(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.\nExample 1:\nInput: nums = [4,6,7,7]\nOutput: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\nExample 2:\nInput: nums = [4,4,3,2,1]\nOutput: [[4,4]]\nConstraints:\n\t1 <= nums.length <= 15\n\t-100 <= nums[i] <= 100",
        "topics": [
            "Array",
            "Hash Table",
            "Backtracking",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/non-decreasing-subsequences/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar findSubsequences = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a positive integer n, return the number of the integers in the range [0, n] whose binary representations do not contain consecutive ones.\nExample 1:\nInput: n = 5\nOutput: 5\nExplanation:\nHere are the non-negative integers <= 5 with their corresponding binary representations:\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \nExample 2:\nInput: n = 1\nOutput: 2\nExample 3:\nInput: n = 2\nOutput: 3\nConstraints:\n\t1 <= n <= 10^9",
        "topics": [
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/",
        "givenPythonCode": "class Solution:\n    def findIntegers(self, n: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int findIntegers(int n) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar findIntegers = function(n) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "A positive integer is magical if it is divisible by either a or b.\nGiven the three integers n, a, and b, return the n^th magical number. Since the answer may be very large, return it modulo 10^9 + 7.\nExample 1:\nInput: n = 1, a = 2, b = 3\nOutput: 2\nExample 2:\nInput: n = 4, a = 2, b = 3\nOutput: 6\nConstraints:\n\t1 <= n <= 10^9\n\t2 <= a, b <= 4 * 10^4",
        "topics": [
            "Math",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/nth-magical-number/",
        "givenPythonCode": "class Solution:\n    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int nthMagicalNumber(int n, int a, int b) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} n\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nvar nthMagicalNumber = function(n, a, b) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\tFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\nGiven an integer num, return its complement.\nExample 1:\nInput: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\nExample 2:\nInput: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\nConstraints:\n\t1 <= num < 2^31\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "topics": [
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/number-complement/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} num\n * @return {number}\n */\nvar findComplement = function(num) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findComplement(self, num: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findComplement(int num) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string formula representing a chemical formula, return the count of each atom.\nThe atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\nOne or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.\n\tFor example, \"H2O\" and \"H2O2\" are possible, but \"H1O2\" is impossible.\nTwo formulas are concatenated together to produce another formula.\n\tFor example, \"H2O2He3Mg4\" is also a formula.\nA formula placed in parentheses, and a count (optionally added) is also a formula.\n\tFor example, \"(H2O2)\" and \"(H2O2)3\" are formulas.\nReturn the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\nThe test cases are generated so that all the values in the output fit in a 32-bit integer.\nExample 1:\nInput: formula = \"H2O\"\nOutput: \"H2O\"\nExplanation: The count of elements are {'H': 2, 'O': 1}.\nExample 2:\nInput: formula = \"Mg(OH)2\"\nOutput: \"H2MgO2\"\nExplanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\nExample 3:\nInput: formula = \"K4(ON(SO3)2)2\"\nOutput: \"K4N2O14S4\"\nExplanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.\nConstraints:\n\t1 <= formula.length <= 1000\n\tformula consists of English letters, digits, '(', and ')'.\n\tformula is always valid.",
        "topics": [
            "Hash Table",
            "String",
            "Stack",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/number-of-atoms/",
        "givenPythonCode": "class Solution:\n    def countOfAtoms(self, formula: str) -> str:\n        ",
        "givenJsCode": "/**\n * @param {string} formula\n * @return {string}\n */\nvar countOfAtoms = function(formula) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public String countOfAtoms(String formula) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a string s, return the number of segments in the string.\nA segment is defined to be a contiguous sequence of non-space characters.\nExample 1:\nInput: s = \"Hello, my name is John\"\nOutput: 5\nExplanation: The five segments are [\"Hello,\", \"my\", \"name\", \"is\", \"John\"]\nExample 2:\nInput: s = \"Hello\"\nOutput: 1\nConstraints:\n\t0 <= s.length <= 300\n\ts consists of lowercase and uppercase English letters, digits, or one of the following characters \"!@#$%^&*()_+-=',.:\".\n\tThe only space character in s is ' '.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/number-of-segments-in-a-string/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar countSegments = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def countSegments(self, s: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int countSegments(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "You are given an array of binary strings strs and two integers m and n.\nReturn the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.\nA set x is a subset of a set y if all elements of x are also elements of y.\nExample 1:\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\nOutput: 4\nExplanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\nOther valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}.\n{\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\nExample 2:\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\nOutput: 2\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\nConstraints:\n\t1 <= strs.length <= 600\n\t1 <= strs[i].length <= 100\n\tstrs[i] consists only of digits '0' and '1'.\n\t1 <= m, n <= 100",
        "topics": [
            "Array",
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/ones-and-zeroes/",
        "givenPythonCode": "/**\n * @param {string[]} strs\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar findMaxForm = function(strs, m, n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an integer x, return true if x is a palindrome, and false otherwise.\nExample 1:\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\nExample 2:\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\nExample 3:\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\nConstraints:\n\t-2^31 <= x <= 2^31 - 1\nFollow up: Could you solve it without converting the integer to a string?",
        "topics": [
            "Math"
        ],
        "url": "https://leetcode.com/problems/palindrome-number/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function(x) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isPalindrome(int x) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string s, partition s such that every substring of the partition is a palindrome.\nReturn the minimum cuts needed for a palindrome partitioning of s.\nExample 1:\nInput: s = \"aab\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\nExample 2:\nInput: s = \"a\"\nOutput: 0\nExample 3:\nInput: s = \"ab\"\nOutput: 1\nConstraints:\n\t1 <= s.length <= 2000\n\ts consists of lowercase English letters only.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/palindrome-partitioning-ii/",
        "givenPythonCode": "class Solution:\n    def minCut(self, s: str) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int minCut(String s) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar minCut = function(s) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.\nExample 1:\nInput: nums = [1,5,11,5]\nOutput: true\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\nExample 2:\nInput: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot be partitioned into equal sum subsets.\nConstraints:\n\t1 <= nums.length <= 200\n\t1 <= nums[i] <= 100",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/partition-equal-subset-sum/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canPartition = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean canPartition(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.\nReturn the minimum number of patches required.\nExample 1:\nInput: nums = [1,3], n = 6\nOutput: 1\nExplanation:\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\nSo we only need 1 patch.\nExample 2:\nInput: nums = [1,5,10], n = 20\nOutput: 2\nExplanation: The two patches can be [2, 4].\nExample 3:\nInput: nums = [1,2,2], n = 5\nOutput: 0\nConstraints:\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 10^4\n\tnums is sorted in ascending order.\n\t1 <= n <= 2^31 - 1",
        "topics": [
            "Array",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/patching-array/",
        "givenPythonCode": "class Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int minPatches(int[] nums, int n) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @param {number} n\n * @return {number}\n */\nvar minPatches = function(nums, n) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly.\nGiven an integer n, return true if n is a perfect number, otherwise return false.\nExample 1:\nInput: num = 28\nOutput: true\nExplanation: 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28.\nExample 2:\nInput: num = 7\nOutput: false\nConstraints:\n\t1 <= num <= 10^8",
        "topics": [
            "Math"
        ],
        "url": "https://leetcode.com/problems/perfect-number/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} num\n * @return {boolean}\n */\nvar checkPerfectNumber = function(num) {\n    \n};",
        "givenJsCode": "class Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean checkPerfectNumber(int num) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\nExample 1:\nInput: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.\nExample 2:\nInput: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.\nConstraints:\n\t1 <= n <= 10^4",
        "topics": [
            "Math",
            "Dynamic Programming",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/perfect-squares/",
        "givenPythonCode": "class Solution:\n    def numSquares(self, n: int) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar numSquares = function(n) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int numSquares(int n) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\nIn other words, return true if one of s1's permutations is the substring of s2.\nExample 1:\nInput: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: true\nExplanation: s2 contains one permutation of s1 (\"ba\").\nExample 2:\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: false\nConstraints:\n\t1 <= s1.length, s2.length <= 10^4\n\ts1 and s2 consist of lowercase English letters.",
        "topics": [
            "Hash Table",
            "Two Pointers",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/permutation-in-string/",
        "givenPythonCode": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar checkInclusion = function(s1, s2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\nExample 1:\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\nExample 2:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nConstraints:\n\t1 <= nums.length <= 8\n\t-10 <= nums[i] <= 10",
        "topics": [
            "Array",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/permutations-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permuteUnique = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nExample 2:\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\nExample 3:\nInput: nums = [1]\nOutput: [[1]]\nConstraints:\n\t1 <= nums.length <= 6\n\t-10 <= nums[i] <= 10\n\tAll the integers of nums are unique.",
        "topics": [
            "Array",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/permutations/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given a large integer represented as an integer array digits, where each digits[i] is the i^th digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\nExample 1:\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\nExample 2:\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\nExample 3:\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\nConstraints:\n\t1 <= digits.length <= 100\n\t0 <= digits[i] <= 9\n\tdigits does not contain any leading 0's.",
        "topics": [
            "Array",
            "Math"
        ],
        "url": "https://leetcode.com/problems/plus-one/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} digits\n * @return {number[]}\n */\nvar plusOne = function(digits) {\n    \n};",
        "givenJsCode": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] plusOne(int[] digits) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\nExample 2:\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\nConstraints:\n\t2 <= nums.length <= 10^5\n\t-30 <= nums[i] <= 30\n\tThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nFollow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)",
        "topics": [
            "Array",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/product-of-array-except-self/",
        "givenPythonCode": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\nEach letter in magazine can only be used once in ransomNote.\nExample 1:\nInput: ransomNote = \"a\", magazine = \"b\"\nOutput: false\nExample 2:\nInput: ransomNote = \"aa\", magazine = \"ab\"\nOutput: false\nExample 3:\nInput: ransomNote = \"aa\", magazine = \"aab\"\nOutput: true\nConstraints:\n\t1 <= ransomNote.length, magazine.length <= 10^5\n\transomNote and magazine consist of lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/ransom-note/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} ransomNote\n * @param {string} magazine\n * @return {boolean}\n */\nvar canConstruct = function(ransomNote, magazine) {\n    \n};",
        "givenJsCode": "class Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        \n    }\n}"
    },
    {
        "excercise": "Given four integers sx, sy, tx, and ty, return true if it is possible to convert the point (sx, sy) to the point (tx, ty) through some operations, or false otherwise.\nThe allowed operation on some point (x, y) is to convert it to either (x, x + y) or (x + y, y).\nExample 1:\nInput: sx = 1, sy = 1, tx = 3, ty = 5\nOutput: true\nExplanation:\nOne series of moves that transforms the starting point to the target is:\n(1, 1) -> (1, 2)\n(1, 2) -> (3, 2)\n(3, 2) -> (3, 5)\nExample 2:\nInput: sx = 1, sy = 1, tx = 2, ty = 2\nOutput: false\nExample 3:\nInput: sx = 1, sy = 1, tx = 1, ty = 1\nOutput: true\nConstraints:\n\t1 <= sx, sy, tx, ty <= 10^9",
        "topics": [
            "Math"
        ],
        "url": "https://leetcode.com/problems/reaching-points/",
        "givenPythonCode": "class Solution:\n    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:\n        ",
        "givenJsCode": "class Solution {\n    public boolean reachingPoints(int sx, int sy, int tx, int ty) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} sx\n * @param {number} sy\n * @param {number} tx\n * @param {number} ty\n * @return {boolean}\n */\nvar reachingPoints = function(sx, sy, tx, ty) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an integer array score of size n, where score[i] is the score of the i^th athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1^st place athlete has the highest score, the 2^nd place athlete has the 2^nd highest score, and so on. The placement of each athlete determines their rank:\n\tThe 1^st place athlete's rank is \"Gold Medal\".\n\tThe 2^nd place athlete's rank is \"Silver Medal\".\n\tThe 3^rd place athlete's rank is \"Bronze Medal\".\n\tFor the 4^th place to the n^th place athlete, their rank is their placement number (i.e., the x^th place athlete's rank is \"x\").\nReturn an array answer of size n where answer[i] is the rank of the i^th athlete.\nExample 1:\nInput: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1^st, 2^nd, 3^rd, 4^th, 5^th].\nExample 2:\nInput: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1^st, 5^th, 3^rd, 2^nd, 4^th].\nConstraints:\n\tn == score.length\n\t1 <= n <= 10^4\n\t0 <= score[i] <= 10^6\n\tAll the values in score are unique.",
        "topics": [
            "Array",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/relative-ranks/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def findRelativeRanks(self, score: List[int]) -> List[str]:\n        ",
        "givenJsCode": "/**\n * @param {number[]} score\n * @return {string[]}\n */\nvar findRelativeRanks = function(score) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nConstraints:\n\t1 <= nums.length <= 3 * 10^4\n\t-10^4 <= nums[i] <= 10^4\n\tnums is sorted in non-decreasing order.",
        "topics": [
            "Array",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\tChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\n\tReturn k.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nConstraints:\n\t1 <= nums.length <= 3 * 10^4\n\t-100 <= nums[i] <= 100\n\tnums is sorted in non-decreasing order.",
        "topics": [
            "Array",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\n\tChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\n\tReturn k.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\nint k = removeElement(nums, val); // Calls your implementation\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nConstraints:\n\t0 <= nums.length <= 100\n\t0 <= nums[i] <= 50\n\t0 <= val <= 100",
        "topics": [
            "Array",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/remove-element/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function(nums, val) {\n    \n};",
        "givenJsCode": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\nReturn a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.\nExample 1:\nInput: s = \"()())()\"\nOutput: [\"(())()\",\"()()()\"]\nExample 2:\nInput: s = \"(a)())()\"\nOutput: [\"(a())()\",\"(a)()()\"]\nExample 3:\nInput: s = \")(\"\nOutput: [\"\"]\nConstraints:\n\t1 <= s.length <= 25\n\ts consists of lowercase English letters and parentheses '(' and ')'.\n\tThere will be at most 20 parentheses in s.",
        "topics": [
            "String",
            "Backtracking",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/remove-invalid-parentheses/",
        "givenPythonCode": "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        ",
        "givenJsCode": "class Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar removeInvalidParentheses = function(s) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\tFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\nExample 1:\nInput: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]\nExample 2:\nInput: s = \"0000\"\nOutput: [\"0.0.0.0\"]\nExample 3:\nInput: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\nConstraints:\n\t1 <= s.length <= 20\n\ts consists of digits only.",
        "topics": [
            "String",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/restore-ip-addresses/",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<String> restoreIpAddresses(String s) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\nExample 1:\nInput: x = 123\nOutput: 321\nExample 2:\nInput: x = -123\nOutput: -321\nExample 3:\nInput: x = 120\nOutput: 21\nConstraints:\n\t-2^31 <= x <= 2^31 - 1",
        "topics": [
            "Math"
        ],
        "url": "https://leetcode.com/problems/reverse-integer/",
        "givenPythonCode": "/**\n * @param {number} x\n * @return {number}\n */\nvar reverse = function(x) {\n    \n};",
        "givenJsCode": "class Solution:\n    def reverse(self, x: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int reverse(int x) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.\nIf there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.\nExample 1:\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\nExample 2:\nInput: s = \"abcd\", k = 2\nOutput: \"bacd\"\nConstraints:\n\t1 <= s.length <= 10^4\n\ts consists of only lowercase English letters.\n\t1 <= k <= 10^4",
        "topics": [
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/reverse-string-ii/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar reverseStr = function(s, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def reverseStr(self, s: str, k: int) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String reverseStr(String s, int k) {\n        \n    }\n}"
    },
    {
        "excercise": "Write a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\nExample 2:\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\nConstraints:\n\t1 <= s.length <= 10^5\n\ts[i] is a printable ascii character.",
        "topics": [
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/reverse-string/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n */\nvar reverseString = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        ",
        "givenJavaCode": "class Solution {\n    public void reverseString(char[] s) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\nExample 1:\nInput: s = \"hello\"\nOutput: \"holle\"\nExample 2:\nInput: s = \"leetcode\"\nOutput: \"leotcede\"\nConstraints:\n\t1 <= s.length <= 3 * 10^5\n\ts consist of printable ASCII characters.",
        "topics": [
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/reverse-vowels-of-a-string/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {string}\n */\nvar reverseVowels = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def reverseVowels(self, s: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String reverseVowels(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\nExample 1:\nInput: s = \"the sky is blue\"\nOutput: \"blue is sky the\"\nExample 2:\nInput: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\nExample 3:\nInput: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\nConstraints:\n\t1 <= s.length <= 10^4\n\ts contains English letters (upper-case and lower-case), digits, and spaces ' '.\n\tThere is at least one word in s.\nFollow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?",
        "topics": [
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/reverse-words-in-a-string/",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String reverseWords(String s) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\tI can be placed before V (5) and X (10) to make 4 and 9. \n\tX can be placed before L (50) and C (100) to make 40 and 90. \n\tC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\nExample 1:\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\nExample 2:\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 3:\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\nConstraints:\n\t1 <= s.length <= 15\n\ts contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\n\tIt is guaranteed that s is a valid roman numeral in the range [1, 3999].",
        "topics": [
            "Hash Table",
            "Math",
            "String"
        ],
        "url": "https://leetcode.com/problems/roman-to-integer/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int romanToInt(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\nExample 1:\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\nExample 2:\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\nConstraints:\n\t1 <= nums.length <= 10^5\n\t-2^31 <= nums[i] <= 2^31 - 1\n\t0 <= k <= 10^5\nFollow up:\n\tTry to come up with as many solutions as you can. There are at least three different ways to solve this problem.\n\tCould you do it in-place with O(1) extra space?",
        "topics": [
            "Array",
            "Math",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/rotate-array/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar rotate = function(nums, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "givenJavaCode": "class Solution {\n    public void rotate(int[] nums, int k) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\nReturn the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\nNote: You cannot rotate an envelope.\nExample 1:\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\nExample 2:\nInput: envelopes = [[1,1],[1,1],[1,1]]\nOutput: 1\nConstraints:\n\t1 <= envelopes.length <= 10^5\n\tenvelopes[i].length == 2\n\t1 <= wi, hi <= 10^5",
        "topics": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/russian-doll-envelopes/",
        "givenPythonCode": "class Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int maxEnvelopes(int[][] envelopes) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[][]} envelopes\n * @return {number}\n */\nvar maxEnvelopes = function(envelopes) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "We can scramble a string s to get a string t using the following algorithm:\n\tIf the length of the string is 1, stop.\n\tIf the length of the string is > 1, do the following:\n\t\tSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\n\t\tRandomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\n\t\tApply step 1 recursively on each of the two substrings x and y.\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\nExample 1:\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\nExample 2:\nInput: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false\nExample 3:\nInput: s1 = \"a\", s2 = \"a\"\nOutput: true\nConstraints:\n\ts1.length == s2.length\n\t1 <= s1.length <= 30\n\ts1 and s2 consist of lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/scramble-string/",
        "givenPythonCode": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        ",
        "givenJsCode": "class Solution {\n    public boolean isScramble(String s1, String s2) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar isScramble = function(s1, s2) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\nYou must decrease the overall operation steps as much as possible.\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\nExample 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\nConstraints:\n\t1 <= nums.length <= 5000\n\t-10^4 <= nums[i] <= 10^4\n\tnums is guaranteed to be rotated at some pivot.\n\t-10^4 <= target <= 10^4\nFollow up: This problem is similar to Search in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {boolean}\n */\nvar search = function(nums, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean search(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\nInput: nums = [1], target = 0\nOutput: -1\nConstraints:\n\t1 <= nums.length <= 5000\n\t-10^4 <= nums[i] <= 10^4\n\tAll values of nums are unique.\n\tnums is an ascending array that is possibly rotated.\n\t-10^4 <= target <= 10^4",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
        "givenPythonCode": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\nExample 2:\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\nExample 3:\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\nConstraints:\n\t1 <= nums.length <= 10^4\n\t-10^4 <= nums[i] <= 10^4\n\tnums contains distinct values sorted in ascending order.\n\t-10^4 <= target <= 10^4",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/search-insert-position/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an absolute path for a Unix-style file system, which begins with a slash '/', transform this path into its simplified canonical path.\nIn Unix-style file system context, a single period '.' signifies the current directory, a double period \"..\" denotes moving up one directory level, and multiple slashes such as \"//\" are interpreted as a single slash. In this problem, treat sequences of periods not covered by the previous rules (like \"...\") as valid names for files or directories.\nThe simplified canonical path should adhere to the following rules:\n\tIt must start with a single slash '/'.\n\tDirectories within the path should be separated by only one slash '/'.\n\tIt should not end with a slash '/', unless it's the root directory.\n\tIt should exclude any single or double periods used to denote current or parent directories.\nReturn the new path.\nExample 1:\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation:\nThe trailing slash should be removed.\nExample 2:\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation:\nMultiple consecutive slashes are replaced by a single one.\nExample 3:\nInput: path = \"/home/user/Documents/../Pictures\"\nOutput: \"/home/user/Pictures\"\nExplanation:\nA double period \"..\" refers to the directory up a level.\nExample 4:\nInput: path = \"/../\"\nOutput: \"/\"\nExplanation:\nGoing one level up from the root directory is not possible.\nExample 5:\nInput: path = \"/.../a/../b/c/../d/./\"\nOutput: \"/.../b/d\"\nExplanation:\n\"...\" is a valid name for a directory in this problem.\nConstraints:\n\t1 <= path.length <= 3000\n\tpath consists of English letters, digits, period '.', slash '/' or '_'.\n\tpath is a valid absolute Unix path.",
        "topics": [
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/simplify-path/",
        "givenPythonCode": "/**\n * @param {string} path\n * @return {string}\n */\nvar simplifyPath = function(path) {\n    \n};",
        "givenJsCode": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String simplifyPath(String path) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\nReturn the single element that appears only once.\nYour solution must run in O(log n) time and O(1) space.\nExample 1:\nInput: nums = [1,1,2,3,3,4,4,8,8]\nOutput: 2\nExample 2:\nInput: nums = [3,3,7,7,10,11,11]\nOutput: 10\nConstraints:\n\t1 <= nums.length <= 10^5\n\t0 <= nums[i] <= 10^5",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/single-element-in-a-sorted-array/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNonDuplicate = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nExample 1:\nInput: nums = [2,2,3,2]\nOutput: 3\nExample 2:\nInput: nums = [0,1,0,1,0,1,99]\nOutput: 99\nConstraints:\n\t1 <= nums.length <= 3 * 10^4\n\t-2^31 <= nums[i] <= 2^31 - 1\n\tEach element in nums appears exactly three times except for one element which appears once.",
        "topics": [
            "Array",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/single-number-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int singleNumber(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.\nYou must write an algorithm that runs in linear runtime complexity and uses only constant extra space.\nExample 1:\nInput: nums = [1,2,1,3,2,5]\nOutput: [3,5]\nExplanation:  [5, 3] is also a valid answer.\nExample 2:\nInput: nums = [-1,0]\nOutput: [-1,0]\nExample 3:\nInput: nums = [0,1]\nOutput: [1,0]\nConstraints:\n\t2 <= nums.length <= 3 * 10^4\n\t-2^31 <= nums[i] <= 2^31 - 1\n\tEach integer in nums will appear twice, only two integers will appear once.",
        "topics": [
            "Array",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/single-number-iii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar singleNumber = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] singleNumber(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\tFor examples, if arr = [2,3,4], the median is 3.\n\tFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10^-5 of the actual value will be accepted.\nExample 1:\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6\nExample 2:\nInput: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]\nConstraints:\n\t1 <= k <= nums.length <= 10^5\n\t-2^31 <= nums[i] <= 2^31 - 1",
        "topics": [
            "Array",
            "Hash Table",
            "Sliding Window",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/sliding-window-median/",
        "givenPythonCode": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        ",
        "givenJsCode": "class Solution {\n    public double[] medianSlidingWindow(int[] nums, int k) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar medianSlidingWindow = function(nums, k) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n represented as a string, return the smallest good base of n.\nWe call k >= 2 a good base of n, if all digits of n base k are 1's.\nExample 1:\nInput: n = \"13\"\nOutput: \"3\"\nExplanation: 13 base 3 is 111.\nExample 2:\nInput: n = \"4681\"\nOutput: \"8\"\nExplanation: 4681 base 8 is 11111.\nExample 3:\nInput: n = \"1000000000000000000\"\nOutput: \"999999999999999999\"\nExplanation: 1000000000000000000 base 999999999999999999 is 11.\nConstraints:\n\tn is an integer in the range [3, 10^18].\n\tn does not contain any leading zeros.",
        "topics": [
            "Math",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/smallest-good-base/",
        "givenPythonCode": "class Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        ",
        "givenJsCode": "class Solution {\n    public String smallestGoodBase(String n) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} n\n * @return {string}\n */\nvar smallestGoodBase = function(n) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.\nWe define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.\nExample 1:\nInput: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\nOutput: [20,24]\nExplanation: \nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\nList 3: [5, 18, 22, 30], 22 is in range [20,24].\nExample 2:\nInput: nums = [[1,2,3],[1,2,3],[1,2,3]]\nOutput: [1,1]\nConstraints:\n\tnums.length == k\n\t1 <= k <= 3500\n\t1 <= nums[i].length <= 50\n\t-10^5 <= nums[i][j] <= 10^5\n\tnums[i] is sorted in non-decreasing order.",
        "topics": [
            "Array",
            "Hash Table",
            "Greedy",
            "Sliding Window",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/",
        "givenPythonCode": "class Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        ",
        "givenJsCode": "class Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[][]} nums\n * @return {number[]}\n */\nvar smallestRange = function(nums) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.\nExample 1:\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\nExample 2:\nInput: nums = [2,0,1]\nOutput: [0,1,2]\nConstraints:\n\tn == nums.length\n\t1 <= n <= 300\n\tnums[i] is either 0, 1, or 2.\nFollow up: Could you come up with a one-pass algorithm using only constant extra space?",
        "topics": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/sort-colors/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar sortColors = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "givenJavaCode": "class Solution {\n    public void sortColors(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.\nReturn the minimized largest sum of the split.\nA subarray is a contiguous part of the array.\nExample 1:\nInput: nums = [7,2,5,10,8], k = 2\nOutput: 18\nExplanation: There are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\nExample 2:\nInput: nums = [1,2,3,4,5], k = 2\nOutput: 9\nExplanation: There are four ways to split nums into two subarrays.\nThe best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\nConstraints:\n\t1 <= nums.length <= 1000\n\t0 <= nums[i] <= 10^6\n\t1 <= k <= min(50, nums.length)",
        "topics": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Greedy",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/split-array-largest-sum/",
        "givenPythonCode": "class Solution:\n    def splitArray(self, nums: List[int], k: int) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar splitArray = function(nums, k) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int splitArray(int[] nums, int k) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou must not use any built-in exponent function or operator.\n\tFor example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\nExample 1:\nInput: x = 4\nOutput: 2\nExplanation: The square root of 4 is 2, so we return 2.\nExample 2:\nInput: x = 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\nConstraints:\n\t0 <= x <= 2^31 - 1",
        "topics": [
            "Math",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/sqrtx/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) {\n    \n};",
        "givenJsCode": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int mySqrt(int x) {\n        \n    }\n}"
    },
    {
        "excercise": "There is a strange printer with the following two special properties:\n\tThe printer can only print a sequence of the same character each time.\n\tAt each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\nGiven a string s, return the minimum number of turns the printer needed to print it.\nExample 1:\nInput: s = \"aaabbb\"\nOutput: 2\nExplanation: Print \"aaa\" first and then print \"bbb\".\nExample 2:\nInput: s = \"aba\"\nOutput: 2\nExplanation: Print \"aaa\" first and then print \"b\" from the second place of the string, which will cover the existing character 'a'.\nConstraints:\n\t1 <= s.length <= 100\n\ts consists of lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/strange-printer/",
        "givenPythonCode": "class Solution:\n    def strangePrinter(self, s: str) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int strangePrinter(String s) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar strangePrinter = function(s) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an array of characters chars, compress it using the following algorithm:\nBegin with an empty string s. For each group of consecutive repeating characters in chars:\n\tIf the group's length is 1, append the character to s.\n\tOtherwise, append the character followed by the group's length.\nThe compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.\nAfter you are done modifying the input array, return the new length of the array.\nYou must write an algorithm that uses only constant extra space.\nExample 1:\nInput: chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\nOutput: Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\nExplanation: The groups are \"aa\", \"bb\", and \"ccc\". This compresses to \"a2b2c3\".\nExample 2:\nInput: chars = [\"a\"]\nOutput: Return 1, and the first character of the input array should be: [\"a\"]\nExplanation: The only group is \"a\", which remains uncompressed since it's a single character.\nExample 3:\nInput: chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\nOutput: Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\nExplanation: The groups are \"a\" and \"bbbbbbbbbbbb\". This compresses to \"ab12\".\nConstraints:\n\t1 <= chars.length <= 2000\n\tchars[i] is a lowercase English letter, uppercase English letter, digit, or symbol.",
        "topics": [
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/string-compression/",
        "givenPythonCode": "/**\n * @param {character[]} chars\n * @return {number}\n */\nvar compress = function(chars) {\n    \n};",
        "givenJsCode": "class Solution:\n    def compress(self, chars: List[str]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int compress(char[] chars) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\t'A': Absent.\n\t'L': Late.\n\t'P': Present.\nThe student is eligible for an attendance award if they meet both of the following criteria:\n\tThe student was absent ('A') for strictly fewer than 2 days total.\n\tThe student was never late ('L') for 3 or more consecutive days.\nReturn true if the student is eligible for an attendance award, or false otherwise.\nExample 1:\nInput: s = \"PPALLP\"\nOutput: true\nExplanation: The student has fewer than 2 absences and was never late 3 or more consecutive days.\nExample 2:\nInput: s = \"PPALLL\"\nOutput: false\nExplanation: The student was late 3 consecutive days in the last 3 days, so is not eligible for the award.\nConstraints:\n\t1 <= s.length <= 1000\n\ts[i] is either 'A', 'L', or 'P'.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/student-attendance-record-i/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar checkRecord = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def checkRecord(self, s: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean checkRecord(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\t'A': Absent.\n\t'L': Late.\n\t'P': Present.\nAny student is eligible for an attendance award if they meet both of the following criteria:\n\tThe student was absent ('A') for strictly fewer than 2 days total.\n\tThe student was never late ('L') for 3 or more consecutive days.\nGiven an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 10^9 + 7.\nExample 1:\nInput: n = 2\nOutput: 8\nExplanation: There are 8 records with length 2 that are eligible for an award:\n\"PP\", \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\"\nOnly \"AA\" is not eligible because there are 2 absences (there need to be fewer than 2).\nExample 2:\nInput: n = 1\nOutput: 3\nExample 3:\nInput: n = 10101\nOutput: 183236316\nConstraints:\n\t1 <= n <= 10^5",
        "topics": [
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/student-attendance-record-ii/",
        "givenPythonCode": "class Solution:\n    def checkRecord(self, n: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int checkRecord(int n) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar checkRecord = function(n) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nInput: nums = [1,1,1], k = 2\nOutput: 2\nExample 2:\nInput: nums = [1,2,3], k = 3\nOutput: 2\nConstraints:\n\t1 <= nums.length <= 2 * 10^4\n\t-1000 <= nums[i] <= 1000\n\t-10^7 <= k <= 10^7",
        "topics": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/subarray-sum-equals-k/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar subarraySum = function(nums, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int subarraySum(int[] nums, int k) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nInput: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\nExample 2:\nInput: nums = [0]\nOutput: [[],[0]]\nConstraints:\n\t1 <= nums.length <= 10\n\t-10 <= nums[i] <= 10",
        "topics": [
            "Array",
            "Backtracking",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/subsets-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsetsWithDup = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\nExample 2:\nInput: nums = [0]\nOutput: [[],[0]]\nConstraints:\n\t1 <= nums.length <= 10\n\t-10 <= nums[i] <= 10\n\tAll the numbers of nums are unique.",
        "topics": [
            "Array",
            "Backtracking",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/subsets/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.\n\tFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated string because it is not the concatenation of any permutation of words.\nReturn an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.\nExample 1:\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation:\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nExample 2:\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation:\nThere is no concatenated substring.\nExample 3:\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation:\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"].\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"].\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"].\nConstraints:\n\t1 <= s.length <= 10^4\n\t1 <= words.length <= 5000\n\t1 <= words[i].length <= 30\n\ts and words[i] consist of lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/",
        "givenPythonCode": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two integers a and b, return the sum of the two integers without using the operators + and -.\nExample 1:\nInput: a = 1, b = 2\nOutput: 3\nExample 2:\nInput: a = 2, b = 3\nOutput: 5\nConstraints:\n\t-1000 <= a, b <= 1000",
        "topics": [
            "Math",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/sum-of-two-integers/",
        "givenPythonCode": "/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nvar getSum = function(a, b) {\n    \n};",
        "givenJsCode": "class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int getSum(int a, int b) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given a sorted unique integer array nums.\nA range [a,b] is the set of all integers from a to b (inclusive).\nReturn the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\nEach range [a,b] in the list should be output as:\n\t\"a->b\" if a != b\n\t\"a\" if a == b\nExample 1:\nInput: nums = [0,1,2,4,5,7]\nOutput: [\"0->2\",\"4->5\",\"7\"]\nExplanation: The ranges are:\n[0,2] --> \"0->2\"\n[4,5] --> \"4->5\"\n[7,7] --> \"7\"\nExample 2:\nInput: nums = [0,2,3,4,6,8,9]\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\nExplanation: The ranges are:\n[0,0] --> \"0\"\n[2,4] --> \"2->4\"\n[6,6] --> \"6\"\n[8,9] --> \"8->9\"\nConstraints:\n\t0 <= nums.length <= 20\n\t-2^31 <= nums[i] <= 2^31 - 1\n\tAll the values of nums are unique.\n\tnums is sorted in ascending order.",
        "topics": [
            "Array"
        ],
        "url": "https://leetcode.com/problems/summary-ranges/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {string[]}\n */\nvar summaryRanges = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "A super ugly number is a positive integer whose prime factors are in the array primes.\nGiven an integer n and an array of integers primes, return the n^th super ugly number.\nThe n^th super ugly number is guaranteed to fit in a 32-bit signed integer.\nExample 1:\nInput: n = 12, primes = [2,7,13,19]\nOutput: 32\nExplanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\nExample 2:\nInput: n = 1, primes = [2,3,5]\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\nConstraints:\n\t1 <= n <= 10^5\n\t1 <= primes.length <= 100\n\t2 <= primes[i] <= 1000\n\tprimes[i] is guaranteed to be a prime number.\n\tAll the values of primes are unique and sorted in ascending order.",
        "topics": [
            "Array",
            "Math",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/super-ugly-number/",
        "givenPythonCode": "/**\n * @param {number} n\n * @param {number[]} primes\n * @return {number}\n */\nvar nthSuperUglyNumber = function(n, primes) {\n    \n};",
        "givenJsCode": "class Solution:\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int nthSuperUglyNumber(int n, int[] primes) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.\nFor each move, you could choose any m (1 <= m <= n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\nGiven an integer array machines representing the number of dresses in each washing machine from left to right on the line, return the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\nExample 1:\nInput: machines = [1,0,5]\nOutput: 3\nExplanation:\n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n3rd move:    2     1 <-- 3    =>    2     2     2\nExample 2:\nInput: machines = [0,3,0]\nOutput: 2\nExplanation:\n1st move:    0 <-- 3     0    =>    1     2     0\n2nd move:    1     2 --> 0    =>    1     1     1\nExample 3:\nInput: machines = [0,2,0]\nOutput: -1\nExplanation:\nIt's impossible to make all three washing machines have the same number of dresses.\nConstraints:\n\tn == machines.length\n\t1 <= n <= 10^4\n\t0 <= machines[i] <= 10^5",
        "topics": [
            "Array",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/super-washing-machines/",
        "givenPythonCode": "class Solution:\n    def findMinMoves(self, machines: List[int]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int findMinMoves(int[] machines) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} machines\n * @return {number}\n */\nvar findMinMoves = function(machines) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid.\nA code snippet is valid if all the following rules hold:\n\tThe code must be wrapped in a valid closed tag. Otherwise, the code is invalid.\n\tA closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.\n\tA valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.\n\tA valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid.\n\tA start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\n\tA < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME (not necessarily valid).\n\tThe cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.\n\tCDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.\nExample 1:\nInput: code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\nOutput: true\nExplanation: \nThe code is wrapped in a closed tag : <DIV> and </DIV>. \nThe TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. \nAlthough CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag.\nSo TAG_CONTENT is valid, and then the code is valid. Thus return true.\nExample 2:\nInput: code = \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"\nOutput: true\nExplanation:\nWe first separate the code into : start_tag|tag_content|end_tag.\nstart_tag -> \"<DIV>\"\nend_tag -> \"</DIV>\"\ntag_content could also be separated into : text1|cdata|text2.\ntext1 -> \">>  ![cdata[]] \"\ncdata -> \"<![CDATA[<div>]>]]>\", where the CDATA_CONTENT is \"<div>]>\"\ntext2 -> \"]]>>]\"\nThe reason why start_tag is NOT \"<DIV>>>\" is because of the rule 6.\nThe reason why cdata is NOT \"<![CDATA[<div>]>]]>]]>\" is because of the rule 7.\nExample 3:\nInput: code = \"<A>  <B> </A>   </B>\"\nOutput: false\nExplanation: Unbalanced. If \"<A>\" is closed, then \"<B>\" must be unmatched, and vice versa.\nConstraints:\n\t1 <= code.length <= 500\n\tcode consists of English letters, digits, '<', '>', '/', '!', '[', ']', '.', and ' '.",
        "topics": [
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/tag-validator/",
        "givenPythonCode": "class Solution:\n    def isValid(self, code: str) -> bool:\n        ",
        "givenJsCode": "class Solution {\n    public boolean isValid(String code) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} code\n * @return {boolean}\n */\nvar isValid = function(code) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\n\tFor example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\".\nReturn the number of different expressions that you can build, which evaluates to target.\nExample 1:\nInput: nums = [1,1,1,1,1], target = 3\nOutput: 5\nExplanation: There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\nExample 2:\nInput: nums = [1], target = 1\nOutput: 1\nConstraints:\n\t1 <= nums.length <= 20\n\t0 <= nums[i] <= 1000\n\t0 <= sum(nums[i]) <= 1000\n\t-1000 <= target <= 1000",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/target-sum/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar findTargetSumWays = function(nums, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.\nYou are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.\nReturn the total number of seconds that Ashe is poisoned.\nExample 1:\nInput: timeSeries = [1,4], duration = 2\nOutput: 4\nExplanation: Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\nAshe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.\nExample 2:\nInput: timeSeries = [1,2], duration = 2\nOutput: 3\nExplanation: Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\nAshe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.\nConstraints:\n\t1 <= timeSeries.length <= 10^4\n\t0 <= timeSeries[i], duration <= 10^7\n\ttimeSeries is sorted in non-decreasing order.",
        "topics": [
            "Array",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/teemo-attacking/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} timeSeries\n * @param {number} duration\n * @return {number}\n */\nvar findPoisonedDuration = function(timeSeries, duration) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findPoisonedDuration(int[] timeSeries, int duration) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:\n\tA word is defined as a character sequence consisting of non-space characters only.\n\tEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n\tThe input array words contains at least one word.\nExample 1:\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\nExample 2:\nInput: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\nExample 3:\nInput: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\nConstraints:\n\t1 <= words.length <= 300\n\t1 <= words[i].length <= 20\n\twords[i] consists of only English letters and symbols.\n\t1 <= maxWidth <= 100\n\twords[i].length <= maxWidth",
        "topics": [
            "Array",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/text-justification/",
        "givenPythonCode": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        ",
        "givenJsCode": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string[]} words\n * @param {number} maxWidth\n * @return {string[]}\n */\nvar fullJustify = function(words, maxWidth) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.\nExample 1:\nInput: nums = [3,2,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.\nExample 2:\nInput: nums = [1,2]\nOutput: 2\nExplanation:\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.\nExample 3:\nInput: nums = [2,2,3,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1.\nConstraints:\n\t1 <= nums.length <= 10^4\n\t-2^31 <= nums[i] <= 2^31 - 1\nFollow up: Can you find an O(n) solution?",
        "topics": [
            "Array",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/third-maximum-number/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar thirdMax = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int thirdMax(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.\nExample 1:\nInput: nums = [4,14,2]\nOutput: 6\nExplanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\nshowing the four bits relevant in this case).\nThe answer will be:\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\nExample 2:\nInput: nums = [4,14,4]\nOutput: 4\nConstraints:\n\t1 <= nums.length <= 10^4\n\t0 <= nums[i] <= 10^9\n\tThe answer for the given input will fit in a 32-bit integer.",
        "topics": [
            "Array",
            "Math",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/total-hamming-distance/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar totalHammingDistance = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def totalHammingDistance(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int totalHammingDistance(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\nExample 1:\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\nExample 2:\nInput: triangle = [[-10]]\nOutput: -10\nConstraints:\n\t1 <= triangle.length <= 200\n\ttriangle[0].length == 1\n\ttriangle[i].length == triangle[i - 1].length + 1\n\t-10^4 <= triangle[i][j] <= 10^4\nFollow up: Could you do this using only O(n) extra space, where n is the total number of rows in the triangle?",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/triangle/",
        "givenPythonCode": "/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n    \n};",
        "givenJsCode": "class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\nYour solution must use only constant extra space.\nExample 1:\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\nExample 2:\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\nExample 3:\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].\nConstraints:\n\t2 <= numbers.length <= 3 * 10^4\n\t-1000 <= numbers[i] <= 1000\n\tnumbers is sorted in non-decreasing order.\n\t-1000 <= target <= 1000\n\tThe tests are generated such that there is exactly one solution.",
        "topics": [
            "Array",
            "Two Pointers",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/",
        "givenPythonCode": "/**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(numbers, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\nConstraints:\n\t2 <= nums.length <= 10^4\n\t-10^9 <= nums[i] <= 10^9\n\t-10^9 <= target <= 10^9\n\tOnly one valid answer exists.\nFollow-up: Can you come up with an algorithm that is less than O(n^2) time complexity?",
        "topics": [
            "Array",
            "Hash Table"
        ],
        "url": "https://leetcode.com/problems/two-sum/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        \n    }\n}"
    },
    {
        "excercise": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the n^th ugly number.\nExample 1:\nInput: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\nExample 2:\nInput: n = 1\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\nConstraints:\n\t1 <= n <= 1690",
        "topics": [
            "Hash Table",
            "Math",
            "Dynamic Programming",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/ugly-number-ii/",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int nthUglyNumber(int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return true if n is an ugly number.\nExample 1:\nInput: n = 6\nOutput: true\nExplanation: 6 = 2 \u00c3\u2014 3\nExample 2:\nInput: n = 1\nOutput: true\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\nExample 3:\nInput: n = 14\nOutput: false\nExplanation: 14 is not ugly since it includes the prime factor 7.\nConstraints:\n\t-2^31 <= n <= 2^31 - 1",
        "topics": [
            "Math"
        ],
        "url": "https://leetcode.com/problems/ugly-number/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def isUgly(self, n: int) -> bool:\n        ",
        "givenJsCode": "/**\n * @param {number} n\n * @return {boolean}\n */\nvar isUgly = function(n) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public boolean isUgly(int n) {\n        \n    }\n}"
    },
    {
        "excercise": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\nConstraints:\n\t1 <= s.length, t.length <= 5 * 10^4\n\ts and t consist of lowercase English letters.\nFollow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",
        "topics": [
            "Hash Table",
            "String",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/valid-anagram/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isAnagram = function(s, t) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string s, return whether s is a valid number.\nFor example, all the following are valid numbers: \"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\", while the following are not valid numbers: \"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\".\nFormally, a valid number is defined using one of the following definitions:\n\tAn integer number followed by an optional exponent.\n\tA decimal number followed by an optional exponent.\nAn integer number is defined with an optional sign '-' or '+' followed by digits.\nA decimal number is defined with an optional sign '-' or '+' followed by one of the following definitions:\n\tDigits followed by a dot '.'.\n\tDigits followed by a dot '.' followed by digits.\n\tA dot '.' followed by digits.\nAn exponent is defined with an exponent notation 'e' or 'E' followed by an integer number.\nThe digits are defined as one or more digits.\nExample 1:\nInput: s = \"0\"\nOutput: true\nExample 2:\nInput: s = \"e\"\nOutput: false\nExample 3:\nInput: s = \".\"\nOutput: false\nConstraints:\n\t1 <= s.length <= 20\n\ts consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/valid-number/",
        "givenPythonCode": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        ",
        "givenJsCode": "class Solution {\n    public boolean isNumber(String s) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isNumber = function(s) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\n\tOpen brackets must be closed by the same type of brackets.\n\tOpen brackets must be closed in the correct order.\n\tEvery close bracket has a corresponding open bracket of the same type.\nExample 1:\nInput: s = \"()\"\nOutput: true\nExample 2:\nInput: s = \"()[]{}\"\nOutput: true\nExample 3:\nInput: s = \"(]\"\nOutput: false\nConstraints:\n\t1 <= s.length <= 10^4\n\ts consists of parentheses only '()[]{}'.",
        "topics": [
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/valid-parentheses/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isValid(self, s: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isValid(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a positive integer num, return true if num is a perfect square or false otherwise.\nA perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\nYou must not use any built-in library function, such as sqrt.\nExample 1:\nInput: num = 16\nOutput: true\nExplanation: We return true because 4 * 4 = 16 and 4 is an integer.\nExample 2:\nInput: num = 14\nOutput: false\nExplanation: We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.\nConstraints:\n\t1 <= num <= 2^31 - 1",
        "topics": [
            "Math",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/valid-perfect-square/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} num\n * @return {boolean}\n */\nvar isPerfectSquare = function(num) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isPerfectSquare(int num) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\nExample 1:\nInput: nums = [2,2,3,4]\nOutput: 3\nExplanation: Valid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\nExample 2:\nInput: nums = [4,2,3,4]\nOutput: 4\nConstraints:\n\t1 <= nums.length <= 1000\n\t0 <= nums[i] <= 1000",
        "topics": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Greedy",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/valid-triangle-number/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar triangleNumber = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def triangleNumber(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int triangleNumber(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 address or \"Neither\" if IP is not a correct IP of any type.\nA valid IPv4 address is an IP in the form \"x1.x2.x3.x4\" where 0 <= xi <= 255 and xi cannot contain leading zeros. For example, \"192.168.1.1\" and \"192.168.1.0\" are valid IPv4 addresses while \"192.168.01.1\", \"192.168.1.00\", and \"192.168@1.1\" are invalid IPv4 addresses.\nA valid IPv6 address is an IP in the form \"x1:x2:x3:x4:x5:x6:x7:x8\" where:\n\t1 <= xi.length <= 4\n\txi is a hexadecimal string which may contain digits, lowercase English letter ('a' to 'f') and upper-case English letters ('A' to 'F').\n\tLeading zeros are allowed in xi.\nFor example, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\" and \"2001:db8:85a3:0:0:8A2E:0370:7334\" are valid IPv6 addresses, while \"2001:0db8:85a3::8A2E:037j:7334\" and \"02001:0db8:85a3:0000:0000:8a2e:0370:7334\" are invalid IPv6 addresses.\nExample 1:\nInput: queryIP = \"172.16.254.1\"\nOutput: \"IPv4\"\nExplanation: This is a valid IPv4 address, return \"IPv4\".\nExample 2:\nInput: queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\nOutput: \"IPv6\"\nExplanation: This is a valid IPv6 address, return \"IPv6\".\nExample 3:\nInput: queryIP = \"256.256.256.256\"\nOutput: \"Neither\"\nExplanation: This is neither a IPv4 address nor a IPv6 address.\nConstraints:\n\tqueryIP consists only of English letters, digits and the characters '.' and ':'.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/validate-ip-address/",
        "givenPythonCode": "/**\n * @param {string} queryIP\n * @return {string}\n */\nvar validIPAddress = function(queryIP) {\n    \n};",
        "givenJsCode": "class Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String validIPAddress(String queryIP) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Return whether the total amount of water in both jugs may reach target using the following operations:\n\tFill either jug completely with water.\n\tCompletely empty either jug.\n\tPour water from one jug into another until the receiving jug is full, or the transferring jug is empty.\nExample 1: \nInput:   x = 3, y = 5, target = 4 \nOutput:   true \nExplanation:\nFollow these steps to reach a total of 4 liters:\n\tFill the 5-liter jug (0, 5).\n\tPour from the 5-liter jug into the 3-liter jug, leaving 2 liters (3, 2).\n\tEmpty the 3-liter jug (0, 2).\n\tTransfer the 2 liters from the 5-liter jug to the 3-liter jug (2, 0).\n\tFill the 5-liter jug again (2, 5).\n\tPour from the 5-liter jug into the 3-liter jug until the 3-liter jug is full. This leaves 4 liters in the 5-liter jug (3, 4).\n\tEmpty the 3-liter jug. Now, you have exactly 4 liters in the 5-liter jug (0, 4).\nReference: The Die Hard example.\nExample 2: \nInput:   x = 2, y = 6, target = 5 \nOutput:   false \nExample 3: \nInput:   x = 1, y = 2, target = 3 \nOutput:   true \nExplanation: Fill both jugs. The total amount of water in both jugs is equal to 3 now.\nConstraints:\n\t1 <= x, y, target <= 10^3",
        "topics": [
            "Math",
            "Depth-First Search",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/water-and-jug-problem/",
        "givenPythonCode": "class Solution:\n    def canMeasureWater(self, x: int, y: int, target: int) -> bool:\n        ",
        "givenJsCode": "/**\n * @param {number} x\n * @param {number} y\n * @param {number} target\n * @return {boolean}\n */\nvar canMeasureWater = function(x, y, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public boolean canMeasureWater(int x, int y, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\tFor example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.\n\tIn contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\nA subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\nGiven an integer array nums, return the length of the longest wiggle subsequence of nums.\nExample 1:\nInput: nums = [1,7,4,9,2,5]\nOutput: 6\nExplanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\nExample 2:\nInput: nums = [1,17,5,10,13,15,10,5,16,8]\nOutput: 7\nExplanation: There are several subsequences that achieve this length.\nOne is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).\nExample 3:\nInput: nums = [1,2,3,4,5,6,7,8,9]\nOutput: 2\nConstraints:\n\t1 <= nums.length <= 1000\n\t0 <= nums[i] <= 1000\nFollow up: Could you solve this in O(n) time?",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/wiggle-subsequence/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar wiggleMaxLength = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def wiggleMaxLength(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int wiggleMaxLength(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\tEvery adjacent pair of words differs by a single letter.\n\tEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n\tsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].\nExample 1:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\nExplanation: There are 2 shortest transformation sequences:\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"\nExample 2:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: []\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\nConstraints:\n\t1 <= beginWord.length <= 5\n\tendWord.length == beginWord.length\n\t1 <= wordList.length <= 500\n\twordList[i].length == beginWord.length\n\tbeginWord, endWord, and wordList[i] consist of lowercase English letters.\n\tbeginWord != endWord\n\tAll the words in wordList are unique.\n\tThe sum of all shortest transformation sequences does not exceed 10^5.",
        "topics": [
            "Hash Table",
            "String",
            "Backtracking",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/word-ladder-ii/",
        "givenPythonCode": "class Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        ",
        "givenJsCode": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {string[][]}\n */\nvar findLadders = function(beginWord, endWord, wordList) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\tEvery adjacent pair of words differs by a single letter.\n\tEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n\tsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\nExample 1:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\nExample 2:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: 0\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\nConstraints:\n\t1 <= beginWord.length <= 10\n\tendWord.length == beginWord.length\n\t1 <= wordList.length <= 5000\n\twordList[i].length == beginWord.length\n\tbeginWord, endWord, and wordList[i] consist of lowercase English letters.\n\tbeginWord != endWord\n\tAll the words in wordList are unique.",
        "topics": [
            "Hash Table",
            "String",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/word-ladder/",
        "givenPythonCode": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a pattern and a string s, find if s follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.\nExample 1:\nInput: pattern = \"abba\", s = \"dog cat cat dog\"\nOutput: true\nExample 2:\nInput: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nExample 3:\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false\nConstraints:\n\t1 <= pattern.length <= 300\n\tpattern contains only lower-case English letters.\n\t1 <= s.length <= 3000\n\ts contains only lowercase English letters and spaces ' '.\n\ts does not contain any leading or trailing spaces.\n\tAll the words in s are separated by a single space.",
        "topics": [
            "Hash Table",
            "String"
        ],
        "url": "https://leetcode.com/problems/word-pattern/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def canMeasureWater(self, x: int, y: int, target: int) -> bool:\n        ",
        "givenJsCode": "/**\n * @param {number} x\n * @param {number} y\n * @param {number} target\n * @return {boolean}\n */\nvar canMeasureWater = function(x, y, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        \n    }\n}"
    },
    {
        "excercise": "You are given an integer array matchsticks where matchsticks[i] is the length of the i^th matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\nReturn true if you can make this square and false otherwise.\nExample 1:\nInput: matchsticks = [1,1,2,2,2]\nOutput: true\nExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.\nExample 2:\nInput: matchsticks = [3,3,3,3,4]\nOutput: false\nExplanation: You cannot find a way to form a square with all the matchsticks.\nConstraints:\n\t1 <= matchsticks.length <= 15\n\t1 <= matchsticks[i] <= 10^8",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Backtracking",
            "Bit Manipulation",
            "Bitmask"
        ],
        "url": "https://leetcode.com/problems/matchsticks-to-square/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\n    def makesquare(self, matchsticks: List[int]) -> bool:\n        ",
        "givenJsCode": "/**\n * @param {number[]} matchsticks\n * @return {boolean}\n */\nvar makesquare = function(matchsticks) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public boolean makesquare(int[] matchsticks) {\n        \n    }\n}"
    },
    {
        "excercise": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth\u00a0is the number of nodes along the longest path from the root node down to the farthest leaf node.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\nExample 2:\nInput: root = [1,null,2]\nOutput: 2\nConstraints:\n\tThe number of nodes in the tree is in the range [0, 10^4].\n\t-100 <= Node.val <= 100",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, invert the tree, and return its root.\nExample 1:\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\nExample 2:\nInput: root = [2,1,3]\nOutput: [2,3,1]\nExample 3:\nInput: root = []\nOutput: []\nConstraints:\n\tThe number of nodes in the tree is in the range [0, 100].\n\t-100 <= Node.val <= 100",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/invert-binary-tree/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {TreeNode}\r\n */\r\nvar invertTree = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode invertTree(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, return all root-to-leaf paths in any order.\nA leaf is a node with no children.\nExample 1:\nInput: root = [1,2,3,null,5]\nOutput: [\"1->2->5\",\"1->3\"]\nExample 2:\nInput: root = [1]\nOutput: [\"1\"]\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 100].\n\t-100 <= Node.val <= 100",
        "topics": [
            "String",
            "Backtracking",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/binary-tree-paths/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {string[]}\r\n */\r\nvar binaryTreePaths = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<String> binaryTreePaths(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given row x col grid representing a map where grid[i][j] = 1 represents\u00a0land and grid[i][j] = 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\nExample 1:\nInput: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\nOutput: 16\nExplanation: The perimeter is the 16 yellow stripes in the image above.\nExample 2:\nInput: grid = [[1]]\nOutput: 4\nExample 3:\nInput: grid = [[1,0]]\nOutput: 4\nConstraints:\n\trow == grid.length\n\tcol == grid[i].length\n\t1 <= row, col <= 100\n\tgrid[i][j] is 0 or 1.\n\tThere is exactly one island in grid.",
        "topics": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/island-perimeter/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar islandPerimeter = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int islandPerimeter(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.\nExample 1:\nInput: root = [4,2,6,1,3]\nOutput: 1\nExample 2:\nInput: root = [1,0,48,null,null,12,49]\nOutput: 1\nConstraints:\n\tThe number of nodes in the tree is in the range [2, 10^4].\n\t0 <= Node.val <= 10^5\nNote: This question is the same as 783: https://leetcode.com/problems/minimum-distance-between-bst-nodes/",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/minimum-absolute-difference-in-bst/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar getMinimumDifference = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int getMinimumDifference(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, return the sum of every tree node's tilt.\nThe tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if the node does not have a right child.\nExample 1:\nInput: root = [1,2,3]\nOutput: 1\nExplanation: \nTilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1\nExample 2:\nInput: root = [4,2,9,3,5,null,7]\nOutput: 15\nExplanation: \nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\nExample 3:\nInput: root = [21,7,14,1,1,2,2,3,3]\nOutput: 9\nConstraints:\n\tThe number of nodes in the tree is in the range [0, 10^4].\n\t-1000 <= Node.val <= 1000",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/binary-tree-tilt/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def findTilt(self, root: Optional[TreeNode]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar findTilt = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int findTilt(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "A tree is an undirected graph in which any two vertices are connected by\u00a0exactly\u00a0one path. In other words, any connected graph without simple cycles is a tree.\nGiven a tree of n nodes\u00a0labelled from 0 to n - 1, and an array of\u00a0n - 1\u00a0edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes\u00a0ai and\u00a0bi in the tree,\u00a0you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))\u00a0 are called minimum height trees (MHTs).\nReturn a list of all MHTs' root labels.\u00a0You can return the answer in any order.\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\nExample 1:\nInput: n = 4, edges = [[1,0],[1,2],[1,3]]\nOutput: [1]\nExplanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\nExample 2:\nInput: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\nOutput: [3,4]\nConstraints:\n\t1 <= n <= 2 * 10^4\n\tedges.length == n - 1\n\t0 <= ai, bi < n\n\tai != bi\n\tAll the pairs (ai, bi) are distinct.\n\tThe given input is guaranteed to be a tree and there will be no repeated edges.",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "url": "https://leetcode.com/problems/minimum-height-trees/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} edges\r\n * @return {number[]}\r\n */\r\nvar findMinHeightTrees = function(n, edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\nExample 2:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\nExample 3:\nInput: root = [1,2], p = 1, q = 2\nOutput: 1\nConstraints:\n\tThe number of nodes in the tree is in the range [2, 10^5].\n\t-10^9 <= Node.val <= 10^9\n\tAll Node.val are unique.\n\tp != q\n\tp and q will exist in the tree.",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution:\r\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {TreeNode}\r\n */\r\nvar lowestCommonAncestor = function(root, p, q) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d\nExample 1:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA of nodes 2 and 8 is 6.\nExample 2:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\nExample 3:\nInput: root = [2,1], p = 2, q = 1\nOutput: 2\nConstraints:\n\tThe number of nodes in the tree is in the range [2, 10^5].\n\t-10^9 <= Node.val <= 10^9\n\tAll Node.val are unique.\n\tp != q\n\tp and q will exist in the BST.",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution:\r\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {TreeNode} root\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {TreeNode}\r\n */\r\nvar lowestCommonAncestor = function(root, p, q) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\n\r\nclass Solution {\r\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary search tree, and an integer k, return the k^th smallest value (1-indexed) of all the values of the nodes in the tree.\nExample 1:\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\nExample 2:\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\nConstraints:\n\tThe number of nodes in the tree is n.\n\t1 <= k <= n <= 10^4\n\t0 <= Node.val <= 10^4\nFollow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar kthSmallest = function(root, k) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int kthSmallest(TreeNode root, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\tFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\nExample 2:\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\nExample 3:\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\nConstraints:\n\t1 <= numCourses <= 2000\n\t0 <= prerequisites.length <= numCourses * (numCourses - 1)\n\tprerequisites[i].length == 2\n\t0 <= ai, bi < numCourses\n\tai != bi\n\tAll the pairs [ai, bi] are distinct.",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "url": "https://leetcode.com/problems/course-schedule-ii/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} numCourses\r\n * @param {number[][]} prerequisites\r\n * @return {number[]}\r\n */\r\nvar findOrder = function(numCourses, prerequisites) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExample 1:\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\nExample 2:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\nConstraints:\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 300\n\tgrid[i][j] is '0' or '1'.",
        "topics": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/number-of-islands/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def numIslands(self, grid: List[List[str]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {character[][]} grid\r\n * @return {number}\r\n */\r\nvar numIslands = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numIslands(char[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nExample 1:\nInput: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]\nExample 2:\nInput: root = [1,null,3]\nOutput: [1,3]\nExample 3:\nInput: root = []\nOutput: []\nConstraints:\n\tThe number of nodes in the tree is in the range [0, 100].\n\t-100 <= Node.val <= 100",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/binary-tree-right-side-view/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nvar rightSideView = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<Integer> rightSideView(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.\nExample 1:\nInput: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\nOutput: 700\nExplanation:\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.\nExample 2:\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200\nExplanation:\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\nExample 3:\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500\nExplanation:\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\nConstraints:\n\t1 <= n <= 100\n\t0 <= flights.length <= (n * (n - 1) / 2)\n\tflights[i].length == 3\n\t0 <= fromi, toi < n\n\tfromi != toi\n\t1 <= pricei <= 10^4\n\tThere will not be any multiple flights between two cities.\n\t0 <= src, dst, k < n\n\tsrc != dst",
        "topics": [
            "Dynamic Programming",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Heap (Priority Queue)",
            "Shortest Path"
        ],
        "url": "https://leetcode.com/problems/cheapest-flights-within-k-stops/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} flights\r\n * @param {number} src\r\n * @param {number} dst\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar findCheapestPrice = function(n, flights, src, dst, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order.\nThe graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).\nExample 1:\nInput: graph = [[1,2],[3],[3],[]]\nOutput: [[0,1,3],[0,2,3]]\nExplanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.\nExample 2:\nInput: graph = [[4,3,1],[3,2,4],[3],[4],[]]\nOutput: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\nConstraints:\n\tn == graph.length\n\t2 <= n <= 15\n\t0 <= graph[i][j] < n\n\tgraph[i][j] != i (i.e., there will be no self-loops).\n\tAll the elements of graph[i] are unique.\n\tThe input graph is guaranteed to be a DAG.",
        "topics": [
            "Backtracking",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/all-paths-from-source-to-target/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} graph\r\n * @return {number[][]}\r\n */\r\nvar allPathsSourceTarget = function(graph) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\nReturn the size of the largest island in grid after applying this operation.\nAn island is a 4-directionally connected group of 1s.\nExample 1:\nInput: grid = [[1,0],[0,1]]\nOutput: 3\nExplanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\nExample 2:\nInput: grid = [[1,1],[1,0]]\nOutput: 4\nExplanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.\nExample 3:\nInput: grid = [[1,1],[1,1]]\nOutput: 4\nExplanation: Can't change any 0 to 1, only one island with area = 4.\nConstraints:\n\tn == grid.length\n\tn == grid[i].length\n\t1 <= n <= 500\n\tgrid[i][j] is either 0 or 1.",
        "topics": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/making-a-large-island/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def largestIsland(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar largestIsland = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int largestIsland(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\nYou are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nReturn an array answer of length n where answer[i] is the sum of the distances between the i^th node in the tree and all other nodes.\nExample 1:\nInput: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\nOutput: [8,12,6,10,10,10]\nExplanation: The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer[0] = 8, and so on.\nExample 2:\nInput: n = 1, edges = []\nOutput: [0]\nExample 3:\nInput: n = 2, edges = [[1,0]]\nOutput: [1,1]\nConstraints:\n\t1 <= n <= 3 * 10^4\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t0 <= ai, bi < n\n\tai != bi\n\tThe given input represents a valid tree.",
        "topics": [
            "Dynamic Programming",
            "Tree",
            "Depth-First Search",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/sum-of-distances-in-tree/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} edges\r\n * @return {number[]}\r\n */\r\nvar sumOfDistancesInTree = function(n, edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] sumOfDistancesInTree(int n, int[][] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Two strings, X and Y, are considered similar if either they are identical or we can make them equivalent by swapping at most two letters (in distinct positions) within the string X.\nFor example, \"tars\"\u00a0and \"rats\"\u00a0are similar (swapping at positions 0 and 2), and \"rats\" and \"arts\" are similar, but \"star\" is not similar to \"tars\", \"rats\", or \"arts\".\nTogether, these form two connected groups by similarity: {\"tars\", \"rats\", \"arts\"} and {\"star\"}.\u00a0 Notice that \"tars\" and \"arts\" are in the same group even though they are not similar.\u00a0 Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\nWe are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?\nExample 1:\nInput: strs = [\"tars\",\"rats\",\"arts\",\"star\"]\nOutput: 2\nExample 2:\nInput: strs = [\"omv\",\"ovm\"]\nOutput: 1\nConstraints:\n\t1 <= strs.length <= 300\n\t1 <= strs[i].length <= 300\n\tstrs[i] consists of lowercase letters only.\n\tAll words in strs have the same length and are anagrams of each other.",
        "topics": [
            "Array",
            "Hash Table",
            "String",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find"
        ],
        "url": "https://leetcode.com/problems/similar-string-groups/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def numSimilarGroups(self, strs: List[str]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string[]} strs\r\n * @return {number}\r\n */\r\nvar numSimilarGroups = function(strs) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numSimilarGroups(String[] strs) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a network of n nodes represented as an n x n adjacency matrix graph, where the i^th node is directly connected to the j^th node if graph[i][j] == 1.\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial.\nReturn the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\nNote that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.\nExample 1:\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\nExample 2:\nInput: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]\nOutput: 0\nExample 3:\nInput: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]\nOutput: 1\nConstraints:\n\tn == graph.length\n\tn == graph[i].length\n\t2 <= n <= 300\n\tgraph[i][j] is 0 or 1.\n\tgraph[i][j] == graph[j][i]\n\tgraph[i][i] == 1\n\t1 <= initial.length <= n\n\t0 <= initial[i] <= n - 1\n\tAll the integers in initial are unique.",
        "topics": [
            "Array",
            "Hash Table",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/minimize-malware-spread/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} graph\r\n * @param {number[]} initial\r\n * @return {number}\r\n */\r\nvar minMalwareSpread = function(graph, initial) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minMalwareSpread(int[][] graph, int[] initial) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a network of n nodes represented as an n x n adjacency matrix graph, where the i^th node is directly connected to the j^th node if graph[i][j] == 1.\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops.\nWe will remove exactly one node from initial, completely removing it and any connections from this node to any other node.\nReturn the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\nExample 1:\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\nExample 2:\nInput: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]\nOutput: 1\nExample 3:\nInput: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]\nOutput: 1\nConstraints:\n\tn == graph.length\n\tn == graph[i].length\n\t2 <= n <= 300\n\tgraph[i][j] is 0 or 1.\n\tgraph[i][j] == graph[j][i]\n\tgraph[i][i] == 1\n\t1 <= initial.length <\u00a0n\n\t0 <= initial[i] <= n - 1\n\tAll the integers in initial are unique.",
        "topics": [
            "Array",
            "Hash Table",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/minimize-malware-spread-ii/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} graph\r\n * @param {number[]} initial\r\n * @return {number}\r\n */\r\nvar minMalwareSpread = function(graph, initial) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minMalwareSpread(int[][] graph, int[] initial) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. The word's maximum k-repeating value is the highest value k where word is k-repeating in sequence. If word is not a substring of sequence, word's maximum k-repeating value is 0.\nGiven strings sequence and word, return the maximum k-repeating value of word in sequence.\nExample 1:\nInput: sequence = \"ababc\", word = \"ab\"\nOutput: 2\nExplanation: \"abab\" is a substring in \"ababc\".\nExample 2:\nInput: sequence = \"ababc\", word = \"ba\"\nOutput: 1\nExplanation: \"ba\" is a substring in \"ababc\". \"baba\" is not a substring in \"ababc\".\nExample 3:\nInput: sequence = \"ababc\", word = \"ac\"\nOutput: 0\nExplanation: \"ac\" is not a substring in \"ababc\". \nConstraints:\n\t1 <= sequence.length <= 100\n\t1 <= word.length <= 100\n\tsequence and word\u00a0contains only lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming",
            "String Matching"
        ],
        "url": "https://leetcode.com/problems/maximum-repeating-substring/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def maxRepeating(self, sequence: str, word: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} sequence\r\n * @param {string} word\r\n * @return {number}\r\n */\r\nvar maxRepeating = function(sequence, word) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maxRepeating(String sequence, String word) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\nExample 1:\nInput: s = \"abc\", t = \"ahbgdc\"\nOutput: true\nExample 2:\nInput: s = \"axc\", t = \"ahbgdc\"\nOutput: false\nConstraints:\n\t0 <= s.length <= 100\n\t0 <= t.length <= 10^4\n\ts and t consist only of lowercase English letters.\nFollow up: Suppose there are lots of incoming s, say s1, s2, ..., sk where k >= 10^9, and you want to check one by one to see if t has its subsequence. In this scenario, how would you change your code?",
        "topics": [
            "Two Pointers",
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/is-subsequence/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def isSubsequence(self, s: str, t: str) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @param {string} t\r\n * @return {boolean}\r\n */\r\nvar isSubsequence = function(s, t) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean isSubsequence(String s, String t) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nExample 1:\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\nExample 2:\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\nConstraints:\n\t1 <= n <= 45",
        "topics": [
            "Math",
            "Dynamic Programming",
            "Memoization"
        ],
        "url": "https://leetcode.com/problems/climbing-stairs/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def climbStairs(self, n: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar climbStairs = function(n) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int climbStairs(int n) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\nConstraints:\n\t1 <= prices.length <= 10^5\n\t0 <= prices[i] <= 10^4",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def maxProfit(self, prices: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} prices\r\n * @return {number}\r\n */\r\nvar maxProfit = function(prices) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maxProfit(int[] prices) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a string array words and a binary array groups both of length n, where words[i] is associated with groups[i].\nYour task is to select the longest alternating subsequence from words. A subsequence of words is alternating if for any two consecutive strings in the sequence, their corresponding elements in the binary array groups differ. Essentially, you are to choose strings such that adjacent elements have non-matching corresponding bits in the groups array.\nFormally, you need to find the longest subsequence of an array of indices [0, 1, ..., n - 1] denoted as [i0, i1, ..., ik-1], such that groups[ij] != groups[ij+1] for each 0 <= j < k - 1 and then find the words corresponding to these indices.\nReturn the selected subsequence. If there are multiple answers, return any of them.\nNote: The elements in words are distinct.\nExample 1:\nInput: words = [\"e\",\"a\",\"b\"], groups = [0,0,1]\nOutput: [\"e\",\"b\"]\nExplanation: A subsequence that can be selected is [\"e\",\"b\"] because groups[0] != groups[2]. Another subsequence that can be selected is [\"a\",\"b\"] because groups[1] != groups[2]. It can be demonstrated that the length of the longest subsequence of indices that satisfies the condition is 2.\nExample 2:\nInput: words = [\"a\",\"b\",\"c\",\"d\"], groups = [1,0,1,1]\nOutput: [\"a\",\"b\",\"c\"]\nExplanation: A subsequence that can be selected is [\"a\",\"b\",\"c\"] because groups[0] != groups[1] and groups[1] != groups[2]. Another subsequence that can be selected is [\"a\",\"b\",\"d\"] because groups[0] != groups[1] and groups[1] != groups[3]. It can be shown that the length of the longest subsequence of indices that satisfies the condition is 3.\nConstraints:\n\t1 <= n == words.length == groups.length <= 100\n\t1 <= words[i].length <= 10\n\tgroups[i] is either 0 or 1.\n\twords consists of distinct strings.\n\twords[i] consists of lowercase English letters.",
        "topics": [
            "Array",
            "String",
            "Dynamic Programming",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-i/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def getLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string[]} words\r\n * @param {number[]} groups\r\n * @return {string[]}\r\n */\r\nvar getLongestSubsequence = function(words, groups) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<String> getLongestSubsequence(String[] words, int[] groups) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer money denoting the amount of money (in dollars) that you have and another integer children denoting the number of children that you must distribute the money to.\nYou have to distribute the money according to the following rules:\n\tAll money must be distributed.\n\tEveryone must receive at least 1 dollar.\n\tNobody receives 4 dollars.\nReturn the maximum number of children who may receive exactly 8 dollars if you distribute the money according to the aforementioned rules. If there is no way to distribute the money, return -1.\nExample 1:\nInput: money = 20, children = 3\nOutput: 1\nExplanation: \nThe maximum number of children with 8 dollars will be 1. One of the ways to distribute the money is:\n- 8 dollars to the first child.\n- 9 dollars to the second child. \n- 3 dollars to the third child.\nIt can be proven that no distribution exists such that number of children getting 8 dollars is greater than 1.\nExample 2:\nInput: money = 16, children = 2\nOutput: 2\nExplanation: Each child can be given 8 dollars.\nConstraints:\n\t1 <= money <= 200\n\t2 <= children <= 30",
        "topics": [
            "Math",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/distribute-money-to-maximum-children/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def distMoney(self, money: int, children: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} money\r\n * @param {number} children\r\n * @return {number}\r\n */\r\nvar distMoney = function(money, children) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int distMoney(int money, int children) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\nExample 1:\nInput: flowerbed = [1,0,0,0,1], n = 1\nOutput: true\nExample 2:\nInput: flowerbed = [1,0,0,0,1], n = 2\nOutput: false\nConstraints:\n\t1 <= flowerbed.length <= 2 * 10^4\n\tflowerbed[i] is 0 or 1.\n\tThere are no two adjacent flowers in flowerbed.\n\t0 <= n <= flowerbed.length",
        "topics": [
            "Array",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/can-place-flowers/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} flowerbed\r\n * @param {number} n\r\n * @return {boolean}\r\n */\r\nvar canPlaceFlowers = function(flowerbed, n) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a string s, return true if the s can be palindrome after deleting at most one character from it.\nExample 1:\nInput: s = \"aba\"\nOutput: true\nExample 2:\nInput: s = \"abca\"\nOutput: true\nExplanation: You could delete the character 'c'.\nExample 3:\nInput: s = \"abc\"\nOutput: false\nConstraints:\n\t1 <= s.length <= 10^5\n\ts consists of lowercase English letters.",
        "topics": [
            "Two Pointers",
            "String",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/valid-palindrome-ii/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def validPalindrome(self, s: str) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {boolean}\r\n */\r\nvar validPalindrome = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean validPalindrome(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There exists an undirected tree with n nodes numbered 0 to n - 1. You are given a 0-indexed 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree. You are also given a positive integer k, and a 0-indexed array of non-negative integers nums of length n, where nums[i] represents the value of the node numbered i.\nAlice wants the sum of values of tree nodes to be maximum, for which Alice can perform the following operation any number of times (including zero) on the tree:\n\tChoose any edge [u, v] connecting the nodes u and v, and update their values as follows:\n\t\tnums[u] = nums[u] XOR k\n\t\tnums[v] = nums[v] XOR k\nReturn the maximum possible sum of the values Alice can achieve by performing the operation any number of times.\nExample 1:\nInput: nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]\nOutput: 6\nExplanation: Alice can achieve the maximum sum of 6 using a single operation:\n- Choose the edge [0,2]. nums[0] and nums[2] become: 1 XOR 3 = 2, and the array nums becomes: [1,2,1] -> [2,2,2].\nThe total sum of values is 2 + 2 + 2 = 6.\nIt can be shown that 6 is the maximum achievable sum of values.\nExample 2:\nInput: nums = [2,3], k = 7, edges = [[0,1]]\nOutput: 9\nExplanation: Alice can achieve the maximum sum of 9 using a single operation:\n- Choose the edge [0,1]. nums[0] becomes: 2 XOR 7 = 5 and nums[1] become: 3 XOR 7 = 4, and the array nums becomes: [2,3] -> [5,4].\nThe total sum of values is 5 + 4 = 9.\nIt can be shown that 9 is the maximum achievable sum of values.\nExample 3:\nInput: nums = [7,7,7,7,7,7], k = 3, edges = [[0,1],[0,2],[0,3],[0,4],[0,5]]\nOutput: 42\nExplanation: The maximum achievable sum is 42 which can be achieved by Alice performing no operations.\nConstraints:\n\t2 <= n == nums.length <= 2 * 10^4\n\t1 <= k <= 10^9\n\t0 <= nums[i] <= 10^9\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t0 <= edges[i][0], edges[i][1] <= n - 1\n\tThe input is generated such that edges represent\u00a0a valid tree.",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Greedy",
            "Bit Manipulation",
            "Tree",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/find-the-maximum-sum-of-node-values/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @param {number[][]} edges\r\n * @return {number}\r\n */\r\nvar maximumValueSum = function(nums, k, edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long maximumValueSum(int[] nums, int k, int[][] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. There exists a unique path between each pair of cities. In other words, the cities form a tree.\nA subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\nFor each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d.\nReturn an array of size n-1 where the d^th element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d.\nNotice\u00a0that\u00a0the distance between the two cities is the number of edges in the path between them.\nExample 1:\nInput: n = 4, edges = [[1,2],[2,3],[2,4]]\nOutput: [3,4,0]\nExplanation:\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\nExample 2:\nInput: n = 2, edges = [[1,2]]\nOutput: [1]\nExample 3:\nInput: n = 3, edges = [[1,2],[2,3]]\nOutput: [2,1]\nConstraints:\n\t2 <= n <= 15\n\tedges.length == n-1\n\tedges[i].length == 2\n\t1 <= ui, vi <= n\n\tAll pairs (ui, vi) are distinct.",
        "topics": [
            "Dynamic Programming",
            "Bit Manipulation",
            "Tree",
            "Enumeration",
            "Bitmask"
        ],
        "url": "https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} edges\r\n * @return {number[]}\r\n */\r\nvar countSubgraphsForEachDiameter = function(n, edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] countSubgraphsForEachDiameter(int n, int[][] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\nYou are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nReturn an array answer of length n where answer[i] is the sum of the distances between the i^th node in the tree and all other nodes.\nExample 1:\nInput: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\nOutput: [8,12,6,10,10,10]\nExplanation: The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer[0] = 8, and so on.\nExample 2:\nInput: n = 1, edges = []\nOutput: [0]\nExample 3:\nInput: n = 2, edges = [[1,0]]\nOutput: [1,1]\nConstraints:\n\t1 <= n <= 3 * 10^4\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t0 <= ai, bi < n\n\tai != bi\n\tThe given input represents a valid tree.",
        "topics": [
            "Dynamic Programming",
            "Tree",
            "Depth-First Search",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/sum-of-distances-in-tree/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} edges\r\n * @return {number[]}\r\n */\r\nvar sumOfDistancesInTree = function(n, edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] sumOfDistancesInTree(int n, int[][] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are also given a 0-indexed integer array values of length n, where values[i] is the value associated with the i^th node, and an integer k.\nA valid split of the tree is obtained by removing any set of edges, possibly empty, from the tree such that the resulting components all have values that are divisible by k, where the value of a connected component is the sum of the values of its nodes.\nReturn the maximum number of components in any valid split.\nExample 1:\nInput: n = 5, edges = [[0,2],[1,2],[1,3],[2,4]], values = [1,8,1,4,4], k = 6\nOutput: 2\nExplanation: We remove the edge connecting node 1 with 2. The resulting split is valid because:\n- The value of the component containing nodes 1 and 3 is values[1] + values[3] = 12.\n- The value of the component containing nodes 0, 2, and 4 is values[0] + values[2] + values[4] = 6.\nIt can be shown that no other valid split has more than 2 connected components.\nExample 2:\nInput: n = 7, edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [3,0,6,1,5,2,1], k = 3\nOutput: 3\nExplanation: We remove the edge connecting node 0 with 2, and the edge connecting node 0 with 1. The resulting split is valid because:\n- The value of the component containing node 0 is values[0] = 3.\n- The value of the component containing nodes 2, 5, and 6 is values[2] + values[5] + values[6] = 9.\n- The value of the component containing nodes 1, 3, and 4 is values[1] + values[3] + values[4] = 6.\nIt can be shown that no other valid split has more than 3 connected components.\nConstraints:\n\t1 <= n <= 3 * 10^4\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t0 <= ai, bi < n\n\tvalues.length == n\n\t0 <= values[i] <= 10^9\n\t1 <= k <= 10^9\n\tSum of values is divisible by k.\n\tThe input is generated such that edges represents a valid tree.",
        "topics": [
            "Tree",
            "Depth-First Search"
        ],
        "url": "https://leetcode.com/problems/maximum-number-of-k-divisible-components/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def maxKDivisibleComponents(self, n: int, edges: List[List[int]], values: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} edges\r\n * @param {number[]} values\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar maxKDivisibleComponents = function(n, edges, values, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maxKDivisibleComponents(int n, int[][] edges, int[] values, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order.\nExample 1:\nInput: root1 = [2,1,4], root2 = [1,0,3]\nOutput: [0,1,1,2,3,4]\nExample 2:\nInput: root1 = [1,null,8], root2 = [8,1]\nOutput: [1,1,8,8]\nConstraints:\n\tThe number of nodes in each tree is in the range [0, 5000].\n\t-10^5 <= Node.val <= 10^5",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Sorting",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/all-elements-in-two-binary-search-trees/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root1\r\n * @param {TreeNode} root2\r\n * @return {number[]}\r\n */\r\nvar getAllElements = function(root1, root2) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.\nA node a is an ancestor of b if either: any child of a is equal to b\u00a0or any child of a is an ancestor of b.\nExample 1:\nInput: root = [8,3,10,1,6,null,14,null,null,4,7,13]\nOutput: 7\nExplanation: We have various ancestor-node differences, some of which are given below :\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\nAmong all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.\nExample 2:\nInput: root = [1,null,2,null,0,3]\nOutput: 3\nConstraints:\n\tThe number of nodes in the tree is in the range [2, 5000].\n\t0 <= Node.val <= 10^5",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxAncestorDiff = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxAncestorDiff(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\n\tFor example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.\nExample 1:\nInput: root = [2,3,5,8,13,21,34]\nOutput: [2,5,3,8,13,21,34]\nExplanation: \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.\nExample 2:\nInput: root = [7,13,11]\nOutput: [7,11,13]\nExplanation: \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.\nExample 3:\nInput: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\nOutput: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\nExplanation: \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 2^14].\n\t0 <= Node.val <= 10^5\n\troot is a perfect binary tree.",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {TreeNode}\r\n */\r\nvar reverseOddLevels = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode reverseOddLevels(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a binary tree root and an integer target, delete all the leaf nodes with value target.\nNote that once you delete a leaf node with value target, if its parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you cannot).\nExample 1:\nInput: root = [1,2,3,2,null,2,4], target = 2\nOutput: [1,null,3,null,4]\nExplanation: Leaf nodes in green with value (target = 2) are removed (Picture in left). \nAfter removing, new nodes become leaf nodes with value (target = 2) (Picture in center).\nExample 2:\nInput: root = [1,3,3,3,2], target = 3\nOutput: [1,3,null,null,2]\nExample 3:\nInput: root = [1,2,null,2,null,2], target = 2\nOutput: [1]\nExplanation: Leaf nodes in green with value (target = 2) are removed at each step.\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 3000].\n\t1 <= Node.val, target <= 1000",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/delete-leaves-with-a-given-value/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def removeLeafNodes(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} target\r\n * @return {TreeNode}\r\n */\r\nvar removeLeafNodes = function(root, target) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode removeLeafNodes(TreeNode root, int target) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\nReturn the minimum number of moves required to make every node have exactly one coin.\nExample 1:\nInput: root = [3,0,0]\nOutput: 2\nExplanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.\nExample 2:\nInput: root = [0,3,0]\nOutput: 3\nExplanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.\nConstraints:\n\tThe number of nodes in the tree is n.\n\t1 <= n <= 100\n\t0 <= Node.val <= n\n\tThe sum of all Node.val is n.",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/distribute-coins-in-binary-tree/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def distributeCoins(self, root: Optional[TreeNode]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar distributeCoins = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int distributeCoins(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\nNotice\u00a0that there may exist\u00a0multiple valid ways for the\u00a0insertion, as long as the tree remains a BST after insertion. You can return any of them.\nExample 1:\nInput: root = [4,2,7,1,3], val = 5\nOutput: [4,2,7,1,3,5]\nExplanation: Another accepted tree is:\nExample 2:\nInput: root = [40,20,60,10,30,50,70], val = 25\nOutput: [40,20,60,10,30,50,70,null,null,25]\nExample 3:\nInput: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\nOutput: [4,2,7,1,3,5]\nConstraints:\n\tThe number of nodes in\u00a0the tree will be in the range [0,\u00a010^4].\n\t-10^8 <= Node.val <= 10^8\n\tAll the values Node.val are unique.\n\t-10^8 <= val <= 10^8\n\tIt's guaranteed that val does not exist in the original BST.",
        "topics": [
            "Tree",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/insert-into-a-binary-search-tree/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} val\r\n * @return {TreeNode}\r\n */\r\nvar insertIntoBST = function(root, val) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode insertIntoBST(TreeNode root, int val) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].\nExample 1:\nInput: root = [10,5,15,3,7,null,18], low = 7, high = 15\nOutput: 32\nExplanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.\nExample 2:\nInput: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\nOutput: 23\nExplanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 2 * 10^4].\n\t1 <= Node.val <= 10^5\n\t1 <= low <= high <= 10^5\n\tAll Node.val are unique.",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/range-sum-of-bst/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} low\r\n * @param {number} high\r\n * @return {number}\r\n */\r\nvar rangeSumBST = function(root, low, high) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int rangeSumBST(TreeNode root, int low, int high) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given two binary trees original and cloned and given a reference to a node target in the original tree.\nThe cloned tree is a copy of the original tree.\nReturn a reference to the same node in the cloned tree.\nNote that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.\nExample 1:\nInput: tree = [7,4,3,null,null,6,19], target = 3\nOutput: 3\nExplanation: In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.\nExample 2:\nInput: tree = [7], target =  7\nOutput: 7\nExample 3:\nInput: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4\nOutput: 4\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 10^4].\n\tThe values of the nodes of the tree are unique.\n\ttarget node is a node from the original tree and is not null.\nFollow up: Could you solve the problem if repeated values on the tree are allowed?",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution:\r\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * class TreeNode {\r\n *     val: number\r\n *     left: TreeNode | null\r\n *     right: TreeNode | null\r\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.left = (left===undefined ? null : left)\r\n *         this.right = (right===undefined ? null : right)\r\n *     }\r\n * }\r\n */\r\n\r\nfunction getTargetCopy(original: TreeNode | null, cloned: TreeNode | null, target: TreeNode | null): TreeNode | null {\r\n\r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\n\r\nclass Solution {\r\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given the root of a full binary tree with the following properties:\n\tLeaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True.\n\tNon-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND.\nThe evaluation of a node is as follows:\n\tIf the node is a leaf node, the evaluation is the value of the node, i.e. True or False.\n\tOtherwise, evaluate the node's two children and apply the boolean operation of its value with the children's evaluations.\nReturn the boolean result of evaluating the root node.\nA full binary tree is a binary tree where each node has either 0 or 2 children.\nA leaf node is a node that has zero children.\nExample 1:\nInput: root = [2,1,3,null,null,0,1]\nOutput: true\nExplanation: The above diagram illustrates the evaluation process.\nThe AND node evaluates to False AND True = False.\nThe OR node evaluates to True OR False = True.\nThe root node evaluates to True, so we return true.\nExample 2:\nInput: root = [0]\nOutput: false\nExplanation: The root node is a leaf node and it evaluates to false, so we return false.\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 1000].\n\t0 <= Node.val <= 3\n\tEvery node has either 0 or 2 children.\n\tLeaf nodes have a value of 0 or 1.\n\tNon-leaf nodes have a value of 2 or 3.",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/evaluate-boolean-binary-tree/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {boolean}\r\n */\r\nvar evaluateTree = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean evaluateTree(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\nExample 1:\nInput: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]\nExample 2:\nInput: root = [4,2,7,1,3], val = 5\nOutput: []\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 5000].\n\t1 <= Node.val <= 10^7\n\troot is a binary search tree.\n\t1 <= val <= 10^7",
        "topics": [
            "Tree",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/search-in-a-binary-search-tree/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} val\r\n * @return {TreeNode}\r\n */\r\nvar searchBST = function(root, val) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode searchBST(TreeNode root, int val) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, return the lowest common ancestor of its deepest leaves.\nRecall that:\n\tThe node of a binary tree is a leaf if and only if it has no children\n\tThe depth of the root of the tree is 0. if the depth of a node is d, the depth of each of its children is d + 1.\n\tThe lowest common ancestor of a set S of nodes, is the node A with the largest depth such that every node in S is in the subtree with root A.\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4]\nOutput: [2,7,4]\nExplanation: We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest leaf-nodes of the tree.\nNote that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.\nExample 2:\nInput: root = [1]\nOutput: [1]\nExplanation: The root is the deepest node in the tree, and it's the lca of itself.\nExample 3:\nInput: root = [0,1,3,null,2]\nOutput: [2]\nExplanation: The deepest leaf node in the tree is 2, the lca of one node is itself.\nConstraints:\n\tThe number of nodes in the tree will be in the range [1, 1000].\n\t0 <= Node.val <= 1000\n\tThe values of the nodes in the tree are unique.\nNote: This question is the same as 865: https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/",
        "topics": [
            "Hash Table",
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {TreeNode}\r\n */\r\nvar lcaDeepestLeaves = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode lcaDeepestLeaves(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, each node in the tree has a distinct value.\nAfter deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).\nReturn the roots of the trees in the remaining forest. You may return the result in any order.\nExample 1:\nInput: root = [1,2,3,4,5,6,7], to_delete = [3,5]\nOutput: [[1,2,null,4],[6],[7]]\nExample 2:\nInput: root = [1,2,4,null,3], to_delete = [3]\nOutput: [[1,2,4]]\nConstraints:\n\tThe number of nodes in the given tree is at most 1000.\n\tEach node has a distinct value between 1 and 1000.\n\tto_delete.length <= 1000\n\tto_delete contains distinct values between 1 and 1000.",
        "topics": [
            "Array",
            "Hash Table",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/delete-nodes-and-return-forest/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def delNodes(self, root: Optional[TreeNode], to_delete: List[int]) -> List[TreeNode]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number[]} to_delete\r\n * @return {TreeNode[]}\r\n */\r\nvar delNodes = function(root, to_delete) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed.\nA subtree of a node node is node plus every node that is a descendant of node.\nExample 1:\nInput: root = [1,null,0,0,1]\nOutput: [1,null,0,null,1]\nExplanation: \nOnly the red nodes satisfy the property \"every subtree not containing a 1\".\nThe diagram on the right represents the answer.\nExample 2:\nInput: root = [1,0,1,0,0,0,1]\nOutput: [1,null,1,null,1]\nExample 3:\nInput: root = [1,1,0,1,1,0,1,0]\nOutput: [1,1,0,1,1,null,1]\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 200].\n\tNode.val is either 0 or 1.",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/binary-tree-pruning/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {TreeNode}\r\n */\r\nvar pruneTree = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode pruneTree(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an n x n integer matrix. You can do the following operation any number of times:\n\tChoose any two adjacent elements of matrix and multiply each of them by -1.\nTwo elements are considered adjacent if and only if they share a border.\nYour goal is to maximize the summation of the matrix's elements. Return the maximum sum of the matrix's elements using the operation mentioned above.\nExample 1:\nInput: matrix = [[1,-1],[-1,1]]\nOutput: 4\nExplanation: We can follow the following steps to reach sum equals 4:\n- Multiply the 2 elements in the first row by -1.\n- Multiply the 2 elements in the first column by -1.\nExample 2:\nInput: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]\nOutput: 16\nExplanation: We can follow the following step to reach sum equals 16:\n- Multiply the 2 last elements in the second row by -1.\nConstraints:\n\tn == matrix.length == matrix[i].length\n\t2 <= n <= 250\n\t-10^5 <= matrix[i][j] <= 10^5",
        "topics": [
            "Array",
            "Greedy",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/maximum-matrix-sum/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} matrix\r\n * @return {number}\r\n */\r\nvar maxMatrixSum = function(matrix) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long maxMatrixSum(int[][] matrix) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an m x n matrix board, representing the current state of a crossword puzzle. The crossword contains lowercase English letters (from solved words), ' ' to represent any empty cells, and '#' to represent any blocked cells.\nA word can be placed horizontally (left to right or right to left) or vertically (top to bottom or bottom to top) in the board if:\n\tIt does not occupy a cell containing the character '#'.\n\tThe cell each letter is placed in must either be ' ' (empty) or match the letter already on the board.\n\tThere must not be any empty cells ' ' or other lowercase letters directly left or right of the word if the word was placed horizontally.\n\tThere must not be any empty cells ' ' or other lowercase letters directly above or below the word if the word was placed vertically.\nGiven a string word, return true if word can be placed in board, or false otherwise.\nExample 1:\nInput: board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \"c\", \" \"]], word = \"abc\"\nOutput: true\nExplanation: The word \"abc\" can be placed as shown above (top to bottom).\nExample 2:\nInput: board = [[\" \", \"#\", \"a\"], [\" \", \"#\", \"c\"], [\" \", \"#\", \"a\"]], word = \"ac\"\nOutput: false\nExplanation: It is impossible to place the word because there will always be a space/letter above or below it.\nExample 3:\nInput: board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \" \", \"c\"]], word = \"ca\"\nOutput: true\nExplanation: The word \"ca\" can be placed as shown above (right to left). \nConstraints:\n\tm == board.length\n\tn == board[i].length\n\t1 <= m * n <= 2 * 10^5\n\tboard[i][j] will be ' ', '#', or a lowercase English letter.\n\t1 <= word.length <= max(m, n)\n\tword will contain only lowercase English letters.",
        "topics": [
            "Array",
            "Matrix",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/check-if-word-can-be-placed-in-crossword/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {character[][]} board\r\n * @param {string} word\r\n * @return {boolean}\r\n */\r\nvar placeWordInCrossword = function(board, word) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean placeWordInCrossword(char[][] board, String word) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a positive integer n, indicating that we initially have an n x n\u00a00-indexed integer matrix mat filled with zeroes.\nYou are also given a 2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i], you should do the following operation:\n\tAdd 1 to every element in the submatrix with the top left corner (row1i, col1i) and the bottom right corner (row2i, col2i). That is, add 1 to mat[x][y] for all row1i <= x <= row2i and col1i <= y <= col2i.\nReturn the matrix mat after performing every query.\nExample 1:\nInput: n = 3, queries = [[1,1,2,2],[0,0,1,1]]\nOutput: [[1,1,0],[1,2,1],[0,1,1]]\nExplanation: The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.\n- In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).\n- In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).\nExample 2:\nInput: n = 2, queries = [[0,0,1,1]]\nOutput: [[1,1],[1,1]]\nExplanation: The diagram above shows the initial matrix and the matrix after the first query.\n- In the first query we add 1 to every element in the matrix.\nConstraints:\n\t1 <= n <= 500\n\t1 <= queries.length <= 10^4\n\t0 <= row1i <= row2i < n\n\t0 <= col1i <= col2i < n",
        "topics": [
            "Array",
            "Matrix",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/increment-submatrices-by-one/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} queries\r\n * @return {number[][]}\r\n */\r\nvar rangeAddQueries = function(n, queries) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[][] rangeAddQueries(int n, int[][] queries) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a 2D grid of 0s and 1s, return the number of elements in\u00a0the largest square\u00a0subgrid that has all 1s on its border, or 0 if such a subgrid\u00a0doesn't exist in the grid.\nExample 1:\nInput: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: 9\nExample 2:\nInput: grid = [[1,1,0,0]]\nOutput: 1\nConstraints:\n\t1 <= grid.length <= 100\n\t1 <= grid[0].length <= 100\n\tgrid[i][j] is 0 or 1",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/largest-1-bordered-square/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar largest1BorderedSquare = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int largest1BorderedSquare(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n].\nGo through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i].\nReturn the smallest index i at which either a row or a column will be completely painted in mat.\nExample 1:\nInput: arr = [1,3,4,2], mat = [[1,4],[2,3]]\nOutput: 2\nExplanation: The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].\nExample 2:\nInput: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]\nOutput: 3\nExplanation: The second column becomes fully painted at arr[3].\nConstraints:\n\tm == mat.length\n\tn = mat[i].length\n\tarr.length == m * n\n\t1 <= m, n <= 10^5\n\t1 <= m * n <= 10^5\n\t1 <= arr[i], mat[r][c] <= m * n\n\tAll the integers of arr are unique.\n\tAll the integers of mat are unique.",
        "topics": [
            "Array",
            "Hash Table",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/first-completely-painted-row-or-column/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} arr\r\n * @param {number[][]} mat\r\n * @return {number}\r\n */\r\nvar firstCompleteIndex = function(arr, mat) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an m x n integer matrix matrix with the following two properties:\n\tEach row is sorted in non-decreasing order.\n\tThe first integer of each row is greater than the last integer of the previous row.\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.\nExample 1:\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\nExample 2:\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\nConstraints:\n\tm == matrix.length\n\tn == matrix[i].length\n\t1 <= m, n <= 100\n\t-10^4 <= matrix[i][j], target <= 10^4",
        "topics": [
            "Array",
            "Binary Search",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/search-a-2d-matrix/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} matrix\r\n * @param {number} target\r\n * @return {boolean}\r\n */\r\nvar searchMatrix = function(matrix, target) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean searchMatrix(int[][] matrix, int target) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a 2D character matrix grid, where grid[i][j] is either 'X', 'Y', or '.', return the number of submatrices that contain:\n\tgrid[0][0]\n\tan equal frequency of 'X' and 'Y'.\n\tat least one 'X'.\nExample 1:\nInput: grid = [[\"X\",\"Y\",\".\"],[\"Y\",\".\",\".\"]]\nOutput: 3\nExplanation:\nExample 2:\nInput: grid = [[\"X\",\"X\"],[\"X\",\"Y\"]]\nOutput: 0\nExplanation:\nNo submatrix has an equal frequency of 'X' and 'Y'.\nExample 3:\nInput: grid = [[\".\",\".\"],[\".\",\".\"]]\nOutput: 0\nExplanation:\nNo submatrix has at least one 'X'.\nConstraints:\n\t1 <= grid.length, grid[i].length <= 1000\n\tgrid[i][j] is either 'X', 'Y', or '.'.",
        "topics": [
            "Array",
            "Matrix",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/count-submatrices-with-equal-frequency-of-x-and-y/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def numberOfSubmatrices(self, grid: List[List[str]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {character[][]} grid\r\n * @return {number}\r\n */\r\nvar numberOfSubmatrices = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numberOfSubmatrices(char[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an n x n grid\u00a0containing only values 0 and 1, where\u00a00 represents water\u00a0and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance.\u00a0If no land or water exists in the grid, return -1.\nThe distance used in this problem is the Manhattan distance:\u00a0the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|.\nExample 1:\nInput: grid = [[1,0,1],[0,0,0],[1,0,1]]\nOutput: 2\nExplanation: The cell (1, 1) is as far as possible from all the land with distance 2.\nExample 2:\nInput: grid = [[1,0,0],[0,0,0],[0,0,0]]\nOutput: 4\nExplanation: The cell (2, 2) is as far as possible from all the land with distance 4.\nConstraints:\n\tn == grid.length\n\tn == grid[i].length\n\t1 <= n\u00a0<= 100\n\tgrid[i][j]\u00a0is 0 or 1",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Breadth-First Search",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/as-far-from-land-as-possible/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maxDistance(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar maxDistance = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maxDistance(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given four integers row, cols, rCenter, and cCenter. There is a rows x cols matrix and you are on the cell with the coordinates (rCenter, cCenter).\nReturn the coordinates of all cells in the matrix, sorted by their distance from (rCenter, cCenter) from the smallest distance to the largest distance. You may return the answer in any order that satisfies this condition.\nThe distance between two cells (r1, c1) and (r2, c2) is |r1 - r2| + |c1 - c2|.\nExample 1:\nInput: rows = 1, cols = 2, rCenter = 0, cCenter = 0\nOutput: [[0,0],[0,1]]\nExplanation: The distances from (0, 0) to other cells are: [0,1]\nExample 2:\nInput: rows = 2, cols = 2, rCenter = 0, cCenter = 1\nOutput: [[0,1],[0,0],[1,1],[1,0]]\nExplanation: The distances from (0, 1) to other cells are: [0,1,1,2]\nThe answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.\nExample 3:\nInput: rows = 2, cols = 3, rCenter = 1, cCenter = 2\nOutput: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]\nExplanation: The distances from (1, 2) to other cells are: [0,1,1,2,2,3]\nThere are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].\nConstraints:\n\t1 <= rows, cols <= 100\n\t0 <= rCenter < rows\n\t0 <= cCenter < cols",
        "topics": [
            "Array",
            "Math",
            "Geometry",
            "Sorting",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/matrix-cells-in-distance-order/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> List[List[int]]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} rows\r\n * @param {number} cols\r\n * @param {number} rCenter\r\n * @param {number} cCenter\r\n * @return {number[][]}\r\n */\r\nvar allCellsDistOrder = function(rows, cols, rCenter, cCenter) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an 8 x 8 matrix representing a chessboard. There is exactly one white rook represented by 'R', some number of white bishops 'B', and some number of black pawns 'p'. Empty squares are represented by '.'.\nA rook can move any number of squares horizontally or vertically (up, down, left, right) until it reaches another piece or the edge of the board. A rook is attacking a pawn if it can move to the pawn's square in one move.\nNote: A rook cannot move through other pieces, such as bishops or pawns. This means a rook cannot attack a pawn if there is another piece blocking the path.\nReturn the number of pawns the white rook is attacking.\nExample 1:\nInput: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 3\nExplanation:\nIn this example, the rook is attacking all the pawns.\nExample 2:\nInput: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 0\nExplanation:\nThe bishops are blocking the rook from attacking any of the pawns.\nExample 3:\nInput: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 3\nExplanation:\nThe rook is attacking the pawns at positions b5, d6, and f5.\nConstraints:\n\tboard.length == 8\n\tboard[i].length == 8\n\tboard[i][j] is either 'R', '.', 'B', or 'p'\n\tThere is exactly one cell with board[i][j] == 'R'",
        "topics": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/available-captures-for-rook/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def numRookCaptures(self, board: List[List[str]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {character[][]} board\r\n * @return {number}\r\n */\r\nvar numRookCaptures = function(board) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numRookCaptures(char[][] board) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i\u200b\u200b\u200b\u200b\u200b^\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b customer has in the j\u200b\u200b\u200b\u200b\u200b^\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b bank. Return the wealth that the richest customer has.\nA customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.\nExample 1:\nInput: accounts = [[1,2,3],[3,2,1]]\nOutput: 6\nExplanation:\n1st customer has wealth = 1 + 2 + 3 = 6\n2nd customer has wealth = 3 + 2 + 1 = 6\nBoth customers are considered the richest with a wealth of 6 each, so return 6.\nExample 2:\nInput: accounts = [[1,5],[7,3],[3,5]]\nOutput: 10\nExplanation: \n1st customer has wealth = 6\n2nd customer has wealth = 10 \n3rd customer has wealth = 8\nThe 2nd customer is the richest with a wealth of 10.\nExample 3:\nInput: accounts = [[2,8,7],[7,1,3],[1,9,5]]\nOutput: 17\nConstraints:\n\tm ==\u00a0accounts.length\n\tn ==\u00a0accounts[i].length\n\t1 <= m, n <= 50\n\t1 <= accounts[i][j] <= 100",
        "topics": [
            "Array",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/richest-customer-wealth/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def maximumWealth(self, accounts: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} accounts\r\n * @return {number}\r\n */\r\nvar maximumWealth = function(accounts) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximumWealth(int[][] accounts) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an m x n grid grid where:\n\t'.' is an empty cell.\n\t'#' is a wall.\n\t'@' is the starting point.\n\tLowercase letters represent keys.\n\tUppercase letters represent locks.\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\nExample 1:\nInput: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.\nExample 2:\nInput: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6\nExample 3:\nInput: grid = [\"@Aa\"]\nOutput: -1\nConstraints:\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 30\n\tgrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\n\tThere is exactly one\u00a0'@'\u00a0in the grid.\n\tThe number of keys in the grid is in the range [1, 6].\n\tEach key in the grid is unique.\n\tEach key in the grid has a matching lock.",
        "topics": [
            "Array",
            "Bit Manipulation",
            "Breadth-First Search",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/shortest-path-to-get-all-keys/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string[]} grid\r\n * @return {number}\r\n */\r\nvar shortestPathAllKeys = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int shortestPathAllKeys(String[] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an m x n integers matrix, return the length of the longest increasing path in matrix.\nFrom each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\nExample 1:\nInput: matrix = [[9,9,4],[6,6,8],[2,1,1]]\nOutput: 4\nExplanation: The longest increasing path is [1, 2, 6, 9].\nExample 2:\nInput: matrix = [[3,4,5],[3,2,6],[2,2,1]]\nOutput: 4\nExplanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\nExample 3:\nInput: matrix = [[1]]\nOutput: 1\nConstraints:\n\tm == matrix.length\n\tn == matrix[i].length\n\t1 <= m, n <= 200\n\t0 <= matrix[i][j] <= 2^31 - 1",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort",
            "Memoization",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} matrix\r\n * @return {number}\r\n */\r\nvar longestIncreasingPath = function(matrix) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int longestIncreasingPath(int[][] matrix) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\t0 represents an empty cell,\n\t1 represents an obstacle that may be removed.\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).\nExample 1:\nInput: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.\nExample 2:\nInput: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.\nConstraints:\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 10^5\n\t2 <= m * n <= 10^5\n\tgrid[i][j] is either 0 or 1.\n\tgrid[0][0] == grid[m - 1][n - 1] == 0",
        "topics": [
            "Array",
            "Breadth-First Search",
            "Graph",
            "Heap (Priority Queue)",
            "Matrix",
            "Shortest Path"
        ],
        "url": "https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar minimumObstacles = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minimumObstacles(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the i^th row and colSum[j] is the sum of the elements of the j^th column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.\nFind any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.\nReturn a 2D array representing any matrix that fulfills the requirements. It's guaranteed that at least one matrix that fulfills the requirements exists.\nExample 1:\nInput: rowSum = [3,8], colSum = [4,7]\nOutput: [[3,0],\n         [1,7]]\nExplanation: \n0^th row: 3 + 0 = 3 == rowSum[0]\n1^st row: 1 + 7 = 8 == rowSum[1]\n0^th column: 3 + 1 = 4 == colSum[0]\n1^st column: 0 + 7 = 7 == colSum[1]\nThe row and column sums match, and all matrix elements are non-negative.\nAnother possible matrix is: [[1,2],\n                             [3,5]]\nExample 2:\nInput: rowSum = [5,7,10], colSum = [8,6,8]\nOutput: [[0,5,0],\n         [6,1,0],\n         [2,0,8]]\nConstraints:\n\t1 <= rowSum.length, colSum.length <= 500\n\t0 <= rowSum[i], colSum[i] <= 10^8\n\tsum(rowSum) == sum(colSum)",
        "topics": [
            "Array",
            "Greedy",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/find-valid-matrix-given-row-and-column-sums/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} rowSum\r\n * @param {number[]} colSum\r\n * @return {number[][]}\r\n */\r\nvar restoreMatrix = function(rowSum, colSum) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[][] restoreMatrix(int[] rowSum, int[] colSum) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an array of integers nums and an integer k, return the number of subarrays of nums where the bitwise AND of the elements of the subarray equals k.\nExample 1:\nInput: nums = [1,1,1], k = 1\nOutput: 6\nExplanation:\nAll subarrays contain only 1's.\nExample 2:\nInput: nums = [1,1,2], k = 1\nOutput: 3\nExplanation:\nSubarrays having an AND value of 1 are: [1,1,2], [1,1,2], [1,1,2].\nExample 3:\nInput: nums = [1,2,3], k = 2\nOutput: 2\nExplanation:\nSubarrays having an AND value of 2 are: [1,2,3], [1,2,3].\nConstraints:\n\t1 <= nums.length <= 10^5\n\t0 <= nums[i], k <= 10^9",
        "topics": [
            "Array",
            "Binary Search",
            "Bit Manipulation",
            "Segment Tree"
        ],
        "url": "https://leetcode.com/problems/number-of-subarrays-with-and-value-of-k/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def countSubarrays(self, nums: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar countSubarrays = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long countSubarrays(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array nums and an integer k.\nIn one operation, you can pick any index i of nums such that 0 <= i < nums.length - 1 and replace nums[i] and nums[i + 1] with a single occurrence of nums[i] & nums[i + 1], where & represents the bitwise AND operator.\nReturn the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations.\nExample 1:\nInput: nums = [3,5,3,2,7], k = 2\nOutput: 3\nExplanation: Let's do the following operations:\n1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums becomes equal to [1,3,2,7].\n2. Replace nums[2] and nums[3] with (nums[2] & nums[3]) so that nums becomes equal to [1,3,2].\nThe bitwise-or of the final array is 3.\nIt can be shown that 3 is the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations.\nExample 2:\nInput: nums = [7,3,15,14,2,8], k = 4\nOutput: 2\nExplanation: Let's do the following operations:\n1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums becomes equal to [3,15,14,2,8]. \n2. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums becomes equal to [3,14,2,8].\n3. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums becomes equal to [2,2,8].\n4. Replace nums[1] and nums[2] with (nums[1] & nums[2]) so that nums becomes equal to [2,0].\nThe bitwise-or of the final array is 2.\nIt can be shown that 2 is the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations.\nExample 3:\nInput: nums = [10,7,10,3,9,14,9,4], k = 1\nOutput: 15\nExplanation: Without applying any operations, the bitwise-or of nums is 15.\nIt can be shown that 15 is the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations.\nConstraints:\n\t1 <= nums.length <= 10^5\n\t0 <= nums[i] < 2^30\n\t0 <= k < nums.length",
        "topics": [
            "Array",
            "Greedy",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/minimize-or-of-remaining-elements-using-operations/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minOrAfterOperations(self, nums: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar minOrAfterOperations = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minOrAfterOperations(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed array nums consisting of non-negative powers of 2, and an integer target.\nIn one operation, you must apply the following changes to the array:\n\tChoose any element of the array nums[i] such that nums[i] > 1.\n\tRemove nums[i] from the array.\n\tAdd two occurrences of nums[i] / 2 to the end of nums.\nReturn the minimum number of operations you need to perform so that nums contains a subsequence whose elements sum to target. If it is impossible to obtain such a subsequence, return -1.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\nInput: nums = [1,2,8], target = 7\nOutput: 1\nExplanation: In the first operation, we choose element nums[2]. The array becomes equal to nums = [1,2,4,4].\nAt this stage, nums contains the subsequence [1,2,4] which sums up to 7.\nIt can be shown that there is no shorter sequence of operations that results in a subsequnce that sums up to 7.\nExample 2:\nInput: nums = [1,32,1,2], target = 12\nOutput: 2\nExplanation: In the first operation, we choose element nums[1]. The array becomes equal to nums = [1,1,2,16,16].\nIn the second operation, we choose element nums[3]. The array becomes equal to nums = [1,1,2,16,8,8]\nAt this stage, nums contains the subsequence [1,1,2,8] which sums up to 12.\nIt can be shown that there is no shorter sequence of operations that results in a subsequence that sums up to 12.\nExample 3:\nInput: nums = [1,32,1], target = 35\nOutput: -1\nExplanation: It can be shown that no sequence of operations results in a subsequence that sums up to 35.\nConstraints:\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 2^30\n\tnums consists only of non-negative powers of two.\n\t1 <= target < 2^31",
        "topics": [
            "Array",
            "Greedy",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/minimum-operations-to-form-subsequence-with-target-sum/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minOperations(self, nums: List[int], target: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar minOperations = function(nums, target) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minOperations(List<Integer> nums, int target) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.\n\tFor example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST.\nReturn the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.\nSince the answer may be very large, return it modulo 10^9 + 7.\nExample 1:\nInput: nums = [2,1,3]\nOutput: 1\nExplanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\nExample 2:\nInput: nums = [3,4,5,1,2]\nOutput: 5\nExplanation: The following 5 arrays will yield the same BST: \n[3,1,2,4,5]\n[3,1,4,2,5]\n[3,1,4,5,2]\n[3,4,1,2,5]\n[3,4,1,5,2]\nExample 3:\nInput: nums = [1,2,3]\nOutput: 0\nExplanation: There are no other orderings of nums that will yield the same BST.\nConstraints:\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= nums.length\n\tAll integers in nums are distinct.",
        "topics": [
            "Array",
            "Math",
            "Divide and Conquer",
            "Dynamic Programming",
            "Tree",
            "Union Find",
            "Binary Search Tree",
            "Memoization",
            "Combinatorics",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def numOfWays(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar numOfWays = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numOfWays(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree and an integer limit, delete all insufficient nodes in the tree simultaneously, and return the root of the resulting binary tree.\nA node is insufficient if every root to leaf path intersecting this node has a sum strictly less than limit.\nA leaf is a node with no children.\nExample 1:\nInput: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1\nOutput: [1,2,3,4,null,null,7,8,9,null,14]\nExample 2:\nInput: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22\nOutput: [5,4,8,11,null,17,4,7,null,null,null,5]\nExample 3:\nInput: root = [1,2,-3,-5,null,4,null], limit = -1\nOutput: [1,null,-3,4]\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 5000].\n\t-10^5 <= Node.val <= 10^5\n\t-10^9 <= limit <= 10^9",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sufficientSubset(self, root: Optional[TreeNode], limit: int) -> Optional[TreeNode]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} limit\r\n * @return {TreeNode}\r\n */\r\nvar sufficientSubset = function(root, limit) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sufficientSubset(TreeNode root, int limit) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, determine if it is a complete binary tree.\nIn a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes inclusive at the last level h.\nExample 1:\nInput: root = [1,2,3,4,5,6]\nOutput: true\nExplanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.\nExample 2:\nInput: root = [1,2,3,4,5,null,7]\nOutput: false\nExplanation: The node with value 7 isn't as far left as possible.\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 100].\n\t1 <= Node.val <= 1000",
        "topics": [
            "Tree",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/check-completeness-of-a-binary-tree/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {boolean}\r\n */\r\nvar isCompleteTree = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isCompleteTree(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.\nExample 1:\nInput: n = 3\nOutput: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\nExample 2:\nInput: n = 1\nOutput: [[1]]\nConstraints:\n\t1 <= n <= 8",
        "topics": [
            "Dynamic Programming",
            "Backtracking",
            "Tree",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {number} n\r\n * @return {TreeNode[]}\r\n */\r\nvar generateTrees = function(n) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<TreeNode> generateTrees(int n) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.\nA root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.\nExample 1:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: [[5,4,11,2],[5,8,4,5]]\nExplanation: There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\nExample 2:\nInput: root = [1,2,3], targetSum = 5\nOutput: []\nExample 3:\nInput: root = [1,2], targetSum = 0\nOutput: []\nConstraints:\n\tThe number of nodes in the tree is in the range [0, 5000].\n\t-1000 <= Node.val <= 1000\n\t-1000 <= targetSum <= 1000",
        "topics": [
            "Backtracking",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/path-sum-ii/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} targetSum\r\n * @return {number[][]}\r\n */\r\nvar pathSum = function(root, targetSum) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer n representing the number of nodes in a perfect binary tree consisting of nodes numbered from 1 to n. The root of the tree is node 1 and each node i in the tree has two children where the left child is the node 2 * i and the right child is 2 * i + 1.\nEach node in the tree also has a cost represented by a given 0-indexed integer array cost of size n where cost[i] is the cost of node i + 1. You are allowed to increment the cost of any node by 1 any number of times.\nReturn the minimum number of increments you need to make the cost of paths from the root to each leaf node equal.\nNote:\n\tA perfect binary tree is a tree where each node, except the leaf nodes, has exactly 2 children.\n\tThe cost of a path is the sum of costs of nodes in the path.\nExample 1:\nInput: n = 7, cost = [1,5,2,2,3,3,1]\nOutput: 6\nExplanation: We can do the following increments:\n- Increase the cost of node 4 one time.\n- Increase the cost of node 3 three times.\n- Increase the cost of node 7 two times.\nEach path from the root to a leaf will have a total cost of 9.\nThe total increments we did is 1 + 3 + 2 = 6.\nIt can be shown that this is the minimum answer we can achieve.\nExample 2:\nInput: n = 3, cost = [5,3,3]\nOutput: 0\nExplanation: The two paths already have equal total costs, so no increments are needed.\nConstraints:\n\t3 <= n <= 10^5\n\tn + 1 is a power of 2\n\tcost.length == n\n\t1 <= cost[i] <= 10^4",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Greedy",
            "Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minIncrements(self, n: int, cost: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[]} cost\r\n * @return {number}\r\n */\r\nvar minIncrements = function(n, cost) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minIncrements(int n, int[] cost) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[20,9],[15,7]]\nExample 2:\nInput: root = [1]\nOutput: [[1]]\nExample 3:\nInput: root = []\nOutput: []\nConstraints:\n\tThe number of nodes in the tree is in the range [0, 2000].\n\t-100 <= Node.val <= 100",
        "topics": [
            "Tree",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[][]}\r\n */\r\nvar zigzagLevelOrder = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root\u00a0of a binary tree, return all duplicate subtrees.\nFor each kind of duplicate subtrees, you only need to return the root node of any one of them.\nTwo trees are duplicate if they have the same structure with the same node values.\nExample 1:\nInput: root = [1,2,3,4,null,2,4,null,null,4]\nOutput: [[2,4],[4]]\nExample 2:\nInput: root = [2,1,1]\nOutput: [[1]]\nExample 3:\nInput: root = [2,2,2,3,null,3,null]\nOutput: [[2,3],[3]]\nConstraints:\n\tThe number of the nodes in the tree will be in the range [1, 5000]\n\t-200 <= Node.val <= 200",
        "topics": [
            "Hash Table",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/find-duplicate-subtrees/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {TreeNode[]}\r\n */\r\nvar findDuplicateSubtrees = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\tFor example, \"ab\" is lexicographically smaller than \"aba\".\nA leaf of a node is a node that has no children.\nExample 1:\nInput: root = [0,1,2,3,4,3,4]\nOutput: \"dba\"\nExample 2:\nInput: root = [25,1,3,1,3,0,2]\nOutput: \"adz\"\nExample 3:\nInput: root = [2,2,1,null,1,0,null,0]\nOutput: \"abc\"\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 8500].\n\t0 <= Node.val <= 25",
        "topics": [
            "String",
            "Backtracking",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/smallest-string-starting-from-leaf/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\nvar smallestFromLeaf = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public String smallestFromLeaf(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.\nExample 1:\nInput: n = 3\nOutput: 5\nExample 2:\nInput: n = 1\nOutput: 1\nConstraints:\n\t1 <= n <= 19",
        "topics": [
            "Math",
            "Dynamic Programming",
            "Tree",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/unique-binary-search-trees/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def numTrees(self, n: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar numTrees = function(n) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numTrees(int n) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree with unique values and the values of two different nodes of the tree x and y, return true if the nodes corresponding to the values x and y in the tree are cousins, or false otherwise.\nTwo nodes of a binary tree are cousins if they have the same depth with different parents.\nNote that in a binary tree, the root node is at the depth 0, and children of each depth k node are at the depth k + 1.\nExample 1:\nInput: root = [1,2,3,4], x = 4, y = 3\nOutput: false\nExample 2:\nInput: root = [1,2,3,null,4,null,5], x = 5, y = 4\nOutput: true\nExample 3:\nInput: root = [1,2,3,null,4], x = 2, y = 3\nOutput: false\nConstraints:\n\tThe number of nodes in the tree is in the range [2, 100].\n\t1 <= Node.val <= 100\n\tEach node has a unique value.\n\tx != y\n\tx and y are exist in the tree.",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/cousins-in-binary-tree/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nvar isCousins = function(root, x, y) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isCousins(TreeNode root, int x, int y) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\nExample 1:\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\nExample 2:\nInput: root = [1,2,2,null,3,null,3]\nOutput: false\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 1000].\n\t-100 <= Node.val <= 100\nFollow up: Could you solve it both recursively and iteratively?",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/symmetric-tree/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {boolean}\r\n */\r\nvar isSymmetric = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSymmetric(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.\nExample 1:\nInput: root = [4,2,6,1,3]\nOutput: 1\nExample 2:\nInput: root = [1,0,48,null,null,12,49]\nOutput: 1\nConstraints:\n\tThe number of nodes in the tree is in the range [2, 10^4].\n\t0 <= Node.val <= 10^5\nNote: This question is the same as 783: https://leetcode.com/problems/minimum-distance-between-bst-nodes/",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar getMinimumDifference = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int getMinimumDifference(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree.\nExample 1:\nInput: root = [4,2,6,1,3]\nOutput: 1\nExample 2:\nInput: root = [1,0,48,null,null,12,49]\nOutput: 1\nConstraints:\n\tThe number of nodes in the tree is in the range [2, 100].\n\t0 <= Node.val <= 10^5\nNote: This question is the same as 530: https://leetcode.com/problems/minimum-absolute-difference-in-bst/",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/minimum-distance-between-bst-nodes/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def minDiffInBST(self, root: Optional[TreeNode]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar minDiffInBST = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int minDiffInBST(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, return the sum of all left leaves.\nA leaf is a node with no children. A left leaf is a leaf that is the left child of another node.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 24\nExplanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.\nExample 2:\nInput: root = [1]\nOutput: 0\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 1000].\n\t-1000 <= Node.val <= 1000",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/sum-of-left-leaves/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar sumOfLeftLeaves = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int sumOfLeftLeaves(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer n denoting the number of cities in a country. The cities are numbered from 0 to n - 1.\nYou are also given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nYou need to assign each city with an integer value from 1 to n, where each value can only be used once. The importance of a road is then defined as the sum of the values of the two cities it connects.\nReturn the maximum total importance of all roads possible after assigning the values optimally.\nExample 1:\nInput: n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\nOutput: 43\nExplanation: The figure above shows the country and the assigned values of [2,4,5,3,1].\n- The road (0,1) has an importance of 2 + 4 = 6.\n- The road (1,2) has an importance of 4 + 5 = 9.\n- The road (2,3) has an importance of 5 + 3 = 8.\n- The road (0,2) has an importance of 2 + 5 = 7.\n- The road (1,3) has an importance of 4 + 3 = 7.\n- The road (2,4) has an importance of 5 + 1 = 6.\nThe total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43.\nIt can be shown that we cannot obtain a greater total importance than 43.\nExample 2:\nInput: n = 5, roads = [[0,3],[2,4],[1,3]]\nOutput: 20\nExplanation: The figure above shows the country and the assigned values of [4,3,2,5,1].\n- The road (0,3) has an importance of 4 + 5 = 9.\n- The road (2,4) has an importance of 2 + 1 = 3.\n- The road (1,3) has an importance of 3 + 5 = 8.\nThe total importance of all roads is 9 + 3 + 8 = 20.\nIt can be shown that we cannot obtain a greater total importance than 20.\nConstraints:\n\t2 <= n <= 5 * 10^4\n\t1 <= roads.length <= 5 * 10^4\n\troads[i].length == 2\n\t0 <= ai, bi <= n - 1\n\tai != bi\n\tThere are no duplicate roads.",
        "topics": [
            "Greedy",
            "Graph",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/maximum-total-importance-of-roads/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximumImportance(self, n: int, roads: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} roads\r\n * @return {number}\r\n */\r\nvar maximumImportance = function(n, roads) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long maximumImportance(int n, int[][] roads) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array.\nReturn the minimum size of the set so that at least half of the integers of the array are removed.\nExample 1:\nInput: arr = [3,3,3,3,5,5,5,2,2,7]\nOutput: 2\nExplanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array).\nPossible sets of size 2 are {3,5},{3,2},{5,2}.\nChoosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has a size greater than half of the size of the old array.\nExample 2:\nInput: arr = [7,7,7,7,7,7]\nOutput: 1\nExplanation: The only possible set you can choose is {7}. This will make the new array empty.\nConstraints:\n\t2 <= arr.length <= 10^5\n\tarr.length is even.\n\t1 <= arr[i] <= 10^5",
        "topics": [
            "Array",
            "Hash Table",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/reduce-array-size-to-the-half/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minSetSize(self, arr: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar minSetSize = function(arr) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minSetSize(int[] arr) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.\nFor every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j].\nReturn the k^th smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].\nExample 1:\nInput: arr = [1,2,3,5], k = 3\nOutput: [2,5]\nExplanation: The fractions to be considered in sorted order are:\n1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.\nThe third fraction is 2/5.\nExample 2:\nInput: arr = [1,7], k = 1\nOutput: [1,7]\nConstraints:\n\t2 <= arr.length <= 1000\n\t1 <= arr[i] <= 3 * 10^4\n\tarr[0] == 1\n\tarr[i] is a prime number for i > 0.\n\tAll the numbers of arr are unique and sorted in strictly increasing order.\n\t1 <= k <= arr.length * (arr.length - 1) / 2\nFollow up: Can you solve the problem with better than O(n^2) complexity?",
        "topics": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/k-th-smallest-prime-fraction/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} arr\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar kthSmallestPrimeFraction = function(arr, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are playing a solitaire game with three piles of stones of sizes a\u200b\u200b\u200b\u200b\u200b\u200b, b,\u200b\u200b\u200b\u200b\u200b\u200b and c\u200b\u200b\u200b\u200b\u200b\u200b respectively. Each turn you choose two different non-empty piles, take one stone from each, and add 1 point to your score. The game stops when there are fewer than two non-empty piles (meaning there are no more available moves).\nGiven three integers a\u200b\u200b\u200b\u200b\u200b, b,\u200b\u200b\u200b\u200b\u200b and c\u200b\u200b\u200b\u200b\u200b, return the maximum score you can get.\nExample 1:\nInput: a = 2, b = 4, c = 6\nOutput: 6\nExplanation: The starting state is (2, 4, 6). One optimal set of moves is:\n- Take from 1st and 3rd piles, state is now (1, 4, 5)\n- Take from 1st and 3rd piles, state is now (0, 4, 4)\n- Take from 2nd and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 6 points.\nExample 2:\nInput: a = 4, b = 4, c = 6\nOutput: 7\nExplanation: The starting state is (4, 4, 6). One optimal set of moves is:\n- Take from 1st and 2nd piles, state is now (3, 3, 6)\n- Take from 1st and 3rd piles, state is now (2, 3, 5)\n- Take from 1st and 3rd piles, state is now (1, 3, 4)\n- Take from 1st and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 7 points.\nExample 3:\nInput: a = 1, b = 8, c = 8\nOutput: 8\nExplanation: One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.\nAfter that, there are fewer than two non-empty piles, so the game ends.\nConstraints:\n\t1 <= a, b, c <= 10^5",
        "topics": [
            "Math",
            "Greedy",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/maximum-score-from-removing-stones/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximumScore(self, a: int, b: int, c: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} a\r\n * @param {number} b\r\n * @param {number} c\r\n * @return {number}\r\n */\r\nvar maximumScore = function(a, b, c) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximumScore(int a, int b, int c) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an integer array nums and an integer k, return the k^th largest element in the array.\nNote that it is the k^th largest element in the sorted order, not the k^th distinct element.\nCan you solve it without sorting?\nExample 1:\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\nExample 2:\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4\nConstraints:\n\t1 <= k <= nums.length <= 10^5\n\t-10^4 <= nums[i] <= 10^4",
        "topics": [
            "Array",
            "Divide and Conquer",
            "Sorting",
            "Heap (Priority Queue)",
            "Quickselect"
        ],
        "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def findKthLargest(self, nums: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar findKthLargest = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int findKthLargest(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\tDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\n\tAdd the maximum of deleted elements to the answer.\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.\nExample 1:\nInput: grid = [[1,2,4],[3,3,1]]\nOutput: 8\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.\nExample 2:\nInput: grid = [[10]]\nOutput: 10\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10.\nConstraints:\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 50\n\t1 <= grid[i][j] <= 100",
        "topics": [
            "Array",
            "Sorting",
            "Heap (Priority Queue)",
            "Matrix",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/delete-greatest-value-in-each-row/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar deleteGreatestValue = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int deleteGreatestValue(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row.\nA row i is weaker than a row j if one of the following is true:\n\tThe number of soldiers in row i is less than the number of soldiers in row j.\n\tBoth rows have the same number of soldiers and i < j.\nReturn the indices of the k weakest rows in the matrix ordered from weakest to strongest.\nExample 1:\nInput: mat = \n[[1,1,0,0,0],\n [1,1,1,1,0],\n [1,0,0,0,0],\n [1,1,0,0,0],\n [1,1,1,1,1]], \nk = 3\nOutput: [2,0,3]\nExplanation: \nThe number of soldiers in each row is: \n- Row 0: 2 \n- Row 1: 4 \n- Row 2: 1 \n- Row 3: 2 \n- Row 4: 5 \nThe rows ordered from weakest to strongest are [2,0,3,1,4].\nExample 2:\nInput: mat = \n[[1,0,0,0],\n [1,1,1,1],\n [1,0,0,0],\n [1,0,0,0]], \nk = 2\nOutput: [0,2]\nExplanation: \nThe number of soldiers in each row is: \n- Row 0: 1 \n- Row 1: 4 \n- Row 2: 1 \n- Row 3: 1 \nThe rows ordered from weakest to strongest are [0,2,3,1].\nConstraints:\n\tm == mat.length\n\tn == mat[i].length\n\t2 <= n, m <= 100\n\t1 <= k <= m\n\tmatrix[i][j] is either 0 or 1.",
        "topics": [
            "Array",
            "Binary Search",
            "Sorting",
            "Heap (Priority Queue)",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} mat\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar kWeakestRows = function(mat, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] kWeakestRows(int[][] mat, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer array score of size n, where score[i] is the score of the i^th athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1^st place athlete has the highest score, the 2^nd place athlete has the 2^nd highest score, and so on. The placement of each athlete determines their rank:\n\tThe 1^st place athlete's rank is \"Gold Medal\".\n\tThe 2^nd place athlete's rank is \"Silver Medal\".\n\tThe 3^rd place athlete's rank is \"Bronze Medal\".\n\tFor the 4^th place to the n^th place athlete, their rank is their placement number (i.e., the x^th place athlete's rank is \"x\").\nReturn an array answer of size n where answer[i] is the rank of the i^th athlete.\nExample 1:\nInput: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1^st, 2^nd, 3^rd, 4^th, 5^th].\nExample 2:\nInput: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1^st, 5^th, 3^rd, 2^nd, 4^th].\nConstraints:\n\tn == score.length\n\t1 <= n <= 10^4\n\t0 <= score[i] <= 10^6\n\tAll the values in score are unique.",
        "topics": [
            "Array",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/relative-ranks/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def findRelativeRanks(self, score: List[int]) -> List[str]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} score\r\n * @return {string[]}\r\n */\r\nvar findRelativeRanks = function(score) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String[] findRelativeRanks(int[] score) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer array gifts denoting the number of gifts in various piles. Every second, you do the following:\n\tChoose the pile with the maximum number of gifts.\n\tIf there is more than one pile with the maximum number of gifts, choose any.\n\tLeave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.\nReturn the number of gifts remaining after k seconds.\nExample 1:\nInput: gifts = [25,64,9,4,100], k = 4\nOutput: 29\nExplanation: \nThe gifts are taken in the following way:\n- In the first second, the last pile is chosen and 10 gifts are left behind.\n- Then the second pile is chosen and 8 gifts are left behind.\n- After that the first pile is chosen and 5 gifts are left behind.\n- Finally, the last pile is chosen again and 3 gifts are left behind.\nThe final remaining gifts are [5,8,9,4,3], so the total number of gifts remaining is 29.\nExample 2:\nInput: gifts = [1,1,1,1], k = 4\nOutput: 4\nExplanation: \nIn this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. \nThat is, you can't take any pile with you. \nSo, the total gifts remaining are 4.\nConstraints:\n\t1 <= gifts.length <= 10^3\n\t1 <= gifts[i] <= 10^9\n\t1 <= k <= 10^3",
        "topics": [
            "Array",
            "Heap (Priority Queue)",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/take-gifts-from-the-richest-pile/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def pickGifts(self, gifts: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} gifts\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar pickGifts = function(gifts, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long pickGifts(int[] gifts, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed m * n integer matrix values, representing the values of m * n different items in m different shops. Each shop has n items where the j^th item in the i^th shop has a value of values[i][j]. Additionally, the items in the i^th shop are sorted in non-increasing order of value. That is, values[i][j] >= values[i][j + 1] for all 0 <= j < n - 1.\nOn each day, you would like to buy a single item from one of the shops. Specifically, On the d^th day you can:\n\tPick any shop i.\n\tBuy the rightmost available item j for the price of values[i][j] * d. That is, find the greatest index j such that item j was never bought before, and buy it for the price of values[i][j] * d.\nNote that all items are pairwise different. For example, if you have bought item 0 from shop 1, you can still buy item 0 from any other shop.\nReturn the maximum amount of money that can be spent on buying all  m * n products.\nExample 1:\nInput: values = [[8,5,2],[6,4,1],[9,7,3]]\nOutput: 285\nExplanation: On the first day, we buy product 2 from shop 1 for a price of values[1][2] * 1 = 1.\nOn the second day, we buy product 2 from shop 0 for a price of values[0][2] * 2 = 4.\nOn the third day, we buy product 2 from shop 2 for a price of values[2][2] * 3 = 9.\nOn the fourth day, we buy product 1 from shop 1 for a price of values[1][1] * 4 = 16.\nOn the fifth day, we buy product 1 from shop 0 for a price of values[0][1] * 5 = 25.\nOn the sixth day, we buy product 0 from shop 1 for a price of values[1][0] * 6 = 36.\nOn the seventh day, we buy product 1 from shop 2 for a price of values[2][1] * 7 = 49.\nOn the eighth day, we buy product 0 from shop 0 for a price of values[0][0] * 8 = 64.\nOn the ninth day, we buy product 0 from shop 2 for a price of values[2][0] * 9 = 81.\nHence, our total spending is equal to 285.\nIt can be shown that 285 is the maximum amount of money that can be spent buying all m * n products. \nExample 2:\nInput: values = [[10,8,6,4,2],[9,7,5,3,2]]\nOutput: 386\nExplanation: On the first day, we buy product 4 from shop 0 for a price of values[0][4] * 1 = 2.\nOn the second day, we buy product 4 from shop 1 for a price of values[1][4] * 2 = 4.\nOn the third day, we buy product 3 from shop 1 for a price of values[1][3] * 3 = 9.\nOn the fourth day, we buy product 3 from shop 0 for a price of values[0][3] * 4 = 16.\nOn the fifth day, we buy product 2 from shop 1 for a price of values[1][2] * 5 = 25.\nOn the sixth day, we buy product 2 from shop 0 for a price of values[0][2] * 6 = 36.\nOn the seventh day, we buy product 1 from shop 1 for a price of values[1][1] * 7 = 49.\nOn the eighth day, we buy product 1 from shop 0 for a price of values[0][1] * 8 = 64\nOn the ninth day, we buy product 0 from shop 1 for a price of values[1][0] * 9 = 81.\nOn the tenth day, we buy product 0 from shop 0 for a price of values[0][0] * 10 = 100.\nHence, our total spending is equal to 386.\nIt can be shown that 386 is the maximum amount of money that can be spent buying all m * n products.\nConstraints:\n\t1 <= m == values.length <= 10\n\t1 <= n == values[i].length <= 10^4\n\t1 <= values[i][j] <= 10^6\n\tvalues[i] are sorted in non-increasing order.",
        "topics": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/maximum-spending-after-buying-items/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def maxSpending(self, values: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} values\r\n * @return {number}\r\n */\r\nvar maxSpending = function(values) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long maxSpending(int[][] values) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n\t1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n\t2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n\t3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n\t4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\nNotice that there could be some signs on the cells of the grid that point outside the grid.\nYou will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\nYou can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\nReturn the minimum cost to make the grid have at least one valid path.\nExample 1:\nInput: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\nOutput: 3\nExplanation: You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.\nExample 2:\nInput: grid = [[1,1,3],[3,2,2],[1,1,4]]\nOutput: 0\nExplanation: You can follow the path from (0, 0) to (2, 2).\nExample 3:\nInput: grid = [[1,2],[4,3]]\nOutput: 1\nConstraints:\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 100\n\t1 <= grid[i][j] <= 4",
        "topics": [
            "Array",
            "Breadth-First Search",
            "Graph",
            "Heap (Priority Queue)",
            "Matrix",
            "Shortest Path"
        ],
        "url": "https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minCost(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar minCost = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minCost(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an m x n matrix mat that has its rows sorted in non-decreasing order and an integer k.\nYou are allowed to choose exactly one element from each row to form an array.\nReturn the k^th smallest array sum among all possible arrays.\nExample 1:\nInput: mat = [[1,3,11],[2,4,6]], k = 5\nOutput: 7\nExplanation: Choosing one element from each row, the first k smallest sum are:\n[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.\nExample 2:\nInput: mat = [[1,3,11],[2,4,6]], k = 9\nOutput: 17\nExample 3:\nInput: mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7\nOutput: 9\nExplanation: Choosing one element from each row, the first k smallest sum are:\n[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  \nConstraints:\n\tm == mat.length\n\tn == mat.length[i]\n\t1 <= m, n <= 40\n\t1 <= mat[i][j] <= 5000\n\t1 <= k <= min(200, n^m)\n\tmat[i] is a non-decreasing array.",
        "topics": [
            "Array",
            "Binary Search",
            "Heap (Priority Queue)",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} mat\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar kthSmallest = function(mat, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int kthSmallest(int[][] mat, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the i^th city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\tNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.\nExample 1:\nInput: stations = [1,2,4,5,0], r = 1, k = 2\nOutput: 5\nExplanation: \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become [1,4,4,5,0].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.\nExample 2:\nInput: stations = [4,4,4,4], r = 0, k = 3\nOutput: 4\nExplanation: \nIt can be proved that we cannot make the minimum power of a city greater than 4.\nConstraints:\n\tn == stations.length\n\t1 <= n <= 10^5\n\t0 <= stations[i] <= 10^5\n\t0 <= r\u00a0<= n - 1\n\t0 <= k\u00a0<= 10^9",
        "topics": [
            "Array",
            "Binary Search",
            "Greedy",
            "Queue",
            "Sliding Window",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/maximize-the-minimum-powered-city/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} stations\r\n * @param {number} r\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar maxPower = function(stations, r, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long maxPower(int[] stations, int r, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a 0-indexed integer array nums of size n containing all numbers from 1 to n, return the number of increasing quadruplets.\nA quadruplet (i, j, k, l) is increasing if:\n\t0 <= i < j < k < l < n, and\n\tnums[i] < nums[k] < nums[j] < nums[l].\nExample 1:\nInput: nums = [1,3,2,4,5]\nOutput: 2\nExplanation: \n- When i = 0, j = 1, k = 2, and l = 3, nums[i] < nums[k] < nums[j] < nums[l].\n- When i = 0, j = 1, k = 2, and l = 4, nums[i] < nums[k] < nums[j] < nums[l]. \nThere are no other quadruplets, so we return 2.\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: 0\nExplanation: There exists only one quadruplet with i = 0, j = 1, k = 2, l = 3, but since nums[j] < nums[k], we return 0.\nConstraints:\n\t4 <= nums.length <= 4000\n\t1 <= nums[i] <= nums.length\n\tAll the integers of nums are unique. nums is a permutation.",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Binary Indexed Tree",
            "Enumeration",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/count-increasing-quadruplets/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def countQuadruplets(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar countQuadruplets = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long countQuadruplets(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array nums of length n. The number of ways to partition nums is the number of pivot indices that satisfy both conditions:\n\t1 <= pivot < n\n\tnums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]\nYou are also given an integer k. You can choose to change the value of one element of nums to k, or to leave the array unchanged.\nReturn the maximum possible number of ways to partition nums to satisfy both conditions after changing at most one element.\nExample 1:\nInput: nums = [2,-1,2], k = 3\nOutput: 1\nExplanation: One optimal approach is to change nums[0] to k. The array becomes [3,-1,2].\nThere is one way to partition the array:\n- For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.\nExample 2:\nInput: nums = [0,0,0], k = 1\nOutput: 2\nExplanation: The optimal approach is to leave the array unchanged.\nThere are two ways to partition the array:\n- For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.\n- For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.\nExample 3:\nInput: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\nOutput: 4\nExplanation: One optimal approach is to change nums[2] to k. The array becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14].\nThere are four ways to partition the array.\nConstraints:\n\tn == nums.length\n\t2 <= n <= 10^5\n\t-10^5 <= k, nums[i] <= 10^5",
        "topics": [
            "Array",
            "Hash Table",
            "Counting",
            "Enumeration",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def waysToPartition(self, nums: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar waysToPartition = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int waysToPartition(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You have n robots. You are given two 0-indexed integer arrays, chargeTimes and runningCosts, both of length n. The i^th robot costs chargeTimes[i] units to charge and costs runningCosts[i] units to run. You are also given an integer budget.\nThe total cost of running k chosen robots is equal to max(chargeTimes) + k * sum(runningCosts), where max(chargeTimes) is the largest charge cost among the k robots and sum(runningCosts) is the sum of running costs among the k robots.\nReturn the maximum number of consecutive robots you can run such that the total cost does not exceed budget.\nExample 1:\nInput: chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25\nOutput: 3\nExplanation: \nIt is possible to run all individual and consecutive pairs of robots within budget.\nTo obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 which is less than 25.\nIt can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3.\nExample 2:\nInput: chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19\nOutput: 0\nExplanation: No robot can be run that does not exceed the budget, so we return 0.\nConstraints:\n\tchargeTimes.length == runningCosts.length == n\n\t1 <= n <= 5 * 10^4\n\t1 <= chargeTimes[i], runningCosts[i] <= 10^5\n\t1 <= budget <= 10^15",
        "topics": [
            "Array",
            "Binary Search",
            "Queue",
            "Sliding Window",
            "Heap (Priority Queue)",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/maximum-number-of-robots-within-budget/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} chargeTimes\r\n * @param {number[]} runningCosts\r\n * @param {number} budget\r\n * @return {number}\r\n */\r\nvar maximumRobots = function(chargeTimes, runningCosts, budget) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 2D integer array tiles where tiles[i] = [li, ri] represents that every tile j in the range li <= j <= ri is colored white.\nYou are also given an integer carpetLen, the length of a single carpet that can be placed anywhere.\nReturn the maximum number of white tiles that can be covered by the carpet.\nExample 1:\nInput: tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10\nOutput: 9\nExplanation: Place the carpet starting on tile 10. \nIt covers 9 white tiles, so we return 9.\nNote that there may be other places where the carpet covers 9 white tiles.\nIt can be shown that the carpet cannot cover more than 9 white tiles.\nExample 2:\nInput: tiles = [[10,11],[1,1]], carpetLen = 2\nOutput: 2\nExplanation: Place the carpet starting on tile 10. \nIt covers 2 white tiles, so we return 2.\nConstraints:\n\t1 <= tiles.length <= 5 * 10^4\n\ttiles[i].length == 2\n\t1 <= li <= ri <= 10^9\n\t1 <= carpetLen <= 10^9\n\tThe tiles are non-overlapping.",
        "topics": [
            "Array",
            "Binary Search",
            "Greedy",
            "Sorting",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} tiles\r\n * @param {number} carpetLen\r\n * @return {number}\r\n */\r\nvar maximumWhiteTiles = function(tiles, carpetLen) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the\u00a0i^th\u00a0type you have. You are also given a 2D array queries where queries[i] = [favoriteTypei, favoriteDayi, dailyCapi].\nYou play a game with the following rules:\n\tYou start eating candies on day 0.\n\tYou cannot eat any candy of type i unless you have eaten all candies of type i - 1.\n\tYou must eat at least one candy per day until you have eaten all the candies.\nConstruct a boolean array answer such that answer.length == queries.length and answer[i] is true if you can eat a candy of type favoriteTypei on day favoriteDayi without eating more than dailyCapi candies on any day, and false otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2.\nReturn the constructed array answer.\nExample 1:\nInput: candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\nOutput: [true,false,true]\nExplanation:\n1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2.\n2- You can eat at most 4 candies each day.\n   If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1.\n   On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2.\n3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13.\nExample 2:\nInput: candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\nOutput: [false,true,true,false,false]\nConstraints:\n\t1 <= candiesCount.length <= 10^5\n\t1 <= candiesCount[i] <= 10^5\n\t1 <= queries.length <= 10^5\n\tqueries[i].length == 3\n\t0 <= favoriteTypei < candiesCount.length\n\t0 <= favoriteDayi <= 10^9\n\t1 <= dailyCapi <= 10^9",
        "topics": [
            "Array",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} candiesCount\r\n * @param {number[][]} queries\r\n * @return {boolean[]}\r\n */\r\nvar canEat = function(candiesCount, queries) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean[] canEat(int[] candiesCount, int[][] queries) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed string text and another 0-indexed string pattern of length 2, both of which consist of only lowercase English letters.\nYou can add either pattern[0] or pattern[1] anywhere in text exactly once. Note that the character can be added even at the beginning or at the end of text.\nReturn the maximum number of times pattern can occur as a subsequence of the modified text.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nExample 1:\nInput: text = \"abdcdbc\", pattern = \"ac\"\nOutput: 4\nExplanation:\nIf we add pattern[0] = 'a' in between text[1] and text[2], we get \"abadcdbc\". Now, the number of times \"ac\" occurs as a subsequence is 4.\nSome other strings which have 4 subsequences \"ac\" after adding a character to text are \"aabdcdbc\" and \"abdacdbc\".\nHowever, strings such as \"abdcadbc\", \"abdccdbc\", and \"abdcdbcc\", although obtainable, have only 3 subsequences \"ac\" and are thus suboptimal.\nIt can be shown that it is not possible to get more than 4 subsequences \"ac\" by adding only one character.\nExample 2:\nInput: text = \"aabb\", pattern = \"ab\"\nOutput: 6\nExplanation:\nSome of the strings which can be obtained from text and have 6 subsequences \"ab\" are \"aaabb\", \"aaabb\", and \"aabbb\".\nConstraints:\n\t1 <= text.length <= 10^5\n\tpattern.length == 2\n\ttext and pattern consist only of lowercase English letters.",
        "topics": [
            "String",
            "Greedy",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} text\r\n * @param {string} pattern\r\n * @return {number}\r\n */\r\nvar maximumSubsequenceCount = function(text, pattern) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long maximumSubsequenceCount(String text, String pattern) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an array nums consisting of positive integers.\nYou are also given an integer array queries of size m. For the i^th query, you want to make all of the elements of nums equal to queries[i]. You can perform the following operation on the array any number of times:\n\tIncrease or decrease an element of the array by 1.\nReturn an array answer of size m where answer[i] is the minimum number of operations to make all elements of nums equal to queries[i].\nNote that after each query the array is reset to its original state.\nExample 1:\nInput: nums = [3,1,6,8], queries = [1,5]\nOutput: [14,10]\nExplanation: For the first query we can do the following operations:\n- Decrease nums[0] 2 times, so that nums = [1,1,6,8].\n- Decrease nums[2] 5 times, so that nums = [1,1,1,8].\n- Decrease nums[3] 7 times, so that nums = [1,1,1,1].\nSo the total number of operations for the first query is 2 + 5 + 7 = 14.\nFor the second query we can do the following operations:\n- Increase nums[0] 2 times, so that nums = [5,1,6,8].\n- Increase nums[1] 4 times, so that nums = [5,5,6,8].\n- Decrease nums[2] 1 time, so that nums = [5,5,5,8].\n- Decrease nums[3] 3 times, so that nums = [5,5,5,5].\nSo the total number of operations for the second query is 2 + 4 + 1 + 3 = 10.\nExample 2:\nInput: nums = [2,9,6,3], queries = [10]\nOutput: [20]\nExplanation: We can increase each value in the array to 10. The total number of operations will be 8 + 1 + 4 + 7 = 20.\nConstraints:\n\tn == nums.length\n\tm == queries.length\n\t1 <= n, m <= 10^5\n\t1 <= nums[i], queries[i] <= 10^9",
        "topics": [
            "Array",
            "Binary Search",
            "Sorting",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/minimum-operations-to-make-all-array-elements-equal/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number[]} queries\r\n * @return {number[]}\r\n */\r\nvar minOperations = function(nums, queries) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<Long> minOperations(int[] nums, int[] queries) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 2D integer array grid of size m x n, where each cell contains a positive integer.\nA cornered path is defined as a set of adjacent cells with at most one turn. More specifically, the path should exclusively move either horizontally or vertically up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the alternate direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.\nThe product of a path is defined as the product of all the values in the path.\nReturn the maximum number of trailing zeros in the product of a cornered path found in grid.\nNote:\n\tHorizontal movement means moving in either the left or right direction.\n\tVertical movement means moving in either the up or down direction.\nExample 1:\nInput: grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\nOutput: 3\nExplanation: The grid on the left shows a valid cornered path.\nIt has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.\nIt can be shown that this is the maximum trailing zeros in the product of a cornered path.\nThe grid in the middle is not a cornered path as it has more than one turn.\nThe grid on the right is not a cornered path as it requires a return to a previously visited cell.\nExample 2:\nInput: grid = [[4,3,2],[7,6,1],[8,8,8]]\nOutput: 0\nExplanation: The grid is shown in the figure above.\nThere are no cornered paths in the grid that result in a product with a trailing zero.\nConstraints:\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 10^5\n\t1 <= m * n <= 10^5\n\t1 <= grid[i][j] <= 1000",
        "topics": [
            "Array",
            "Matrix",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar maxTrailingZeros = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maxTrailingZeros(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given two strings a and b that consist of lowercase letters. In one operation, you can change any character in a or b to any lowercase letter.\nYour goal is to satisfy one of the following three conditions:\n\tEvery letter in a is strictly less than every letter in b in the alphabet.\n\tEvery letter in b is strictly less than every letter in a in the alphabet.\n\tBoth a and b consist of only one distinct letter.\nReturn the minimum number of operations needed to achieve your goal.\nExample 1:\nInput: a = \"aba\", b = \"caa\"\nOutput: 2\nExplanation: Consider the best way to make each condition true:\n1) Change b to \"ccc\" in 2 operations, then every letter in a is less than every letter in b.\n2) Change a to \"bbb\" and b to \"aaa\" in 3 operations, then every letter in b is less than every letter in a.\n3) Change a to \"aaa\" and b to \"aaa\" in 2 operations, then a and b consist of one distinct letter.\nThe best way was done in 2 operations (either condition 1 or condition 3).\nExample 2:\nInput: a = \"dabadd\", b = \"cda\"\nOutput: 3\nExplanation: The best way is to make condition 1 true by changing b to \"eee\".\nConstraints:\n\t1 <= a.length, b.length <= 10^5\n\ta and b consist only of lowercase letters.",
        "topics": [
            "Hash Table",
            "String",
            "Counting",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} a\r\n * @param {string} b\r\n * @return {number}\r\n */\r\nvar minCharacters = function(a, b) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minCharacters(String a, String b) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a string s of lowercase English letters and a 2D integer array shifts where shifts[i] = [starti, endi, directioni]. For every i, shift the characters in s from the index starti to the index endi (inclusive) forward if directioni = 1, or shift the characters backward if directioni = 0.\nShifting a character forward means replacing it with the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Similarly, shifting a character backward means replacing it with the previous letter in the alphabet (wrapping around so that 'a' becomes 'z').\nReturn the final string after all such shifts to s are applied.\nExample 1:\nInput: s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\nOutput: \"ace\"\nExplanation: Firstly, shift the characters from index 0 to index 1 backward. Now s = \"zac\".\nSecondly, shift the characters from index 1 to index 2 forward. Now s = \"zbd\".\nFinally, shift the characters from index 0 to index 2 forward. Now s = \"ace\".\nExample 2:\nInput: s = \"dztz\", shifts = [[0,0,0],[1,1,1]]\nOutput: \"catz\"\nExplanation: Firstly, shift the characters from index 0 to index 0 backward. Now s = \"cztz\".\nFinally, shift the characters from index 1 to index 1 forward. Now s = \"catz\".\nConstraints:\n\t1 <= s.length, shifts.length <= 5 * 10^4\n\tshifts[i].length == 3\n\t0 <= starti <= endi < s.length\n\t0 <= directioni <= 1\n\ts consists of lowercase English letters.",
        "topics": [
            "Array",
            "String",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/shifting-letters-ii/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @param {number[][]} shifts\r\n * @return {string}\r\n */\r\nvar shiftingLetters = function(s, shifts) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String shiftingLetters(String s, int[][] shifts) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "We have an array of integers, nums, and an array of requests where requests[i] = [starti, endi]. The i^th request asks for the sum of nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]. Both starti and endi are 0-indexed.\nReturn the maximum total sum of all requests among all permutations of nums.\nSince the answer may be too large, return it modulo 10^9 + 7.\nExample 1:\nInput: nums = [1,2,3,4,5], requests = [[1,3],[0,1]]\nOutput: 19\nExplanation: One permutation of nums is [2,1,3,4,5] with the following result: \nrequests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8\nrequests[1] -> nums[0] + nums[1] = 2 + 1 = 3\nTotal sum: 8 + 3 = 11.\nA permutation with a higher total sum is [3,5,4,2,1] with the following result:\nrequests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11\nrequests[1] -> nums[0] + nums[1] = 3 + 5  = 8\nTotal sum: 11 + 8 = 19, which is the best that you can do.\nExample 2:\nInput: nums = [1,2,3,4,5,6], requests = [[0,1]]\nOutput: 11\nExplanation: A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11].\nExample 3:\nInput: nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]\nOutput: 47\nExplanation: A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10].\nConstraints:\n\tn == nums.length\n\t1 <= n <= 10^5\n\t0 <= nums[i]\u00a0<= 10^5\n\t1 <= requests.length <=\u00a010^5\n\trequests[i].length == 2\n\t0 <= starti\u00a0<= endi\u00a0<\u00a0n",
        "topics": [
            "Array",
            "Greedy",
            "Sorting",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/maximum-sum-obtained-of-any-permutation/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number[][]} requests\r\n * @return {number}\r\n */\r\nvar maxSumRangeQuery = function(nums, requests) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "The min-product of an array is equal to the minimum value in the array multiplied by the array's sum.\n\tFor example, the array [3,2,5] (minimum value is 2) has a min-product of 2 * (3+2+5) = 2 * 10 = 20.\nGiven an array of integers nums, return the maximum min-product of any non-empty subarray of nums. Since the answer may be large, return it modulo 10^9 + 7.\nNote that the min-product should be maximized before performing the modulo operation. Testcases are generated such that the maximum min-product without modulo will fit in a 64-bit signed integer.\nA subarray is a contiguous part of an array.\nExample 1:\nInput: nums = [1,2,3,2]\nOutput: 14\nExplanation: The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).\n2 * (2+3+2) = 2 * 7 = 14.\nExample 2:\nInput: nums = [2,3,3,1,2]\nOutput: 18\nExplanation: The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).\n3 * (3+3) = 3 * 6 = 18.\nExample 3:\nInput: nums = [3,1,5,6,4,2]\nOutput: 60\nExplanation: The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).\n4 * (5+6+4) = 4 * 15 = 60.\nConstraints:\n\t1 <= nums.length <= 10^5\n\t1 <= nums[i] <= 10^7",
        "topics": [
            "Array",
            "Stack",
            "Monotonic Stack",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/maximum-subarray-min-product/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maxSumMinProduct(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maxSumMinProduct = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maxSumMinProduct(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers of a hidden sequence of length (n + 1). More formally, call the hidden sequence hidden, then we have that differences[i] = hidden[i + 1] - hidden[i].\nYou are further given two integers lower and upper that describe the inclusive range of values [lower, upper] that the hidden sequence can contain.\n\tFor example, given differences = [1, -3, 4], lower = 1, upper = 6, the hidden sequence is a sequence of length 4 whose elements are in between 1 and 6 (inclusive).\n\t\t[3, 4, 1, 5] and [4, 5, 2, 6] are possible hidden sequences.\n\t\t[5, 6, 3, 7] is not possible since it contains an element greater than 6.\n\t\t[1, 2, 3, 4] is not possible since the differences are not correct.\nReturn the number of possible hidden sequences there are. If there are no possible sequences, return 0.\nExample 1:\nInput: differences = [1,-3,4], lower = 1, upper = 6\nOutput: 2\nExplanation: The possible hidden sequences are:\n- [3, 4, 1, 5]\n- [4, 5, 2, 6]\nThus, we return 2.\nExample 2:\nInput: differences = [3,-4,5,1,-2], lower = -4, upper = 5\nOutput: 4\nExplanation: The possible hidden sequences are:\n- [-3, 0, -4, 1, 2, 0]\n- [-2, 1, -3, 2, 3, 1]\n- [-1, 2, -2, 3, 4, 2]\n- [0, 3, -1, 4, 5, 3]\nThus, we return 4.\nExample 3:\nInput: differences = [4,-7,2], lower = 3, upper = 6\nOutput: 0\nExplanation: There are no possible hidden sequences. Thus, we return 0.\nConstraints:\n\tn == differences.length\n\t1 <= n <= 10^5\n\t-10^5 <= differences[i] <= 10^5\n\t-10^5 <= lower <= upper <= 10^5",
        "topics": [
            "Array",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/count-the-hidden-sequences/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} differences\r\n * @param {number} lower\r\n * @param {number} upper\r\n * @return {number}\r\n */\r\nvar numberOfArrays = function(differences, lower, upper) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numberOfArrays(int[] differences, int lower, int upper) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a\u00a0string s\u00a0of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).\nThe score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.\nExample 1:\nInput: s = \"011101\"\nOutput: 5 \nExplanation: \nAll possible ways of splitting s into two non-empty substrings are:\nleft = \"0\" and right = \"11101\", score = 1 + 4 = 5 \nleft = \"01\" and right = \"1101\", score = 1 + 3 = 4 \nleft = \"011\" and right = \"101\", score = 1 + 2 = 3 \nleft = \"0111\" and right = \"01\", score = 1 + 1 = 2 \nleft = \"01110\" and right = \"1\", score = 2 + 1 = 3\nExample 2:\nInput: s = \"00111\"\nOutput: 5\nExplanation: When left = \"00\" and right = \"111\", we get the maximum score = 2 + 3 = 5\nExample 3:\nInput: s = \"1111\"\nOutput: 3\nConstraints:\n\t2 <= s.length <= 500\n\tThe string s consists of characters '0' and '1' only.",
        "topics": [
            "String",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/maximum-score-after-splitting-a-string/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def maxScore(self, s: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar maxScore = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maxScore(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an array of integers\u00a0nums, you start with an initial positive value startValue.\nIn each iteration, you calculate the step by step sum of startValue\u00a0plus\u00a0elements in nums\u00a0(from left to right).\nReturn the minimum positive value of\u00a0startValue such that the step by step sum is never less than 1.\nExample 1:\nInput: nums = [-3,2,-3,4,2]\nOutput: 5\nExplanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1.\nstep by step sum\nstartValue = 4 | startValue = 5 | nums\n  (4 -3 ) = 1  | (5 -3 ) = 2    |  -3\n  (1 +2 ) = 3  | (2 +2 ) = 4    |   2\n  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3\n  (0 +4 ) = 4  | (1 +4 ) = 5    |   4\n  (4 +2 ) = 6  | (5 +2 ) = 7    |   2\nExample 2:\nInput: nums = [1,2]\nOutput: 1\nExplanation: Minimum start value should be positive. \nExample 3:\nInput: nums = [1,-2,-3]\nOutput: 5\nConstraints:\n\t1 <= nums.length <= 100\n\t-100 <= nums[i] <= 100",
        "topics": [
            "Array",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def minStartValue(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar minStartValue = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minStartValue(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).\nA middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].\nIf middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.\nReturn the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.\nExample 1:\nInput: nums = [2,3,-1,8,4]\nOutput: 3\nExplanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\nThe sum of the numbers after index 3 is: 4 = 4\nExample 2:\nInput: nums = [1,-1,4]\nOutput: 2\nExplanation: The sum of the numbers before index 2 is: 1 + -1 = 0\nThe sum of the numbers after index 2 is: 0\nExample 3:\nInput: nums = [2,5]\nOutput: -1\nExplanation: There is no valid middleIndex.\nConstraints:\n\t1 <= nums.length <= 100\n\t-1000 <= nums[i] <= 1000\nNote: This question is the same as\u00a0724:\u00a0https://leetcode.com/problems/find-pivot-index/",
        "topics": [
            "Array",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/find-the-middle-index-in-array/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def findMiddleIndex(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar findMiddleIndex = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int findMiddleIndex(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer array nums of length n, and an integer array queries of length m.\nReturn an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\nInput: nums = [4,5,2,1], queries = [3,10,21]\nOutput: [2,3,4]\nExplanation: We answer the queries as follows:\n- The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2.\n- The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3.\n- The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4.\nExample 2:\nInput: nums = [2,3,4,5], queries = [1]\nOutput: [0]\nExplanation: The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0.\nConstraints:\n\tn == nums.length\n\tm == queries.length\n\t1 <= n, m <= 1000\n\t1 <= nums[i], queries[i] <= 10^6",
        "topics": [
            "Array",
            "Binary Search",
            "Greedy",
            "Sorting",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/longest-subsequence-with-limited-sum/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number[]} queries\r\n * @return {number[]}\r\n */\r\nvar answerQueries = function(nums, queries) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] answerQueries(int[] nums, int[] queries) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.\nCreate the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.\nReturn an array of the k digits representing the answer.\nExample 1:\nInput: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\nOutput: [9,8,6,5,3]\nExample 2:\nInput: nums1 = [6,7], nums2 = [6,0,4], k = 5\nOutput: [6,7,6,0,4]\nExample 3:\nInput: nums1 = [3,9], nums2 = [8,9], k = 3\nOutput: [9,8,9]\nConstraints:\n\tm == nums1.length\n\tn == nums2.length\n\t1 <= m, n <= 500\n\t0 <= nums1[i], nums2[i] <= 9\n\t1 <= k <= m + n",
        "topics": [
            "Array",
            "Two Pointers",
            "Stack",
            "Greedy",
            "Monotonic Stack"
        ],
        "url": "https://leetcode.com/problems/create-maximum-number/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums1\r\n * @param {number[]} nums2\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar maxNumber = function(nums1, nums2, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are playing a variation of the game Zuma.\nIn this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red 'R', yellow 'Y', blue 'B', green 'G', or white 'W'. You also have several colored balls in your hand.\nYour goal is to clear all of the balls from the board. On each turn:\n\tPick any ball from your hand and insert it in between two balls in the row or on either end of the row.\n\tIf there is a group of three or more consecutive balls of the same color, remove the group of balls from the board.\n\t\tIf this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.\n\tIf there are no more balls on the board, then you win the game.\n\tRepeat this process until you either win or do not have any more balls in your hand.\nGiven a string board, representing the row of balls on the board, and a string hand, representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.\nExample 1:\nInput: board = \"WRRBBW\", hand = \"RB\"\nOutput: -1\nExplanation: It is impossible to clear all the balls. The best you can do is:\n- Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.\n- Insert 'B' so the board becomes WBBBW. WBBBW -> WW.\nThere are still balls remaining on the board, and you are out of balls to insert.\nExample 2:\nInput: board = \"WWRRBBWW\", hand = \"WRBRW\"\nOutput: 2\nExplanation: To make the board empty:\n- Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW -> WWBBWW.\n- Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW -> empty.\n2 balls from your hand were needed to clear the board.\nExample 3:\nInput: board = \"G\", hand = \"GGGGG\"\nOutput: 2\nExplanation: To make the board empty:\n- Insert 'G' so the board becomes GG.\n- Insert 'G' so the board becomes GGG. GGG -> empty.\n2 balls from your hand were needed to clear the board.\nConstraints:\n\t1 <= board.length <= 16\n\t1 <= hand.length <= 5\n\tboard and hand consist of the characters 'R', 'Y', 'B', 'G', and 'W'.\n\tThe initial row of balls on the board will not have any groups of three or more consecutive balls of the same color.",
        "topics": [
            "String",
            "Dynamic Programming",
            "Stack",
            "Breadth-First Search",
            "Memoization"
        ],
        "url": "https://leetcode.com/problems/zuma-game/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def findMinStep(self, board: str, hand: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} board\r\n * @param {string} hand\r\n * @return {number}\r\n */\r\nvar findMinStep = function(board, hand) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int findMinStep(String board, String hand) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an array nums of n positive integers and an integer k.\nInitially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:\n\tChoose any non-empty subarray nums[l, ..., r] that you haven't chosen previously.\n\tChoose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.\n\tMultiply your score by x.\nHere, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.\nThe prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.\nReturn the maximum possible score after applying at most k operations.\nSince the answer may be large, return it modulo 10^9 + 7.\nExample 1:\nInput: nums = [8,3,9,3,8], k = 2\nOutput: 81\nExplanation: To get a score of 81, we can apply the following operations:\n- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.\n- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.\nIt can be proven that 81 is the highest score one can obtain.\nExample 2:\nInput: nums = [19,12,14,6,10,18], k = 3\nOutput: 4788\nExplanation: To get a score of 4788, we can apply the following operations: \n- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.\n- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.\n- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.\nIt can be proven that 4788 is the highest score one can obtain.\nConstraints:\n\t1 <= nums.length == n <= 10^5\n\t1 <= nums[i] <= 10^5\n\t1 <= k <= min(n * (n + 1) / 2, 10^9)",
        "topics": [
            "Array",
            "Math",
            "Stack",
            "Greedy",
            "Monotonic Stack",
            "Number Theory"
        ],
        "url": "https://leetcode.com/problems/apply-operations-to-maximize-score/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def maximumScore(self, nums: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar maximumScore = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximumScore(List<Integer> nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed 2D integer array items of length n and an integer k.\nitems[i] = [profiti, categoryi], where profiti and categoryi denote the profit and category of the i^th item respectively.\nLet's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.\nYour task is to find the maximum elegance from all subsequences of size k in items.\nReturn an integer denoting the maximum elegance of a subsequence of items with size exactly k.\nNote: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.\nExample 1:\nInput: items = [[3,2],[5,1],[10,1]], k = 2\nOutput: 17\nExplanation: In this example, we have to select a subsequence of size 2.\nWe can select items[0] = [3,2] and items[2] = [10,1].\nThe total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].\nHence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. \nExample 2:\nInput: items = [[3,1],[3,1],[2,2],[5,3]], k = 3\nOutput: 19\nExplanation: In this example, we have to select a subsequence of size 3. \nWe can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. \nThe total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. \nHence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.\nExample 3:\nInput: items = [[1,1],[2,1],[3,1]], k = 3\nOutput: 7\nExplanation: In this example, we have to select a subsequence of size 3. \nWe should select all the items. \nThe total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. \nHence, the maximum elegance is 6 + 1^2 = 7.  \nConstraints:\n\t1 <= items.length == n <= 10^5\n\titems[i].length == 2\n\titems[i][0] == profiti\n\titems[i][1] == categoryi\n\t1 <= profiti <= 10^9\n\t1 <= categoryi <= n \n\t1 <= k <= n",
        "topics": [
            "Array",
            "Hash Table",
            "Stack",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/maximum-elegance-of-a-k-length-subsequence/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} items\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar findMaximumElegance = function(items, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long findMaximumElegance(int[][] items, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a string s that contains digits 0-9, addition symbols '+', and multiplication symbols '*' only, representing a valid math expression of single digit numbers (e.g., 3+5*2). This expression was given to n elementary school students. The students were instructed to get the answer of the expression by following this order of operations:\n\tCompute multiplication, reading from left to right; Then,\n\tCompute addition, reading from left to right.\nYou are given an integer array answers of length n, which are the submitted answers of the students in no particular order. You are asked to grade the answers, by following these rules:\n\tIf an answer equals the correct answer of the expression, this student will be rewarded 5 points;\n\tOtherwise, if the answer could be interpreted as if the student applied the operators in the wrong order but had correct arithmetic, this student will be rewarded 2 points;\n\tOtherwise, this student will be rewarded 0 points.\nReturn the sum of the points of the students.\nExample 1:\nInput: s = \"7+3*1*2\", answers = [20,13,42]\nOutput: 7\nExplanation: As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: [20,13,42]\nA student might have applied the operators in this wrong order: ((7+3)*1)*2 = 20. Therefore one student is rewarded 2 points: [20,13,42]\nThe points for the students are: [2,5,0]. The sum of the points is 2+5+0=7.\nExample 2:\nInput: s = \"3+5*2\", answers = [13,0,10,13,13,16,16]\nOutput: 19\nExplanation: The correct answer of the expression is 13, therefore three students are rewarded 5 points each: [13,0,10,13,13,16,16]\nA student might have applied the operators in this wrong order: ((3+5)*2 = 16. Therefore two students are rewarded 2 points: [13,0,10,13,13,16,16]\nThe points for the students are: [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19.\nExample 3:\nInput: s = \"6+0*1\", answers = [12,9,6,4,8,6]\nOutput: 10\nExplanation: The correct answer of the expression is 6.\nIf a student had incorrectly done (6+0)*1, the answer would also be 6.\nBy the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points.\nThe points for the students are: [0,0,5,0,0,5]. The sum of the points is 10.\nConstraints:\n\t3 <= s.length <= 31\n\ts represents a valid expression that contains only digits 0-9, '+', and '*' only.\n\tAll the integer operands in the expression are in the inclusive range [0, 9].\n\t1 <= The count of all operators ('+' and '*') in the math expression <= 15\n\tTest data are generated such that the correct answer of the expression is in the range of [0, 1000].\n\tn == answers.length\n\t1 <= n <= 10^4\n\t0 <= answers[i] <= 1000",
        "topics": [
            "Array",
            "Math",
            "String",
            "Dynamic Programming",
            "Stack",
            "Memoization"
        ],
        "url": "https://leetcode.com/problems/the-score-of-students-solving-math-expression/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @param {number[]} answers\r\n * @return {number}\r\n */\r\nvar scoreOfStudents = function(s, answers) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int scoreOfStudents(String s, int[] answers) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\n\tAny left parenthesis '(' must have a corresponding right parenthesis ')'.\n\tAny right parenthesis ')' must have a corresponding left parenthesis '('.\n\tLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n\t'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".\nExample 1:\nInput: s = \"()\"\nOutput: true\nExample 2:\nInput: s = \"(*)\"\nOutput: true\nExample 3:\nInput: s = \"(*))\"\nOutput: true\nConstraints:\n\t1 <= s.length <= 100\n\ts[i] is '(', ')' or '*'.",
        "topics": [
            "String",
            "Dynamic Programming",
            "Stack",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/valid-parenthesis-string/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def checkValidString(self, s: str) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {boolean}\r\n */\r\nvar checkValidString = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean checkValidString(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "The min-product of an array is equal to the minimum value in the array multiplied by the array's sum.\n\tFor example, the array [3,2,5] (minimum value is 2) has a min-product of 2 * (3+2+5) = 2 * 10 = 20.\nGiven an array of integers nums, return the maximum min-product of any non-empty subarray of nums. Since the answer may be large, return it modulo 10^9 + 7.\nNote that the min-product should be maximized before performing the modulo operation. Testcases are generated such that the maximum min-product without modulo will fit in a 64-bit signed integer.\nA subarray is a contiguous part of an array.\nExample 1:\nInput: nums = [1,2,3,2]\nOutput: 14\nExplanation: The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).\n2 * (2+3+2) = 2 * 7 = 14.\nExample 2:\nInput: nums = [2,3,3,1,2]\nOutput: 18\nExplanation: The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).\n3 * (3+3) = 3 * 6 = 18.\nExample 3:\nInput: nums = [3,1,5,6,4,2]\nOutput: 60\nExplanation: The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).\n4 * (5+6+4) = 4 * 15 = 60.\nConstraints:\n\t1 <= nums.length <= 10^5\n\t1 <= nums[i] <= 10^7",
        "topics": [
            "Array",
            "Stack",
            "Monotonic Stack",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/maximum-subarray-min-product/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maxSumMinProduct(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maxSumMinProduct = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maxSumMinProduct(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty:\n\tRemove the first character of a string s and give it to the robot. The robot will append this character to the string t.\n\tRemove the last character of a string t and give it to the robot. The robot will write this character on paper.\nReturn the lexicographically smallest string that can be written on the paper.\nExample 1:\nInput: s = \"zza\"\nOutput: \"azz\"\nExplanation: Let p denote the written string.\nInitially p=\"\", s=\"zza\", t=\"\".\nPerform first operation three times p=\"\", s=\"\", t=\"zza\".\nPerform second operation three times p=\"azz\", s=\"\", t=\"\".\nExample 2:\nInput: s = \"bac\"\nOutput: \"abc\"\nExplanation: Let p denote the written string.\nPerform first operation twice p=\"\", s=\"c\", t=\"ba\". \nPerform second operation twice p=\"ab\", s=\"c\", t=\"\". \nPerform first operation p=\"ab\", s=\"\", t=\"c\". \nPerform second operation p=\"abc\", s=\"\", t=\"\".\nExample 3:\nInput: s = \"bdda\"\nOutput: \"addb\"\nExplanation: Let p denote the written string.\nInitially p=\"\", s=\"bdda\", t=\"\".\nPerform first operation four times p=\"\", s=\"\", t=\"bdda\".\nPerform second operation four times p=\"addb\", s=\"\", t=\"\".\nConstraints:\n\t1 <= s.length <= 10^5\n\ts consists of only English lowercase letters.",
        "topics": [
            "Hash Table",
            "String",
            "Stack",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/using-a-robot-to-print-the-lexicographically-smallest-string/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def robotWithString(self, s: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar robotWithString = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String robotWithString(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an absolute path for a Unix-style file system, which begins with a slash '/', transform this path into its simplified canonical path.\nIn Unix-style file system context, a single period '.' signifies the current directory, a double period \"..\" denotes moving up one directory level, and multiple slashes such as \"//\" are interpreted as a single slash. In this problem, treat sequences of periods not covered by the previous rules (like \"...\") as valid names for files or directories.\nThe simplified canonical path should adhere to the following rules:\n\tIt must start with a single slash '/'.\n\tDirectories within the path should be separated by only one slash '/'.\n\tIt should not end with a slash '/', unless it's the root directory.\n\tIt should exclude any single or double periods used to denote current or parent directories.\nReturn the new path.\nExample 1:\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation:\nThe trailing slash should be removed.\nExample 2:\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation:\nMultiple consecutive slashes are replaced by a single one.\nExample 3:\nInput: path = \"/home/user/Documents/../Pictures\"\nOutput: \"/home/user/Pictures\"\nExplanation:\nA double period \"..\" refers to the directory up a level.\nExample 4:\nInput: path = \"/../\"\nOutput: \"/\"\nExplanation:\nGoing one level up from the root directory is not possible.\nExample 5:\nInput: path = \"/.../a/../b/c/../d/./\"\nOutput: \"/.../b/d\"\nExplanation:\n\"...\" is a valid name for a directory in this problem.\nConstraints:\n\t1 <= path.length <= 3000\n\tpath consists of English letters, digits, period '.', slash '/' or '_'.\n\tpath is a valid absolute Unix path.",
        "topics": [
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/simplify-path/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def simplifyPath(self, path: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} path\r\n * @return {string}\r\n */\r\nvar simplifyPath = function(path) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String simplifyPath(String path) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an array heights of n integers representing the number of bricks in n consecutive towers. Your task is to remove some bricks to form a mountain-shaped tower arrangement. In this arrangement, the tower heights are non-decreasing, reaching a maximum peak value with one or multiple consecutive towers and then non-increasing.\nReturn the maximum possible sum of heights of a mountain-shaped tower arrangement.\nExample 1:\nInput: heights = [5,3,4,1,1]\nOutput: 13\nExplanation:\nWe remove some bricks to make heights =\u00a0[5,3,3,1,1], the peak is at index 0.\nExample 2:\nInput: heights = [6,5,3,9,2,7]\nOutput: 22\nExplanation:\nWe remove some bricks to make heights =\u00a0[3,3,3,9,2,2], the peak is at index 3.\nExample 3:\nInput: heights = [3,2,5,5,2,3]\nOutput: 18\nExplanation:\nWe remove some bricks to make heights = [2,2,5,5,2,2], the peak is at index 2 or 3.\nConstraints:\n\t1 <= n == heights <= 10^3\n\t1 <= heights[i] <= 10^9",
        "topics": [
            "Array",
            "Stack",
            "Monotonic Stack"
        ],
        "url": "https://leetcode.com/problems/beautiful-towers-i/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximumSumOfHeights(self, heights: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} heights\r\n * @return {number}\r\n */\r\nvar maximumSumOfHeights = function(heights) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long maximumSumOfHeights(int[] heights) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are n cars on an infinitely long road. The cars are numbered from 0 to n - 1 from left to right and each car is present at a unique point.\nYou are given a 0-indexed string directions of length n. directions[i] can be either 'L', 'R', or 'S' denoting whether the i^th car is moving towards the left, towards the right, or staying at its current point respectively. Each moving car has the same speed.\nThe number of collisions can be calculated as follows:\n\tWhen two cars moving in opposite directions collide with each other, the number of collisions increases by 2.\n\tWhen a moving car collides with a stationary car, the number of collisions increases by 1.\nAfter a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.\nReturn the total number of collisions that will happen on the road.\nExample 1:\nInput: directions = \"RLRSLL\"\nOutput: 5\nExplanation:\nThe collisions that will happen on the road are:\n- Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.\n- Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.\n- Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.\n- Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.\nThus, the total number of collisions that will happen on the road is 5. \nExample 2:\nInput: directions = \"LLRR\"\nOutput: 0\nExplanation:\nNo cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0.\nConstraints:\n\t1 <= directions.length <= 10^5\n\tdirections[i] is either 'L', 'R', or 'S'.",
        "topics": [
            "String",
            "Stack",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/count-collisions-on-a-road/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def countCollisions(self, directions: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} directions\r\n * @return {number}\r\n */\r\nvar countCollisions = function(directions) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int countCollisions(String directions) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a string s which represents an expression, evaluate this expression and return its value.\u00a0\nThe integer division should truncate toward zero.\nYou may assume that the given expression is always valid. All intermediate results will be in the range of [-2^31, 2^31 - 1].\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\nExample 1:\nInput: s = \"3+2*2\"\nOutput: 7\nExample 2:\nInput: s = \" 3/2 \"\nOutput: 1\nExample 3:\nInput: s = \" 3+5 / 2 \"\nOutput: 5\nConstraints:\n\t1 <= s.length <= 3 * 10^5\n\ts consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces.\n\ts represents a valid expression.\n\tAll the integers in the expression are non-negative integers in the range [0, 2^31 - 1].\n\tThe answer is guaranteed to fit in a 32-bit integer.",
        "topics": [
            "Math",
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/basic-calculator-ii/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def calculate(self, s: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar calculate = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int calculate(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the i^th character in the game.\nA character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei.\nReturn the number of weak characters.\nExample 1:\nInput: properties = [[5,5],[6,3],[3,6]]\nOutput: 0\nExplanation: No character has strictly greater attack and defense than the other.\nExample 2:\nInput: properties = [[2,2],[3,3]]\nOutput: 1\nExplanation: The first character is weak because the second character has a strictly greater attack and defense.\nExample 3:\nInput: properties = [[1,5],[10,4],[4,3]]\nOutput: 1\nExplanation: The third character is weak because the second character has a strictly greater attack and defense.\nConstraints:\n\t2 <= properties.length <= 10^5\n\tproperties[i].length == 2\n\t1 <= attacki, defensei <= 10^5",
        "topics": [
            "Array",
            "Stack",
            "Greedy",
            "Sorting",
            "Monotonic Stack"
        ],
        "url": "https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} properties\r\n * @return {number}\r\n */\r\nvar numberOfWeakCharacters = function(properties) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numberOfWeakCharacters(int[][] properties) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "We are given an array asteroids of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\nExample 1:\nInput: asteroids = [5,10,-5]\nOutput: [5,10]\nExplanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.\nExample 2:\nInput: asteroids = [8,-8]\nOutput: []\nExplanation: The 8 and -8 collide exploding each other.\nExample 3:\nInput: asteroids = [10,2,-5]\nOutput: [10]\nExplanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.\nConstraints:\n\t2 <= asteroids.length <= 10^4\n\t-1000 <= asteroids[i] <= 1000\n\tasteroids[i] != 0",
        "topics": [
            "Array",
            "Stack",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/asteroid-collision/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def asteroidCollision(self, asteroids: List[int]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} asteroids\r\n * @return {number[]}\r\n */\r\nvar asteroidCollision = function(asteroids) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] asteroidCollision(int[] asteroids) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a string s of lower and upper case English letters.\nA good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where:\n\t0 <= i <= s.length - 2\n\ts[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.\nTo make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.\nReturn the string after making it good. The answer is guaranteed to be unique under the given constraints.\nNotice that an empty string is also good.\nExample 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\".\nExample 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: We have many possible scenarios, and all lead to the same answer. For example:\n\"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\"\n\"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\"\nExample 3:\nInput: s = \"s\"\nOutput: \"s\"\nConstraints:\n\t1 <= s.length <= 100\n\ts contains only lower and upper case English letters.",
        "topics": [
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/make-the-string-great/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def makeGood(self, s: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar makeGood = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String makeGood(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a string s consisting only of uppercase English letters.\nYou can apply some operations to this string where, in one operation, you can remove any occurrence of one of the substrings \"AB\" or \"CD\" from s.\nReturn the minimum possible length of the resulting string that you can obtain.\nNote that the string concatenates after removing the substring and could produce new \"AB\" or \"CD\" substrings.\nExample 1:\nInput: s = \"ABFCACDB\"\nOutput: 2\nExplanation: We can do the following operations:\n- Remove the substring \"ABFCACDB\", so s = \"FCACDB\".\n- Remove the substring \"FCACDB\", so s = \"FCAB\".\n- Remove the substring \"FCAB\", so s = \"FC\".\nSo the resulting length of the string is 2.\nIt can be shown that it is the minimum length that we can obtain.\nExample 2:\nInput: s = \"ACBBD\"\nOutput: 5\nExplanation: We cannot do any operations on the string so the length remains the same.\nConstraints:\n\t1 <= s.length <= 100\n\ts\u00a0consists only of uppercase English letters.",
        "topics": [
            "String",
            "Stack",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/minimum-string-length-after-removing-substrings/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def minLength(self, s: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar minLength = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minLength(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.\nWe repeatedly make duplicate removals on s until we no longer can.\nReturn the final string after all such duplicate removals have been made. It can be proven that the answer is unique.\nExample 1:\nInput: s = \"abbaca\"\nOutput: \"ca\"\nExplanation: \nFor example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\".\nExample 2:\nInput: s = \"azxxzy\"\nOutput: \"ay\"\nConstraints:\n\t1 <= s.length <= 10^5\n\ts consists of lowercase English letters.",
        "topics": [
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def removeDuplicates(self, s: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar removeDuplicates = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String removeDuplicates(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, return the preorder traversal of its nodes' values.\nExample 1:\nInput: root = [1,null,2,3]\nOutput: [1,2,3]\nExample 2:\nInput: root = []\nOutput: []\nExample 3:\nInput: root = [1]\nOutput: [1]\nConstraints:\n\tThe number of nodes in the tree is in the range [0, 100].\n\t-100 <= Node.val <= 100\nFollow up: Recursive solution is trivial, could you do it iteratively?",
        "topics": [
            "Stack",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nvar preorderTraversal = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<Integer> preorderTraversal(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "The Leetcode file system keeps a log each time some user performs a change folder operation.\nThe operations are described below:\n\t\"../\" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).\n\t\"./\" : Remain in the same folder.\n\t\"x/\" : Move to the child folder named x (This folder is guaranteed to always exist).\nYou are given a list of strings logs where logs[i] is the operation performed by the user at the i^th step.\nThe file system starts in the main folder, then the operations in logs are performed.\nReturn the minimum number of operations needed to go back to the main folder after the change folder operations.\nExample 1:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Use this change folder operation \"../\" 2 times and go back to the main folder.\nExample 2:\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\nExample 3:\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0\nConstraints:\n\t1 <= logs.length <= 10^3\n\t2 <= logs[i].length <= 10\n\tlogs[i] contains lowercase English letters, digits, '.', and '/'.\n\tlogs[i] follows the format described in the statement.\n\tFolder names consist of lowercase English letters and digits.",
        "topics": [
            "Array",
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/crawler-log-folder/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def minOperations(self, logs: List[str]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string[]} logs\r\n * @return {number}\r\n */\r\nvar minOperations = function(logs) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minOperations(String[] logs) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are n 1-indexed robots, each having a position on a line, health, and movement direction.\nYou are given 0-indexed integer arrays positions, healths, and a string directions (directions[i] is either 'L' for left or 'R' for right). All integers in positions are unique.\nAll robots start moving on the line simultaneously at the same speed in their given directions. If two robots ever share the same position while moving, they will collide.\nIf two robots collide, the robot with lower health is removed from the line, and the health of the other robot decreases by one. The surviving robot continues in the same direction it was going. If both robots have the same health, they are both removed from the line.\nYour task is to determine the health of the robots that survive the collisions, in the same order that the robots were given, i.e. final heath of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.\nReturn an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.\nNote: The positions may be unsorted.\nExample 1:\nInput: positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = \"RRRRR\"\nOutput: [2,17,9,15,10]\nExplanation: No collision occurs in this example, since all robots are moving in the same direction. So, the health of the robots in order from the first robot is returned, [2, 17, 9, 15, 10].\nExample 2:\nInput: positions = [3,5,2,6], healths = [10,10,15,12], directions = \"RLRL\"\nOutput: [14]\nExplanation: There are 2 collisions in this example. Firstly, robot 1 and robot 2 will collide, and since both have the same health, they will be removed from the line. Next, robot 3 and robot 4 will collide and since robot 4's health is smaller, it gets removed, and robot 3's health becomes 15 - 1 = 14. Only robot 3 remains, so we return [14].\nExample 3:\nInput: positions = [1,2,5,6], healths = [10,10,11,11], directions = \"RLRL\"\nOutput: []\nExplanation: Robot 1 and robot 2 will collide and since both have the same health, they are both removed. Robot 3 and 4 will collide and since both have the same health, they are both removed. So, we return an empty array, [].\nConstraints:\n\t1 <= positions.length == healths.length == directions.length == n <= 10^5\n\t1 <= positions[i], healths[i] <= 10^9\n\tdirections[i] == 'L' or directions[i] == 'R'\n\tAll values in positions are distinct",
        "topics": [
            "Array",
            "Stack",
            "Sorting",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/robot-collisions/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} positions\r\n * @param {number[]} healths\r\n * @param {string} directions\r\n * @return {number[]}\r\n */\r\nvar survivedRobotsHealths = function(positions, healths, directions) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is an 8 x 8 chessboard containing n pieces (rooks, queens, or bishops). You are given a string array pieces of length n, where pieces[i] describes the type (rook, queen, or bishop) of the i^th piece. In addition, you are given a 2D integer array positions also of length n, where positions[i] = [ri, ci] indicates that the i^th piece is currently at the 1-based coordinate (ri, ci) on the chessboard.\nWhen making a move for a piece, you choose a destination square that the piece will travel toward and stop on.\n\tA rook can only travel horizontally or vertically from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), or (r, c-1).\n\tA queen can only travel horizontally, vertically, or diagonally from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), (r, c-1), (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).\n\tA bishop can only travel diagonally from (r, c) to the direction of (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).\nYou must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0^th second. A move combination is invalid if, at a given time, two or more pieces occupy the same square.\nReturn the number of valid move combinations\u200b\u200b\u200b\u200b\u200b.\nNotes:\n\tNo two pieces will start in the same square.\n\tYou may choose the square a piece is already on as its destination.\n\tIf two pieces are directly adjacent to each other, it is valid for them to move past each other and swap positions in one second.\nExample 1:\nInput: pieces = [\"rook\"], positions = [[1,1]]\nOutput: 15\nExplanation: The image above shows the possible squares the piece can move to.\nExample 2:\nInput: pieces = [\"queen\"], positions = [[1,1]]\nOutput: 22\nExplanation: The image above shows the possible squares the piece can move to.\nExample 3:\nInput: pieces = [\"bishop\"], positions = [[4,3]]\nOutput: 12\nExplanation: The image above shows the possible squares the piece can move to.\nConstraints:\n\tn == pieces.length \n\tn == positions.length\n\t1 <= n <= 4\n\tpieces only contains the strings \"rook\", \"queen\", and \"bishop\".\n\tThere will be at most one queen on the chessboard.\n\t1 <= xi, yi <= 8\n\tEach positions[i] is distinct.",
        "topics": [
            "Array",
            "String",
            "Backtracking",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/number-of-valid-move-combinations-on-chessboard/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string[]} pieces\r\n * @param {number[][]} positions\r\n * @return {number}\r\n */\r\nvar countCombinations = function(pieces, positions) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int countCombinations(String[] pieces, int[][] positions) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\nThe world is modeled as an m x n binary grid isInfected, where isInfected[i][j] == 0 represents uninfected cells, and isInfected[i][j] == 1 represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There will never be a tie.\nReturn the number of walls used to quarantine all the infected regions. If the world will become fully infected, return the number of walls used.\nExample 1:\nInput: isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]\nOutput: 10\nExplanation: There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\nExample 2:\nInput: isInfected = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: 4\nExplanation: Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\nExample 3:\nInput: isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]\nOutput: 13\nExplanation: The region on the left only builds two new walls.\nConstraints:\n\tm ==\u00a0isInfected.length\n\tn ==\u00a0isInfected[i].length\n\t1 <= m, n <= 50\n\tisInfected[i][j] is either 0 or 1.\n\tThere is always a contiguous viral region throughout the described process that will infect strictly more uncontaminated squares in the next round.",
        "topics": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/contain-virus/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def containVirus(self, isInfected: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} isInfected\r\n * @return {number}\r\n */\r\nvar containVirus = function(isInfected) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int containVirus(int[][] isInfected) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "A competition consists of n players numbered from 0 to n - 1.\nYou are given an integer array skills of size n and a positive integer k, where skills[i] is the skill level of player i. All integers in skills are unique.\nAll players are standing in a queue in order from player 0 to player n - 1.\nThe competition process is as follows:\n\tThe first two players in the queue play a game, and the player with the higher skill level wins.\n\tAfter the game, the winner stays at the beginning of the queue, and the loser goes to the end of it.\nThe winner of the competition is the first player who wins k games in a row.\nReturn the initial index of the winning player.\nExample 1:\nInput: skills = [4,2,6,3,9], k = 2\nOutput: 2\nExplanation:\nInitially, the queue of players is [0,1,2,3,4]. The following process happens:\n\tPlayers 0 and 1 play a game, since the skill of player 0 is higher than that of player 1, player 0 wins. The resulting queue is [0,2,3,4,1].\n\tPlayers 0 and 2 play a game, since the skill of player 2 is higher than that of player 0, player 2 wins. The resulting queue is [2,3,4,1,0].\n\tPlayers 2 and 3 play a game, since the skill of player 2 is higher than that of player 3, player 2 wins. The resulting queue is [2,4,1,0,3].\nPlayer 2 won k = 2 games in a row, so the winner is player 2.\nExample 2:\nInput: skills = [2,5,4], k = 3\nOutput: 1\nExplanation:\nInitially, the queue of players is [0,1,2]. The following process happens:\n\tPlayers 0 and 1 play a game, since the skill of player 1 is higher than that of player 0, player 1 wins. The resulting queue is [1,2,0].\n\tPlayers 1 and 2 play a game, since the skill of player 1 is higher than that of player 2, player 1 wins. The resulting queue is [1,0,2].\n\tPlayers 1 and 0 play a game, since the skill of player 1 is higher than that of player 0, player 1 wins. The resulting queue is [1,2,0].\nPlayer 1 won k = 3 games in a row, so the winner is player 1.\nConstraints:\n\tn == skills.length\n\t2 <= n <= 10^5\n\t1 <= k <= 10^9\n\t1 <= skills[i] <= 10^6\n\tAll integers in skills are unique.",
        "topics": [
            "Array",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/find-the-first-player-to-win-k-games-in-a-row/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def findWinningPlayer(self, skills: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} skills\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar findWinningPlayer = function(skills, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int findWinningPlayer(int[] skills, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "A robot on an infinite XY-plane starts at point (0, 0) facing north. The robot can receive a sequence of these three possible types of commands:\n\t-2: Turn left 90 degrees.\n\t-1: Turn right 90 degrees.\n\t1 <= k <= 9: Move forward k units, one unit at a time.\nSome of the grid squares are obstacles. The i^th obstacle is at grid point obstacles[i] = (xi, yi). If the robot runs into an obstacle, then it will instead stay in its current location and move on to the next command.\nReturn the maximum Euclidean distance that the robot ever gets from the origin squared (i.e. if the distance is 5, return 25).\nNote:\n\tNorth means +Y direction.\n\tEast means +X direction.\n\tSouth means -Y direction.\n\tWest means -X direction.\n\tThere can be obstacle in\u00a0[0,0].\nExample 1:\nInput: commands = [4,-1,3], obstacles = []\nOutput: 25\nExplanation: The robot starts at (0, 0):\n1. Move north 4 units to (0, 4).\n2. Turn right.\n3. Move east 3 units to (3, 4).\nThe furthest point the robot ever gets from the origin is (3, 4), which squared is 3^2 + 4^2 = 25 units away.\nExample 2:\nInput: commands = [4,-1,4,-2,4], obstacles = [[2,4]]\nOutput: 65\nExplanation: The robot starts at (0, 0):\n1. Move north 4 units to (0, 4).\n2. Turn right.\n3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4).\n4. Turn left.\n5. Move north 4 units to (1, 8).\nThe furthest point the robot ever gets from the origin is (1, 8), which squared is 1^2 + 8^2 = 65 units away.\nExample 3:\nInput: commands = [6,-1,-1,6], obstacles = []\nOutput: 36\nExplanation: The robot starts at (0, 0):\n1. Move north 6 units to (0, 6).\n2. Turn right.\n3. Turn right.\n4. Move south 6 units to (0, 0).\nThe furthest point the robot ever gets from the origin is (0, 6), which squared is 6^2 = 36 units away.\nConstraints:\n\t1 <= commands.length <= 10^4\n\tcommands[i] is either -2, -1, or an integer in the range [1, 9].\n\t0 <= obstacles.length <= 10^4\n\t-3 * 10^4 <= xi, yi <= 3 * 10^4\n\tThe answer is guaranteed to be less than 2^31.",
        "topics": [
            "Array",
            "Hash Table",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/walking-robot-simulation/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} commands\r\n * @param {number[][]} obstacles\r\n * @return {number}\r\n */\r\nvar robotSim = function(commands, obstacles) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int robotSim(int[] commands, int[][] obstacles) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote:\u00a0You must not use any built-in BigInteger library or convert the inputs to integer directly.\nExample 1:\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\nExample 2:\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\nConstraints:\n\t1 <= num1.length, num2.length <= 200\n\tnum1 and num2 consist of digits only.\n\tBoth num1 and num2\u00a0do not contain any leading zero, except the number 0 itself.",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/multiply-strings/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def multiply(self, num1: str, num2: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} num1\r\n * @param {string} num2\r\n * @return {string}\r\n */\r\nvar multiply = function(num1, num2) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String multiply(String num1, String num2) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer limit and a 2D array queries of size n x 2.\nThere are limit + 1 balls with distinct labels in the range [0, limit]. Initially, all balls are uncolored. For every query in queries that is of the form [x, y], you mark ball x with the color y. After each query, you need to find the number of distinct colors among the balls.\nReturn an array result of length n, where result[i] denotes the number of distinct colors after i^th query.\nNote that when answering a query, lack of a color will not be considered as a color.\nExample 1:\nInput: limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]\nOutput: [1,2,2,3]\nExplanation:\n\tAfter query 0, ball 1 has color 4.\n\tAfter query 1, ball 1 has color 4, and ball 2 has color 5.\n\tAfter query 2, ball 1 has color 3, and ball 2 has color 5.\n\tAfter query 3, ball 1 has color 3, ball 2 has color 5, and ball 3 has color 4.\nExample 2:\nInput: limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]\nOutput: [1,2,2,3,4]\nExplanation:\n\tAfter query 0, ball 0 has color 1.\n\tAfter query 1, ball 0 has color 1, and ball 1 has color 2.\n\tAfter query 2, ball 0 has color 1, and balls 1 and 2 have color 2.\n\tAfter query 3, ball 0 has color 1, balls 1 and 2 have color 2, and ball 3 has color 4.\n\tAfter query 4, ball 0 has color 1, balls 1 and 2 have color 2, ball 3 has color 4, and ball 4 has color 5.\nConstraints:\n\t1 <= limit <= 10^9\n\t1 <= n == queries.length <= 10^5\n\tqueries[i].length == 2\n\t0 <= queries[i][0] <= limit\n\t1 <= queries[i][1] <= 10^9",
        "topics": [
            "Array",
            "Hash Table",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/find-the-number-of-distinct-colors-among-the-balls/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} limit\r\n * @param {number[][]} queries\r\n * @return {number[]}\r\n */\r\nvar queryResults = function(limit, queries) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] queryResults(int limit, int[][] queries) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an array arr that represents a permutation of numbers from 1 to n.\nYou have a binary string of size n that initially has all its bits set to zero. At each step i (assuming both the binary string and arr are 1-indexed) from 1 to n, the bit at position arr[i] is set to 1.\nYou are also given an integer m. Find the latest step at which there exists a group of ones of length m. A group of ones is a contiguous substring of 1's such that it cannot be extended in either direction.\nReturn the latest step at which there exists a group of ones of length exactly m. If no such group exists, return -1.\nExample 1:\nInput: arr = [3,5,1,2,4], m = 1\nOutput: 4\nExplanation: \nStep 1: \"00100\", groups: [\"1\"]\nStep 2: \"00101\", groups: [\"1\", \"1\"]\nStep 3: \"10101\", groups: [\"1\", \"1\", \"1\"]\nStep 4: \"11101\", groups: [\"111\", \"1\"]\nStep 5: \"11111\", groups: [\"11111\"]\nThe latest step at which there exists a group of size 1 is step 4.\nExample 2:\nInput: arr = [3,1,5,4,2], m = 2\nOutput: -1\nExplanation: \nStep 1: \"00100\", groups: [\"1\"]\nStep 2: \"10100\", groups: [\"1\", \"1\"]\nStep 3: \"10101\", groups: [\"1\", \"1\", \"1\"]\nStep 4: \"10111\", groups: [\"1\", \"111\"]\nStep 5: \"11111\", groups: [\"11111\"]\nNo group of size 2 exists during any step.\nConstraints:\n\tn == arr.length\n\t1 <= m <= n <= 10^5\n\t1 <= arr[i] <= n\n\tAll integers in arr are distinct.",
        "topics": [
            "Array",
            "Binary Search",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/find-latest-group-of-size-m/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def findLatestStep(self, arr: List[int], m: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} arr\r\n * @param {number} m\r\n * @return {number}\r\n */\r\nvar findLatestStep = function(arr, m) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int findLatestStep(int[] arr, int m) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the i^th worker.\nYou are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:\n\tYou will run k sessions and hire exactly one worker in each session.\n\tIn each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index.\n\t\tFor example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4^th worker because they have the lowest cost [3,2,7,7,1,2].\n\t\tIn the second hiring session, we will choose 1^st worker because they have the same lowest cost as 4^th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process.\n\tIf there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.\n\tA worker can only be chosen once.\nReturn the total cost to hire exactly k workers.\nExample 1:\nInput: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\nOutput: 11\nExplanation: We hire 3 workers in total. The total cost is initially 0.\n- In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.\n- In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.\n- In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.\nThe total hiring cost is 11.\nExample 2:\nInput: costs = [1,2,4,1], k = 3, candidates = 3\nOutput: 4\nExplanation: We hire 3 workers in total. The total cost is initially 0.\n- In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.\n- In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.\n- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.\nThe total hiring cost is 4.\nConstraints:\n\t1 <= costs.length <= 10^5 \n\t1 <= costs[i] <= 10^5\n\t1 <= k, candidates <= costs.length",
        "topics": [
            "Array",
            "Two Pointers",
            "Heap (Priority Queue)",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/total-cost-to-hire-k-workers/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} costs\r\n * @param {number} k\r\n * @param {number} candidates\r\n * @return {number}\r\n */\r\nvar totalCost = function(costs, k, candidates) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long totalCost(int[] costs, int k, int candidates) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Solve a given equation and return the value of 'x' in the form of a string \"x=#value\". The equation contains only '+', '-' operation, the variable 'x' and its coefficient. You should return \"No solution\" if there is no solution for the equation, or \"Infinite solutions\" if there are infinite solutions for the equation.\nIf there is exactly one solution for the equation, we ensure that the value of 'x' is an integer.\nExample 1:\nInput: equation = \"x+5-3+x=6+x-2\"\nOutput: \"x=2\"\nExample 2:\nInput: equation = \"x=x\"\nOutput: \"Infinite solutions\"\nExample 3:\nInput: equation = \"2x=x\"\nOutput: \"x=0\"\nConstraints:\n\t3 <= equation.length <= 1000\n\tequation has exactly one '='.\n\tequation consists of integers with an absolute value in the range [0, 100] without any leading zeros, and the variable 'x'.",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/solve-the-equation/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def solveEquation(self, equation: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} equation\r\n * @return {string}\r\n */\r\nvar solveEquation = function(equation) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String solveEquation(String equation) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are n cars on an infinitely long road. The cars are numbered from 0 to n - 1 from left to right and each car is present at a unique point.\nYou are given a 0-indexed string directions of length n. directions[i] can be either 'L', 'R', or 'S' denoting whether the i^th car is moving towards the left, towards the right, or staying at its current point respectively. Each moving car has the same speed.\nThe number of collisions can be calculated as follows:\n\tWhen two cars moving in opposite directions collide with each other, the number of collisions increases by 2.\n\tWhen a moving car collides with a stationary car, the number of collisions increases by 1.\nAfter a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.\nReturn the total number of collisions that will happen on the road.\nExample 1:\nInput: directions = \"RLRSLL\"\nOutput: 5\nExplanation:\nThe collisions that will happen on the road are:\n- Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.\n- Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.\n- Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.\n- Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.\nThus, the total number of collisions that will happen on the road is 5. \nExample 2:\nInput: directions = \"LLRR\"\nOutput: 0\nExplanation:\nNo cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0.\nConstraints:\n\t1 <= directions.length <= 10^5\n\tdirections[i] is either 'L', 'R', or 'S'.",
        "topics": [
            "String",
            "Stack",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/count-collisions-on-a-road/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def countCollisions(self, directions: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} directions\r\n * @return {number}\r\n */\r\nvar countCollisions = function(directions) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int countCollisions(String directions) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.\nYou are given an array customers of length n where customers[i] is the number of new customers arriving just before the i^th rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.\nYou can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.\nReturn the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.\nExample 1:\nInput: customers = [8,3], boardingCost = 5, runningCost = 6\nOutput: 3\nExplanation: The numbers written on the gondolas are the number of people currently there.\n1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\nThe highest profit was $37 after rotating the wheel 3 times.\nExample 2:\nInput: customers = [10,9,6], boardingCost = 6, runningCost = 4\nOutput: 7\nExplanation:\n1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\nThe highest profit was $122 after rotating the wheel 7 times.\nExample 3:\nInput: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\nOutput: -1\nExplanation:\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\nThe profit was never positive, so return -1.\nConstraints:\n\tn == customers.length\n\t1 <= n <= 10^5\n\t0 <= customers[i] <= 50\n\t1 <= boardingCost, runningCost <= 100",
        "topics": [
            "Array",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/maximum-profit-of-operating-a-centennial-wheel/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} customers\r\n * @param {number} boardingCost\r\n * @param {number} runningCost\r\n * @return {number}\r\n */\r\nvar minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "We are given an array asteroids of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\nExample 1:\nInput: asteroids = [5,10,-5]\nOutput: [5,10]\nExplanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.\nExample 2:\nInput: asteroids = [8,-8]\nOutput: []\nExplanation: The 8 and -8 collide exploding each other.\nExample 3:\nInput: asteroids = [10,2,-5]\nOutput: [10]\nExplanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.\nConstraints:\n\t2 <= asteroids.length <= 10^4\n\t-1000 <= asteroids[i] <= 1000\n\tasteroids[i] != 0",
        "topics": [
            "Array",
            "Stack",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/asteroid-collision/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def asteroidCollision(self, asteroids: List[int]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} asteroids\r\n * @return {number[]}\r\n */\r\nvar asteroidCollision = function(asteroids) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] asteroidCollision(int[] asteroids) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.\nYou are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.\nReturn the index of the student that will replace the chalk pieces.\nExample 1:\nInput: chalk = [5,1,5], k = 22\nOutput: 0\nExplanation: The students go in turns as follows:\n- Student number 0 uses 5 chalk, so k = 17.\n- Student number 1 uses 1 chalk, so k = 16.\n- Student number 2 uses 5 chalk, so k = 11.\n- Student number 0 uses 5 chalk, so k = 6.\n- Student number 1 uses 1 chalk, so k = 5.\n- Student number 2 uses 5 chalk, so k = 0.\nStudent number 0 does not have enough chalk, so they will have to replace it.\nExample 2:\nInput: chalk = [3,4,1,2], k = 25\nOutput: 1\nExplanation: The students go in turns as follows:\n- Student number 0 uses 3 chalk so k = 22.\n- Student number 1 uses 4 chalk so k = 18.\n- Student number 2 uses 1 chalk so k = 17.\n- Student number 3 uses 2 chalk so k = 15.\n- Student number 0 uses 3 chalk so k = 12.\n- Student number 1 uses 4 chalk so k = 8.\n- Student number 2 uses 1 chalk so k = 7.\n- Student number 3 uses 2 chalk so k = 5.\n- Student number 0 uses 3 chalk so k = 2.\nStudent number 1 does not have enough chalk, so they will have to replace it.\nConstraints:\n\tchalk.length == n\n\t1 <= n <= 10^5\n\t1 <= chalk[i] <= 10^5\n\t1 <= k <= 10^9",
        "topics": [
            "Array",
            "Binary Search",
            "Simulation",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/find-the-student-that-will-replace-the-chalk/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def chalkReplacer(self, chalk: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} chalk\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar chalkReplacer = function(chalk, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int chalkReplacer(int[] chalk, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "On day 1, one person discovers a secret.\nYou are given an integer delay, which means that each person will share the secret with a new person every day, starting from delay days after discovering the secret. You are also given an integer forget, which means that each person will forget the secret forget days after discovering it. A person cannot share the secret on the same day they forgot it, or on any day afterwards.\nGiven an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 10^9 + 7.\nExample 1:\nInput: n = 6, delay = 2, forget = 4\nOutput: 5\nExplanation:\nDay 1: Suppose the first person is named A. (1 person)\nDay 2: A is the only person who knows the secret. (1 person)\nDay 3: A shares the secret with a new person, B. (2 people)\nDay 4: A shares the secret with a new person, C. (3 people)\nDay 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)\nDay 6: B shares the secret with E, and C shares the secret with F. (5 people)\nExample 2:\nInput: n = 4, delay = 1, forget = 3\nOutput: 6\nExplanation:\nDay 1: The first person is named A. (1 person)\nDay 2: A shares the secret with B. (2 people)\nDay 3: A and B share the secret with 2 new people, C and D. (4 people)\nDay 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)\nConstraints:\n\t2 <= n <= 1000\n\t1 <= delay < forget <= n",
        "topics": [
            "Dynamic Programming",
            "Queue",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/number-of-people-aware-of-a-secret/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number} delay\r\n * @param {number} forget\r\n * @return {number}\r\n */\r\nvar peopleAwareOfSecret = function(n, delay, forget) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\nNote that after backspacing an empty text, the text will continue empty.\nExample 1:\nInput: s = \"ab#c\", t = \"ad#c\"\nOutput: true\nExplanation: Both s and t become \"ac\".\nExample 2:\nInput: s = \"ab##\", t = \"c#d#\"\nOutput: true\nExplanation: Both s and t become \"\".\nExample 3:\nInput: s = \"a#c\", t = \"b\"\nOutput: false\nExplanation: s becomes \"c\" while t becomes \"b\".\nConstraints:\n\t1 <= s.length, t.length <= 200\n\ts and t only contain lowercase letters and '#' characters.\nFollow up: Can you solve it in O(n) time and O(1) space?",
        "topics": [
            "Two Pointers",
            "String",
            "Stack",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/backspace-string-compare/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def backspaceCompare(self, s: str, t: str) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @param {string} t\r\n * @return {boolean}\r\n */\r\nvar backspaceCompare = function(s, t) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean backspaceCompare(String s, String t) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given two positive integers x and y, denoting the number of coins with values 75 and 10 respectively.\nAlice and Bob are playing a game. Each turn, starting with Alice, the player must pick up coins with a total value 115. If the player is unable to do so, they lose the game.\nReturn the name of the player who wins the game if both players play optimally.\nExample 1:\nInput: x = 2, y = 7\nOutput: \"Alice\"\nExplanation:\nThe game ends in a single turn:\n\tAlice picks 1 coin with a value of 75 and 4 coins with a value of 10.\nExample 2:\nInput: x = 4, y = 11\nOutput: \"Bob\"\nExplanation:\nThe game ends in 2 turns:\n\tAlice picks 1 coin with a value of 75 and 4 coins with a value of 10.\n\tBob picks 1 coin with a value of 75 and 4 coins with a value of 10.\nConstraints:\n\t1 <= x, y <= 100",
        "topics": [
            "Math",
            "Simulation",
            "Game Theory"
        ],
        "url": "https://leetcode.com/problems/find-the-winning-player-in-coin-game/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def losingPlayer(self, x: int, y: int) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {string}\r\n */\r\nvar losingPlayer = function(x, y) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String losingPlayer(int x, int y) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\tnums[0] = 0\n\tnums[1] = 1\n\tnums[2 * i] = nums[i] when 2 <= 2 * i <= n\n\tnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.\nExample 1:\nInput: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nExample 2:\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nExample 3:\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.\nConstraints:\n\t0 <= n <= 100",
        "topics": [
            "Array",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/get-maximum-in-generated-array/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def getMaximumGenerated(self, n: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar getMaximumGenerated = function(n) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int getMaximumGenerated(int n) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.\nExample 1:\nInput: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"\nExample 2:\nInput: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"\nExample 3:\nInput: num1 = \"0\", num2 = \"0\"\nOutput: \"0\"\nConstraints:\n\t1 <= num1.length, num2.length <= 10^4\n\tnum1 and num2 consist of only digits.\n\tnum1 and num2 don't have any leading zeros except for the zero itself.",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/add-strings/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def addStrings(self, num1: str, num2: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} num1\r\n * @param {string} num2\r\n * @return {string}\r\n */\r\nvar addStrings = function(num1, num2) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String addStrings(String num1, String num2) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an array of integers called nums, you can perform the following operation while nums contains at least 2 elements:\n\tChoose the first two elements of nums and delete them.\nThe score of the operation is the sum of the deleted elements.\nYour task is to find the maximum number of operations that can be performed, such that all operations have the same score.\nReturn the maximum number of operations possible that satisfy the condition mentioned above.\nExample 1:\nInput: nums = [3,2,1,4,5]\nOutput: 2\nExplanation: We perform the following operations:\n- Delete the first two elements, with score 3 + 2 = 5, nums = [1,4,5].\n- Delete the first two elements, with score 1 + 4 = 5, nums = [5].\nWe are unable to perform any more operations as nums contain only 1 element.\nExample 2:\nInput: nums = [3,2,6,1,4]\nOutput: 1\nExplanation: We perform the following operations:\n- Delete the first two elements, with score 3 + 2 = 5, nums = [6,1,4].\nWe are unable to perform any more operations as the score of the next operation isn't the same as the previous one.\nConstraints:\n\t2 <= nums.length <= 100\n\t1 <= nums[i] <= 1000",
        "topics": [
            "Array",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/maximum-number-of-operations-with-the-same-score-i/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def maxOperations(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maxOperations = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maxOperations(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\nThe given input is a directed graph that started as a rooted tree with n nodes (with distinct values from 1 to n), with one additional directed edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed.\nThe resulting graph is given as a 2D-array of edges. Each element of edges is a pair [ui, vi] that represents a directed edge connecting nodes ui and vi, where ui is a parent of child vi.\nReturn an edge that can be removed so that the resulting graph is a rooted tree of n nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.\nExample 1:\nInput: edges = [[1,2],[1,3],[2,3]]\nOutput: [2,3]\nExample 2:\nInput: edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\nOutput: [4,1]\nConstraints:\n\tn == edges.length\n\t3 <= n <= 1000\n\tedges[i].length == 2\n\t1 <= ui, vi <= n\n\tui != vi",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/redundant-connection-ii/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} edges\r\n * @return {number[]}\r\n */\r\nvar findRedundantDirectedConnection = function(edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] findRedundantDirectedConnection(int[][] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the minimum time required to be able to visit the cell (row, col), which means you can visit the cell (row, col) only when the time you visit it is greater than or equal to grid[row][col].\nYou are standing in the top-left cell of the matrix in the 0^th second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\nReturn the minimum time required in which you can visit the bottom-right cell of the matrix. If you cannot visit the bottom-right cell, then return -1.\nExample 1:\nInput: grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\nOutput: 7\nExplanation: One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\nExample 2:\nInput: grid = [[0,2,4],[3,2,1],[1,0,4]]\nOutput: -1\nExplanation: There is no path from the top left to the bottom-right cell.\nConstraints:\n\tm == grid.length\n\tn == grid[i].length\n\t2 <= m, n <= 1000\n\t4 <= m * n <= 10^5\n\t0 <= grid[i][j] <= 10^5\n\tgrid[0][0] == 0\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}",
        "topics": [
            "Array",
            "Breadth-First Search",
            "Graph",
            "Heap (Priority Queue)",
            "Matrix",
            "Shortest Path"
        ],
        "url": "https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minimumTime(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar minimumTime = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minimumTime(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are n people, each person has a unique id between 0 and n-1. Given the arrays watchedVideos and friends, where watchedVideos[i] and friends[i] contain the list of watched videos and the list of friends respectively for the person with id = i.\nLevel 1 of videos are all watched videos by your\u00a0friends, level 2 of videos are all watched videos by the friends of your\u00a0friends and so on. In general, the level k of videos are all\u00a0watched videos by people\u00a0with the shortest path exactly equal\u00a0to\u00a0k with you. Given your\u00a0id and the level of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest.\u00a0\nExample 1:\nInput: watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1\nOutput: [\"B\",\"C\"] \nExplanation: \nYou have id = 0 (green color in the figure) and your friends are (yellow color in the figure):\nPerson with id = 1 -> watchedVideos = [\"C\"]\u00a0\nPerson with id = 2 -> watchedVideos = [\"B\",\"C\"]\u00a0\nThe frequencies of watchedVideos by your friends are:\u00a0\nB -> 1\u00a0\nC -> 2\nExample 2:\nInput: watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2\nOutput: [\"D\"]\nExplanation: \nYou have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).\nConstraints:\n\tn == watchedVideos.length ==\u00a0friends.length\n\t2 <= n\u00a0<= 100\n\t1 <=\u00a0watchedVideos[i].length <= 100\n\t1 <=\u00a0watchedVideos[i][j].length <= 8\n\t0 <= friends[i].length < n\n\t0 <= friends[i][j]\u00a0< n\n\t0 <= id < n\n\t1 <= level < n\n\tif\u00a0friends[i] contains j, then friends[j] contains i",
        "topics": [
            "Array",
            "Hash Table",
            "Breadth-First Search",
            "Graph",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/get-watched-videos-by-your-friends/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string[][]} watchedVideos\r\n * @param {number[][]} friends\r\n * @param {number} id\r\n * @param {number} level\r\n * @return {string[]}\r\n */\r\nvar watchedVideosByFriends = function(watchedVideos, friends, id, level) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.\nExample 1:\nInput: edges = [1,0,0,0,0,7,7,5]\nOutput: 7\nExplanation:\n- The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.\n- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.\n- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.\n- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.\nNode 7 has the highest edge score so return 7.\nExample 2:\nInput: edges = [2,0,0,2]\nOutput: 0\nExplanation:\n- The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.\n- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.\nNodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0.\nConstraints:\n\tn == edges.length\n\t2 <= n <= 10^5\n\t0 <= edges[i] < n\n\tedges[i] != i",
        "topics": [
            "Hash Table",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/node-with-highest-edge-score/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def edgeScore(self, edges: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} edges\r\n * @return {number}\r\n */\r\nvar edgeScore = function(edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int edgeScore(int[] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb.\nThe bombs are represented by a 0-indexed 2D integer array bombs where bombs[i] = [xi, yi, ri]. xi and yi denote the X-coordinate and Y-coordinate of the location of the i^th bomb, whereas ri denotes the radius of its range.\nYou may choose to detonate a single bomb. When a bomb is detonated, it will detonate all bombs that lie in its range. These bombs will further detonate the bombs that lie in their ranges.\nGiven the list of bombs, return the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb.\nExample 1:\nInput: bombs = [[2,1,3],[6,1,4]]\nOutput: 2\nExplanation:\nThe above figure shows the positions and ranges of the 2 bombs.\nIf we detonate the left bomb, the right bomb will not be affected.\nBut if we detonate the right bomb, both bombs will be detonated.\nSo the maximum bombs that can be detonated is max(1, 2) = 2.\nExample 2:\nInput: bombs = [[1,1,5],[10,10,5]]\nOutput: 1\nExplanation:\nDetonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.\nExample 3:\nInput: bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\nOutput: 5\nExplanation:\nThe best bomb to detonate is bomb 0 because:\n- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.\n- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.\n- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.\nThus all 5 bombs are detonated.\nConstraints:\n\t1 <= bombs.length\u00a0<= 100\n\tbombs[i].length == 3\n\t1 <= xi, yi, ri <= 10^5",
        "topics": [
            "Array",
            "Math",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Geometry"
        ],
        "url": "https://leetcode.com/problems/detonate-the-maximum-bombs/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} bombs\r\n * @return {number}\r\n */\r\nvar maximumDetonation = function(bombs) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximumDetonation(int[][] bombs) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer n. There is an undirected graph with n nodes, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nReturn the number of pairs of different nodes that are unreachable from each other.\nExample 1:\nInput: n = 3, edges = [[0,1],[0,2],[1,2]]\nOutput: 0\nExplanation: There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.\nExample 2:\nInput: n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]\nOutput: 14\nExplanation: There are 14 pairs of nodes that are unreachable from each other:\n[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].\nTherefore, we return 14.\nConstraints:\n\t1 <= n <= 10^5\n\t0 <= edges.length <= 2 * 10^5\n\tedges[i].length == 2\n\t0 <= ai, bi < n\n\tai != bi\n\tThere are no repeated edges.",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def countPairs(self, n: int, edges: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} edges\r\n * @return {number}\r\n */\r\nvar countPairs = function(n, edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long countPairs(int n, int[][] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course ai first if you want to take course bi.\n\tFor example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1.\nPrerequisites can also be indirect. If course a is a prerequisite of course b, and course b is a prerequisite of course c, then course a is a prerequisite of course c.\nYou are also given an array queries where queries[j] = [uj, vj]. For the j^th query, you should answer whether course uj is a prerequisite of course vj or not.\nReturn a boolean array answer, where answer[j] is the answer to the j^th query.\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]\nOutput: [false,true]\nExplanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0.\nCourse 0 is not a prerequisite of course 1, but the opposite is true.\nExample 2:\nInput: numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]\nOutput: [false,false]\nExplanation: There are no prerequisites, and each course is independent.\nExample 3:\nInput: numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]\nOutput: [true,true]\nConstraints:\n\t2 <= numCourses <= 100\n\t0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)\n\tprerequisites[i].length == 2\n\t0 <= ai, bi <= n - 1\n\tai != bi\n\tAll the pairs [ai, bi] are unique.\n\tThe prerequisites graph has no cycles.\n\t1 <= queries.length <= 10^4\n\t0 <= ui, vi <= n - 1\n\tui != vi",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "url": "https://leetcode.com/problems/course-schedule-iv/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} numCourses\r\n * @param {number[][]} prerequisites\r\n * @param {number[][]} queries\r\n * @return {boolean[]}\r\n */\r\nvar checkIfPrerequisite = function(numCourses, prerequisites, queries) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.\nExample 1:\nInput: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.\nExample 2:\nInput: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations.\nConstraints:\n\t1 <= equations.length <= 500\n\tequations[i].length == 4\n\tequations[i][0] is a lowercase letter.\n\tequations[i][1] is either '=' or '!'.\n\tequations[i][2] is '='.\n\tequations[i][3] is a lowercase letter.",
        "topics": [
            "Array",
            "String",
            "Union Find",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/satisfiability-of-equality-equations/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def equationsPossible(self, equations: List[str]) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string[]} equations\r\n * @return {boolean}\r\n */\r\nvar equationsPossible = function(equations) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean equationsPossible(String[] equations) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group.\nGiven the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way.\nExample 1:\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\nOutput: true\nExplanation: The first group has [1,4], and the second group has [2,3].\nExample 2:\nInput: n = 3, dislikes = [[1,2],[1,3],[2,3]]\nOutput: false\nExplanation: We need at least 3 groups to divide them. We cannot put them in two groups.\nConstraints:\n\t1 <= n <= 2000\n\t0 <= dislikes.length <= 10^4\n\tdislikes[i].length == 2\n\t1 <= ai < bi <= n\n\tAll the pairs of dislikes are unique.",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/possible-bipartition/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} dislikes\r\n * @return {boolean}\r\n */\r\nvar possibleBipartition = function(n, dislikes) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean possibleBipartition(int n, int[][] dislikes) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is a network of n servers, labeled from 0 to n - 1. You are given a 2D integer array edges, where edges[i] = [ui, vi] indicates there is a message channel between servers ui and vi, and they can pass any number of messages to each other directly in one second. You are also given a 0-indexed integer array patience of length n.\nAll servers are connected, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels.\nThe server labeled 0 is the master server. The rest are data servers. Each data server needs to send its message to the master server for processing and wait for a reply. Messages move between servers optimally, so every message takes the least amount of time to arrive at the master server. The master server will process all newly arrived messages instantly and send a reply to the originating server via the reversed path the message had gone through.\nAt the beginning of second 0, each data server sends its message to be processed. Starting from second 1, at the beginning of every second, each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server:\n\tIf it has not, it will resend the message periodically. The data server i will resend the message every patience[i] second(s), i.e., the data server i will resend the message if patience[i] second(s) have elapsed since the last time the message was sent from this server.\n\tOtherwise, no more resending will occur from this server.\nThe network becomes idle when there are no messages passing between servers or arriving at servers.\nReturn the earliest second starting from which the network becomes idle.\nExample 1:\nInput: edges = [[0,1],[1,2]], patience = [0,2,1]\nOutput: 8\nExplanation:\nAt (the beginning of) second 0,\n- Data server 1 sends its message (denoted 1A) to the master server.\n- Data server 2 sends its message (denoted 2A) to the master server.\nAt second 1,\n- Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.\n- Server 1 has not received any reply. 1 second (1 < patience[1] = 2) elapsed since this server has sent the message, therefore it does not resend the message.\n- Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).\nAt second 2,\n- The reply 1A arrives at server 1. No more resending will occur from server 1.\n- Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.\n- Server 2 resends the message (denoted 2C).\n...\nAt second 4,\n- The reply 2A arrives at server 2. No more resending will occur from server 2.\n...\nAt second 7, reply 2D arrives at server 2.\nStarting from the beginning of the second 8, there are no messages passing between servers or arriving at servers.\nThis is the time when the network becomes idle.\nExample 2:\nInput: edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]\nOutput: 3\nExplanation: Data servers 1 and 2 receive a reply back at the beginning of second 2.\nFrom the beginning of the second 3, the network becomes idle.\nConstraints:\n\tn == patience.length\n\t2 <= n <= 10^5\n\tpatience[0] == 0\n\t1 <= patience[i] <= 10^5 for 1 <= i < n\n\t1 <= edges.length <= min(10^5, n * (n - 1) / 2)\n\tedges[i].length == 2\n\t0 <= ui, vi < n\n\tui != vi\n\tThere are no duplicate edges.\n\tEach server can directly or indirectly reach another server.",
        "topics": [
            "Array",
            "Breadth-First Search",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/the-time-when-the-network-becomes-idle/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} edges\r\n * @param {number[]} patience\r\n * @return {number}\r\n */\r\nvar networkBecomesIdle = function(edges, patience) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.\nIf the town judge exists, then:\n\tThe town judge trusts nobody.\n\tEverybody (except for the town judge) trusts the town judge.\n\tThere is exactly one person that satisfies properties 1 and 2.\nYou are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.\nReturn the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.\nExample 1:\nInput: n = 2, trust = [[1,2]]\nOutput: 2\nExample 2:\nInput: n = 3, trust = [[1,3],[2,3]]\nOutput: 3\nExample 3:\nInput: n = 3, trust = [[1,3],[2,3],[3,1]]\nOutput: -1\nConstraints:\n\t1 <= n <= 1000\n\t0 <= trust.length <= 10^4\n\ttrust[i].length == 2\n\tAll the pairs of trust are unique.\n\tai != bi\n\t1 <= ai, bi <= n",
        "topics": [
            "Array",
            "Hash Table",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/find-the-town-judge/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} trust\r\n * @return {number}\r\n */\r\nvar findJudge = function(n, trust) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int findJudge(int n, int[][] trust) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.\nYou are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.\nExample 1:\nInput: edges = [[1,2],[2,3],[4,2]]\nOutput: 2\nExplanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center.\nExample 2:\nInput: edges = [[1,2],[5,1],[1,3],[1,4]]\nOutput: 1\nConstraints:\n\t3 <= n <= 10^5\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t1 <= ui, vi <= n\n\tui != vi\n\tThe given edges represent a valid star graph.",
        "topics": [
            "Graph"
        ],
        "url": "https://leetcode.com/problems/find-center-of-star-graph/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def findCenter(self, edges: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} edges\r\n * @return {number}\r\n */\r\nvar findCenter = function(edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int findCenter(int[][] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer array nums and an integer k.\nSplit the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\nLet trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\n\tFor example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\nThe importance value of a subarray is k + trimmed(subarray).length.\n\tFor example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\nReturn the minimum possible cost of a split of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nInput: nums = [1,2,1,2,1,3,3], k = 2\nOutput: 8\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.\nExample 2:\nInput: nums = [1,2,1,2,1], k = 2\nOutput: 6\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.\nExample 3:\nInput: nums = [1,2,1,2,1], k = 5\nOutput: 10\nExplanation: We split nums to have one subarray: [1,2,1,2,1].\nThe importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits.\nConstraints:\n\t1 <= nums.length <= 1000\n\t0 <= nums[i] < nums.length\n\t1 <= k <= 10^9\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0;\u00a0\n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}",
        "topics": [
            "Array",
            "Hash Table",
            "Dynamic Programming",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/minimum-cost-to-split-an-array/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minCost(self, nums: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar minCost = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minCost(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.\nExample 1:\nInput: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].\nWe can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.\nExample 2:\nInput: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].\nThe total cost needed here is 10, which is the minimum possible.\nExample 3:\nInput: nums1 = [1,2,2], nums2 = [1,2,2]\nOutput: -1\nExplanation: \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1.\nConstraints:\n\tn == nums1.length == nums2.length\n\t1 <= n <= 10^5\n\t1 <= nums1[i], nums2[i] <= n",
        "topics": [
            "Array",
            "Hash Table",
            "Greedy",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/minimum-total-cost-to-make-arrays-unequal/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums1\r\n * @param {number[]} nums2\r\n * @return {number}\r\n */\r\nvar minimumTotalCost = function(nums1, nums2) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long minimumTotalCost(int[] nums1, int[] nums2) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an array words of size n consisting of non-empty strings.\nWe define the score of a string word as the number of strings words[i] such that word is a prefix of words[i].\n\tFor example, if words = [\"a\", \"ab\", \"abc\", \"cab\"], then the score of \"ab\" is 2, since \"ab\" is a prefix of both \"ab\" and \"abc\".\nReturn an array answer of size n where answer[i] is the sum of scores of every non-empty prefix of words[i].\nNote that a string is considered as a prefix of itself.\nExample 1:\nInput: words = [\"abc\",\"ab\",\"bc\",\"b\"]\nOutput: [5,4,3,2]\nExplanation: The answer for each string is the following:\n- \"abc\" has 3 prefixes: \"a\", \"ab\", and \"abc\".\n- There are 2 strings with the prefix \"a\", 2 strings with the prefix \"ab\", and 1 string with the prefix \"abc\".\nThe total is answer[0] = 2 + 2 + 1 = 5.\n- \"ab\" has 2 prefixes: \"a\" and \"ab\".\n- There are 2 strings with the prefix \"a\", and 2 strings with the prefix \"ab\".\nThe total is answer[1] = 2 + 2 = 4.\n- \"bc\" has 2 prefixes: \"b\" and \"bc\".\n- There are 2 strings with the prefix \"b\", and 1 string with the prefix \"bc\".\nThe total is answer[2] = 2 + 1 = 3.\n- \"b\" has 1 prefix: \"b\".\n- There are 2 strings with the prefix \"b\".\nThe total is answer[3] = 2.\nExample 2:\nInput: words = [\"abcd\"]\nOutput: [4]\nExplanation:\n\"abcd\" has 4 prefixes: \"a\", \"ab\", \"abc\", and \"abcd\".\nEach prefix has a score of one, so the total is answer[0] = 1 + 1 + 1 + 1 = 4.\nConstraints:\n\t1 <= words.length <= 1000\n\t1 <= words[i].length <= 1000\n\twords[i] consists of lowercase English letters.",
        "topics": [
            "Array",
            "String",
            "Trie",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/sum-of-prefix-scores-of-strings/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string[]} words\r\n * @return {number[]}\r\n */\r\nvar sumPrefixScores = function(words) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] sumPrefixScores(String[] words) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1.\nYou are given a string colors where colors[i] is a lowercase English letter representing the color of the i^th node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj.\nA valid path in the graph is a sequence of nodes x1 -> x2 -> x3 -> ... -> xk such that there is a directed edge from xi to xi+1 for every 1 <= i < k. The color value of the path is the number of nodes that are colored the most frequently occurring color along that path.\nReturn the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle.\nExample 1:\nInput: colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]\nOutput: 3\nExplanation: The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored \"a\" (red in the above image).\nExample 2:\nInput: colors = \"a\", edges = [[0,0]]\nOutput: -1\nExplanation: There is a cycle from 0 to 0.\nConstraints:\n\tn == colors.length\n\tm == edges.length\n\t1 <= n <= 10^5\n\t0 <= m <= 10^5\n\tcolors consists of lowercase English letters.\n\t0 <= aj, bj\u00a0< n",
        "topics": [
            "Hash Table",
            "Dynamic Programming",
            "Graph",
            "Topological Sort",
            "Memoization",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/largest-color-value-in-a-directed-graph/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:",
        "givenJsCode": "/**\r\n * @param {string} colors\r\n * @param {number[][]} edges\r\n * @return {number}\r\n */\r\nvar largestPathValue = function(colors, edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int largestPathValue(String colors, int[][] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a string s of length n, and an integer k. You are tasked to find the longest subsequence repeated k times in string s.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nA subsequence seq is repeated k times in the string s if seq * k is a subsequence of s, where seq * k represents a string constructed by concatenating seq k times.\n\tFor example, \"bba\" is repeated 2 times in the string \"bababcba\", because the string \"bbabba\", constructed by concatenating \"bba\" 2 times, is a subsequence of the string \"bababcba\".\nReturn the longest subsequence repeated k times in string s. If multiple such subsequences are found, return the lexicographically largest one. If there is no such subsequence, return an empty string.\nExample 1:\nInput: s = \"letsleetcode\", k = 2\nOutput: \"let\"\nExplanation: There are two longest subsequences repeated 2 times: \"let\" and \"ete\".\n\"let\" is the lexicographically largest one.\nExample 2:\nInput: s = \"bb\", k = 2\nOutput: \"b\"\nExplanation: The longest subsequence repeated 2 times is \"b\".\nExample 3:\nInput: s = \"ab\", k = 2\nOutput: \"\"\nExplanation: There is no subsequence repeated 2 times. Empty string is returned.\nConstraints:\n\tn == s.length\n\t2 <= n, k <= 2000\n\t2 <= n < k * 8\n\ts consists of lowercase English letters.",
        "topics": [
            "String",
            "Backtracking",
            "Greedy",
            "Counting",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/longest-subsequence-repeated-k-times/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @param {number} k\r\n * @return {string}\r\n */\r\nvar longestSubsequenceRepeatedK = function(s, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String longestSubsequenceRepeatedK(String s, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "A magician has various spells.\nYou are given an array power, where each element represents the damage of a spell. Multiple spells can have the same damage value.\nIt is a known fact that if a magician decides to cast a spell with a damage of power[i], they cannot cast any spell with a damage of power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2.\nEach spell can be cast only once.\nReturn the maximum possible total damage that a magician can cast.\nExample 1:\nInput: power = [1,1,3,4]\nOutput: 6\nExplanation:\nThe maximum possible damage of 6 is produced by casting spells 0, 1, 3 with damage 1, 1, 4.\nExample 2:\nInput: power = [7,1,6,6]\nOutput: 13\nExplanation:\nThe maximum possible damage of 13 is produced by casting spells 1, 2, 3 with damage 1, 6, 6.\nConstraints:\n\t1 <= power.length <= 10^5\n\t1 <= power[i] <= 10^9",
        "topics": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Dynamic Programming",
            "Sorting",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/maximum-total-damage-with-spell-casting/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximumTotalDamage(self, power: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} power\r\n * @return {number}\r\n */\r\nvar maximumTotalDamage = function(power) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long maximumTotalDamage(int[] power) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given two 0-indexed strings word1 and word2.\nA move consists of choosing two indices i and j such that 0 <= i < word1.length and 0 <= j < word2.length and swapping word1[i] with word2[j].\nReturn true if it is possible to get the number of distinct characters in word1 and word2 to be equal with exactly one move. Return false otherwise.\nExample 1:\nInput: word1 = \"ac\", word2 = \"b\"\nOutput: false\nExplanation: Any pair of swaps would yield two distinct characters in the first string, and one in the second string.\nExample 2:\nInput: word1 = \"abcc\", word2 = \"aab\"\nOutput: true\nExplanation: We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = \"abac\" and word2 = \"cab\", which both have 3 distinct characters.\nExample 3:\nInput: word1 = \"abcde\", word2 = \"fghij\"\nOutput: true\nExplanation: Both resulting strings will have 5 distinct characters, regardless of which indices we swap.\nConstraints:\n\t1 <= word1.length, word2.length <= 10^5\n\tword1 and word2 consist of only lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/make-number-of-distinct-characters-equal/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def isItPossible(self, word1: str, word2: str) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} word1\r\n * @param {string} word2\r\n * @return {boolean}\r\n */\r\nvar isItPossible = function(word1, word2) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean isItPossible(String word1, String word2) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array stones, where stones[i] is the value of the i^th stone.\nAlice and Bob take turns, with Alice starting first. On each turn, the player may remove any stone from stones. The player who removes a stone loses if the sum of the values of all removed stones is divisible by 3. Bob will win automatically if there are no remaining stones (even if it is Alice's turn).\nAssuming both players play optimally, return true if Alice wins and false if Bob wins.\nExample 1:\nInput: stones = [2,1]\nOutput: true\nExplanation:\u00a0The game will be played as follows:\n- Turn 1: Alice can remove either stone.\n- Turn 2: Bob removes the remaining stone. \nThe sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game.\nExample 2:\nInput: stones = [2]\nOutput: false\nExplanation:\u00a0Alice will remove the only stone, and the sum of the values on the removed stones is 2. \nSince all the stones are removed and the sum of values is not divisible by 3, Bob wins the game.\nExample 3:\nInput: stones = [5,1,2,4,3]\nOutput: false\nExplanation: Bob will always win. One possible way for Bob to win is shown below:\n- Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.\n- Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.\n- Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.\n- Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.\n- Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.\nAlice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.\nConstraints:\n\t1 <= stones.length <= 10^5\n\t1 <= stones[i] <= 10^4",
        "topics": [
            "Array",
            "Math",
            "Greedy",
            "Counting",
            "Game Theory"
        ],
        "url": "https://leetcode.com/problems/stone-game-ix/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def stoneGameIX(self, stones: List[int]) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} stones\r\n * @return {boolean}\r\n */\r\nvar stoneGameIX = function(stones) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean stoneGameIX(int[] stones) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed array nums consisting of n positive integers.\nThe array nums is called alternating if:\n\tnums[i - 2] == nums[i], where 2 <= i <= n - 1.\n\tnums[i - 1] != nums[i], where 1 <= i <= n - 1.\nIn one operation, you can choose an index i and change nums[i] into any positive integer.\nReturn the minimum number of operations required to make the array alternating.\nExample 1:\nInput: nums = [3,1,3,2,4,3]\nOutput: 3\nExplanation:\nOne way to make the array alternating is by converting it to [3,1,3,1,3,1].\nThe number of operations required in this case is 3.\nIt can be proven that it is not possible to make the array alternating in less than 3 operations. \nExample 2:\nInput: nums = [1,2,2,2,2]\nOutput: 2\nExplanation:\nOne way to make the array alternating is by converting it to [1,2,1,2,1].\nThe number of operations required in this case is 2.\nNote that the array cannot be converted to [2,2,2,2,2] because in this case nums[0] == nums[1] which violates the conditions of an alternating array.\nConstraints:\n\t1 <= nums.length <= 10^5\n\t1 <= nums[i] <= 10^5",
        "topics": [
            "Array",
            "Hash Table",
            "Greedy",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minimumOperations(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar minimumOperations = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minimumOperations(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a string s that consists of lowercase English letters.\nA string is called special if it is made up of only a single character. For example, the string \"abc\" is not special, whereas the strings \"ddd\", \"zz\", and \"f\" are special.\nReturn the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.\nA substring is a contiguous non-empty sequence of characters within a string.\nExample 1:\nInput: s = \"aaaa\"\nOutput: 2\nExplanation: The longest special substring which occurs thrice is \"aa\": substrings \"aaaa\", \"aaaa\", and \"aaaa\".\nIt can be shown that the maximum length achievable is 2.\nExample 2:\nInput: s = \"abcdef\"\nOutput: -1\nExplanation: There exists no special substring which occurs at least thrice. Hence return -1.\nExample 3:\nInput: s = \"abcaba\"\nOutput: 1\nExplanation: The longest special substring which occurs thrice is \"a\": substrings \"abcaba\", \"abcaba\", and \"abcaba\".\nIt can be shown that the maximum length achievable is 1.\nConstraints:\n\t3 <= s.length <= 5 * 10^5\n\ts consists of only lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Binary Search",
            "Sliding Window",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-ii/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximumLength(self, s: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar maximumLength = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximumLength(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a string num consisting of digits only.\nReturn the largest palindromic integer (in the form of a string) that can be formed using digits taken from num. It should not contain leading zeroes.\nNotes:\n\tYou do not need to use all the digits of num, but you must use at least one digit.\n\tThe digits can be reordered.\nExample 1:\nInput: num = \"444947137\"\nOutput: \"7449447\"\nExplanation: \nUse the digits \"4449477\" from \"444947137\" to form the palindromic integer \"7449447\".\nIt can be shown that \"7449447\" is the largest palindromic integer that can be formed.\nExample 2:\nInput: num = \"00009\"\nOutput: \"9\"\nExplanation: \nIt can be shown that \"9\" is the largest palindromic integer that can be formed.\nNote that the integer returned should not contain leading zeroes.\nConstraints:\n\t1 <= num.length <= 10^5\n\tnum consists of digits.",
        "topics": [
            "Hash Table",
            "String",
            "Greedy",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/largest-palindromic-number/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def largestPalindromic(self, num: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} num\r\n * @return {string}\r\n */\r\nvar largestPalindromic = function(num) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String largestPalindromic(String num) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given two strings a and b that consist of lowercase letters. In one operation, you can change any character in a or b to any lowercase letter.\nYour goal is to satisfy one of the following three conditions:\n\tEvery letter in a is strictly less than every letter in b in the alphabet.\n\tEvery letter in b is strictly less than every letter in a in the alphabet.\n\tBoth a and b consist of only one distinct letter.\nReturn the minimum number of operations needed to achieve your goal.\nExample 1:\nInput: a = \"aba\", b = \"caa\"\nOutput: 2\nExplanation: Consider the best way to make each condition true:\n1) Change b to \"ccc\" in 2 operations, then every letter in a is less than every letter in b.\n2) Change a to \"bbb\" and b to \"aaa\" in 3 operations, then every letter in b is less than every letter in a.\n3) Change a to \"aaa\" and b to \"aaa\" in 2 operations, then a and b consist of one distinct letter.\nThe best way was done in 2 operations (either condition 1 or condition 3).\nExample 2:\nInput: a = \"dabadd\", b = \"cda\"\nOutput: 3\nExplanation: The best way is to make condition 1 true by changing b to \"eee\".\nConstraints:\n\t1 <= a.length, b.length <= 10^5\n\ta and b consist only of lowercase letters.",
        "topics": [
            "Hash Table",
            "String",
            "Counting",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} a\r\n * @param {string} b\r\n * @return {number}\r\n */\r\nvar minCharacters = function(a, b) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minCharacters(String a, String b) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an array of integers arr of even length n and an integer k.\nWe want to divide the array into exactly n / 2 pairs such that the sum of each pair is divisible by k.\nReturn true If you can find a way to do that or false otherwise.\nExample 1:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nExplanation: Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10).\nExample 2:\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nExplanation: Pairs are (1,6),(2,5) and(3,4).\nExample 3:\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nExplanation: You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10.\nConstraints:\n\tarr.length == n\n\t1 <= n <= 10^5\n\tn is even.\n\t-10^9 <= arr[i] <= 10^9\n\t1 <= k <= 10^5",
        "topics": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def canArrange(self, arr: List[int], k: int) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} arr\r\n * @param {number} k\r\n * @return {boolean}\r\n */\r\nvar canArrange = function(arr, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean canArrange(int[] arr, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed array nums consisting of positive integers, representing targets on a number line. You are also given an integer space.\nYou have a machine which can destroy targets. Seeding the machine with some nums[i] allows it to destroy all targets with values that can be represented as nums[i] + c * space, where c is any non-negative integer. You want to destroy the maximum number of targets in nums.\nReturn the minimum value of nums[i] you can seed the machine with to destroy the maximum number of targets.\nExample 1:\nInput: nums = [3,7,8,1,1,5], space = 2\nOutput: 1\nExplanation: If we seed the machine with nums[3], then we destroy all targets equal to 1,3,5,7,9,... \nIn this case, we would destroy 5 total targets (all except for nums[2]). \nIt is impossible to destroy more than 5 targets, so we return nums[3].\nExample 2:\nInput: nums = [1,3,5,2,4,6], space = 2\nOutput: 1\nExplanation: Seeding the machine with nums[0], or nums[3] destroys 3 targets. \nIt is not possible to destroy more than 3 targets.\nSince nums[0] is the minimal integer that can destroy 3 targets, we return 1.\nExample 3:\nInput: nums = [6,2,5], space = 100\nOutput: 2\nExplanation: Whatever initial seed we select, we can only destroy 1 target. The minimal seed is nums[1].\nConstraints:\n\t1 <= nums.length <= 10^5\n\t1 <= nums[i] <= 10^9\n\t1 <= space <=\u00a010^9",
        "topics": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/destroy-sequential-targets/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def destroyTargets(self, nums: List[int], space: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} space\r\n * @return {number}\r\n */\r\nvar destroyTargets = function(nums, space) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int destroyTargets(int[] nums, int space) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a string s, you need to partition it into one or more balanced substrings. For example, if s == \"ababcc\" then (\"abab\", \"c\", \"c\"), (\"ab\", \"abc\", \"c\"), and (\"ababcc\") are all valid partitions, but (\"a\", \"bab\", \"cc\"), (\"aba\", \"bc\", \"c\"), and (\"ab\", \"abcc\") are not. The unbalanced substrings are bolded.\nReturn the minimum number of substrings that you can partition s into.\nNote: A balanced string is a string where each character in the string occurs the same number of times.\nExample 1:\nInput: s = \"fabccddg\"\nOutput: 3\nExplanation:\nWe can partition the string s into 3 substrings in one of the following ways: (\"fab, \"ccdd\", \"g\"), or (\"fabc\", \"cd\", \"dg\").\nExample 2:\nInput: s = \"abababaccddb\"\nOutput: 2\nExplanation:\nWe can partition the string s into 2 substrings like so: (\"abab\", \"abaccddb\").\nConstraints:\n\t1 <= s.length <= 1000\n\ts consists only of English lowercase letters.",
        "topics": [
            "Hash Table",
            "String",
            "Dynamic Programming",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/minimum-substring-partition-of-equal-character-frequency/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minimumSubstringsInPartition(self, s: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar minimumSubstringsInPartition = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minimumSubstringsInPartition(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\nReturn true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.\nExample 1:\nInput: s1 = \"bank\", s2 = \"kanb\"\nOutput: true\nExplanation: For example, swap the first character with the last character of s2 to make \"bank\".\nExample 2:\nInput: s1 = \"attack\", s2 = \"defend\"\nOutput: false\nExplanation: It is impossible to make them equal with one string swap.\nExample 3:\nInput: s1 = \"kelb\", s2 = \"kelb\"\nOutput: true\nExplanation: The two strings are already equal, so no string swap operation is required.\nConstraints:\n\t1 <= s1.length, s2.length <= 100\n\ts1.length == s2.length\n\ts1 and s2 consist of only lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s1\r\n * @param {string} s2\r\n * @return {boolean}\r\n */\r\nvar areAlmostEqual = function(s1, s2) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean areAlmostEqual(String s1, String s2) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino.\nReturn the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].\nExample 1:\nInput: dominoes = [[1,2],[2,1],[3,4],[5,6]]\nOutput: 1\nExample 2:\nInput: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]\nOutput: 3\nConstraints:\n\t1 <= dominoes.length <= 4 * 10^4\n\tdominoes[i].length == 2\n\t1 <= dominoes[i][j] <= 9",
        "topics": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} dominoes\r\n * @return {number}\r\n */\r\nvar numEquivDominoPairs = function(dominoes) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numEquivDominoPairs(int[][] dominoes) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array nums. A pair of indices i, j where 0 <=\u00a0i < j < nums.length is called beautiful if the first digit of nums[i] and the last digit of nums[j] are coprime.\nReturn the total number of beautiful pairs in nums.\nTwo integers x and y are coprime if there is no integer greater than 1 that divides both of them. In other words, x and y are coprime if gcd(x, y) == 1, where gcd(x, y) is the greatest common divisor of x and y.\nExample 1:\nInput: nums = [2,5,1,4]\nOutput: 5\nExplanation: There are 5 beautiful pairs in nums:\nWhen i = 0 and j = 1: the first digit of nums[0] is 2, and the last digit of nums[1] is 5. We can confirm that 2 and 5 are coprime, since gcd(2,5) == 1.\nWhen i = 0 and j = 2: the first digit of nums[0] is 2, and the last digit of nums[2] is 1. Indeed, gcd(2,1) == 1.\nWhen i = 1 and j = 2: the first digit of nums[1] is 5, and the last digit of nums[2] is 1. Indeed, gcd(5,1) == 1.\nWhen i = 1 and j = 3: the first digit of nums[1] is 5, and the last digit of nums[3] is 4. Indeed, gcd(5,4) == 1.\nWhen i = 2 and j = 3: the first digit of nums[2] is 1, and the last digit of nums[3] is 4. Indeed, gcd(1,4) == 1.\nThus, we return 5.\nExample 2:\nInput: nums = [11,21,12]\nOutput: 2\nExplanation: There are 2 beautiful pairs:\nWhen i = 0 and j = 1: the first digit of nums[0] is 1, and the last digit of nums[1] is 1. Indeed, gcd(1,1) == 1.\nWhen i = 0 and j = 2: the first digit of nums[0] is 1, and the last digit of nums[2] is 2. Indeed, gcd(1,2) == 1.\nThus, we return 2.\nConstraints:\n\t2 <= nums.length <= 100\n\t1 <= nums[i] <= 9999\n\tnums[i] % 10 != 0",
        "topics": [
            "Array",
            "Hash Table",
            "Math",
            "Counting",
            "Number Theory"
        ],
        "url": "https://leetcode.com/problems/number-of-beautiful-pairs/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def countBeautifulPairs(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar countBeautifulPairs = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int countBeautifulPairs(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.\nExample 1:\nInput: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.\nExample 2:\nInput: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.\nExample 3:\nInput: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element.\nConstraints:\n\t1 <= nums.length <= 2000\n\t0 <= nums[i] <= 10^5",
        "topics": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/most-frequent-even-element/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def mostFrequentEven(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar mostFrequentEven = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int mostFrequentEven(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\nGiven an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\nA subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\nInput: nums = [1,3,2,2,5,2,3,7]\nOutput: 5\nExplanation: The longest harmonious subsequence is [3,2,2,2,3].\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: 2\nExample 3:\nInput: nums = [1,1,1,1]\nOutput: 0\nConstraints:\n\t1 <= nums.length <= 2 * 10^4\n\t-10^9 <= nums[i] <= 10^9",
        "topics": [
            "Array",
            "Hash Table",
            "Sliding Window",
            "Sorting",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/longest-harmonious-subsequence/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def findLHS(self, nums: List[int]) -> int:",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar findLHS = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int findLHS(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1.\nA subarray is a contiguous part of an array.\nExample 1:\nInput: nums = [1], k = 1\nOutput: 1\nExample 2:\nInput: nums = [1,2], k = 4\nOutput: -1\nExample 3:\nInput: nums = [2,-1,2], k = 3\nOutput: 3\nConstraints:\n\t1 <= nums.length <= 10^5\n\t-10^5 <= nums[i] <= 10^5\n\t1 <= k <= 10^9",
        "topics": [
            "Array",
            "Binary Search",
            "Queue",
            "Sliding Window",
            "Heap (Priority Queue)",
            "Prefix Sum",
            "Monotonic Queue"
        ],
        "url": "https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def shortestSubarray(self, nums: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar shortestSubarray = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int shortestSubarray(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a string word and an integer k.\nA substring s of word is complete if:\n\tEach character in s occurs exactly k times.\n\tThe difference between two adjacent characters is at most 2. That is, for any two adjacent characters c1 and c2 in s, the absolute difference in their positions in the alphabet is at most 2.\nReturn the number of complete substrings of word.\nA substring is a non-empty contiguous sequence of characters in a string.\nExample 1:\nInput: word = \"igigee\", k = 2\nOutput: 3\nExplanation: The complete substrings where each character appears exactly twice and the difference between adjacent characters is at most 2 are: igigee, igigee, igigee.\nExample 2:\nInput: word = \"aaabbbccc\", k = 3\nOutput: 6\nExplanation: The complete substrings where each character appears exactly three times and the difference between adjacent characters is at most 2 are: aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc.\nConstraints:\n\t1 <= word.length <= 10^5\n\tword consists only of lowercase English letters.\n\t1 <= k <= word.length",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/count-complete-substrings/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} word\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar countCompleteSubstrings = function(word, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int countCompleteSubstrings(String word, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer array nums. The uniqueness array of nums is the sorted array that contains the number of distinct elements of all the subarrays of nums. In other words, it is a sorted array consisting of distinct(nums[i..j]), for all 0 <= i <= j < nums.length.\nHere, distinct(nums[i..j]) denotes the number of distinct elements in the subarray that starts at index i and ends at index j.\nReturn the median of the uniqueness array of nums.\nNote that the median of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the smaller of the two values is taken.\nExample 1:\nInput: nums = [1,2,3]\nOutput: 1\nExplanation:\nThe uniqueness array of nums is [distinct(nums[0..0]), distinct(nums[1..1]), distinct(nums[2..2]), distinct(nums[0..1]), distinct(nums[1..2]), distinct(nums[0..2])] which is equal to [1, 1, 1, 2, 2, 3]. The uniqueness array has a median of 1. Therefore, the answer is 1.\nExample 2:\nInput: nums = [3,4,3,4,5]\nOutput: 2\nExplanation:\nThe uniqueness array of nums is [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]. The uniqueness array has a median of 2. Therefore, the answer is 2.\nExample 3:\nInput: nums = [4,3,5,4]\nOutput: 2\nExplanation:\nThe uniqueness array of nums is [1, 1, 1, 1, 2, 2, 2, 3, 3, 3]. The uniqueness array has a median of 2. Therefore, the answer is 2.\nConstraints:\n\t1 <= nums.length <= 10^5\n\t1 <= nums[i] <= 10^5",
        "topics": [
            "Array",
            "Hash Table",
            "Binary Search",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/find-the-median-of-the-uniqueness-array/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def medianOfUniquenessArray(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar medianOfUniquenessArray = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int medianOfUniquenessArray(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition:\n\t|x - y| <= min(x, y)\nYou need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array.\nReturn the maximum XOR value out of all possible strong pairs in the array nums.\nNote that you can pick the same integer twice to form a pair.\nExample 1:\nInput: nums = [1,2,3,4,5]\nOutput: 7\nExplanation: There are 11 strong pairs in the array nums: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).\nThe maximum XOR possible from these pairs is 3 XOR 4 = 7.\nExample 2:\nInput: nums = [10,100]\nOutput: 0\nExplanation: There are 2 strong pairs in the array nums: (10, 10) and (100, 100).\nThe maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.\nExample 3:\nInput: nums = [500,520,2500,3000]\nOutput: 1020\nExplanation: There are 6 strong pairs in the array nums: (500, 500), (500, 520), (520, 520), (2500, 2500), (2500, 3000) and (3000, 3000).\nThe maximum XOR possible from these pairs is 500 XOR 520 = 1020 since the only other non-zero XOR value is 2500 XOR 3000 = 636.\nConstraints:\n\t1 <= nums.length <= 5 * 10^4\n\t1 <= nums[i] <= 2^20 - 1",
        "topics": [
            "Array",
            "Hash Table",
            "Bit Manipulation",
            "Trie",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/maximum-strong-pair-xor-ii/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maximumStrongPairXor = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximumStrongPairXor(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times.\u00a0The occurrences\u00a0may overlap.\nReturn any duplicated\u00a0substring that has the longest possible length.\u00a0If s does not have a duplicated substring, the answer is \"\".\nExample 1:\nInput: s = \"banana\"\nOutput: \"ana\"\nExample 2:\nInput: s = \"abcd\"\nOutput: \"\"\nConstraints:\n\t2 <= s.length <= 3 * 10^4\n\ts consists of lowercase English letters.",
        "topics": [
            "String",
            "Binary Search",
            "Sliding Window",
            "Rolling Hash",
            "Suffix Array",
            "Hash Function"
        ],
        "url": "https://leetcode.com/problems/longest-duplicate-substring/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def longestDupSubstring(self, s: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar longestDupSubstring = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String longestDupSubstring(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed array nums and an integer target.\nA 0-indexed array infinite_nums is generated by infinitely appending the elements of nums to itself.\nReturn the length of the shortest subarray of the array infinite_nums with a sum equal to target. If there is no such subarray return -1.\nExample 1:\nInput: nums = [1,2,3], target = 5\nOutput: 2\nExplanation: In this example infinite_nums = [1,2,3,1,2,3,1,2,...].\nThe subarray in the range [1,2], has the sum equal to target = 5 and length = 2.\nIt can be proven that 2 is the shortest length of a subarray with sum equal to target = 5.\nExample 2:\nInput: nums = [1,1,1,2,3], target = 4\nOutput: 2\nExplanation: In this example infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].\nThe subarray in the range [4,5], has the sum equal to target = 4 and length = 2.\nIt can be proven that 2 is the shortest length of a subarray with sum equal to target = 4.\nExample 3:\nInput: nums = [2,4,6,8], target = 3\nOutput: -1\nExplanation: In this example infinite_nums = [2,4,6,8,2,4,6,8,...].\nIt can be proven that there is no subarray with sum equal to target = 3.\nConstraints:\n\t1 <= nums.length <= 10^5\n\t1 <= nums[i] <= 10^5\n\t1 <= target <= 10^9",
        "topics": [
            "Array",
            "Hash Table",
            "Sliding Window",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/minimum-size-subarray-in-infinite-array/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minSizeSubarray(self, nums: List[int], target: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar minSizeSubarray = function(nums, target) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minSizeSubarray(int[] nums, int target) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer n denoting the total number of servers and a 2D 0-indexed integer array logs, where logs[i] = [server_id, time] denotes that the server with id server_id received a request at time time.\nYou are also given an integer x and a 0-indexed integer array queries.\nReturn a 0-indexed integer array arr of length queries.length where arr[i] represents the number of servers that did not receive any requests during the time interval [queries[i] - x, queries[i]].\nNote that the time intervals are inclusive.\nExample 1:\nInput: n = 3, logs = [[1,3],[2,6],[1,5]], x = 5, queries = [10,11]\nOutput: [1,2]\nExplanation: \nFor queries[0]: The servers with ids 1 and 2 get requests in the duration of [5, 10]. Hence, only server 3 gets zero requests.\nFor queries[1]: Only the server with id 2 gets a request in duration of [6,11]. Hence, the servers with ids 1 and 3 are the only servers that do not receive any requests during that time period.\nExample 2:\nInput: n = 3, logs = [[2,4],[2,1],[1,2],[3,1]], x = 2, queries = [3,4]\nOutput: [0,1]\nExplanation: \nFor queries[0]: All servers get at least one request in the duration of [1, 3].\nFor queries[1]: Only server with id 3 gets no request in the duration [2,4].\nConstraints:\n\t1 <= n <= 10^5\n\t1 <= logs.length <= 10^5\n\t1 <= queries.length <= 10^5\n\tlogs[i].length == 2\n\t1 <= logs[i][0] <= n\n\t1 <= logs[i][1] <= 10^6\n\t1 <= x <= 10^5\n\tx <\u00a0queries[i]\u00a0<= 10^6",
        "topics": [
            "Array",
            "Hash Table",
            "Sliding Window",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/count-zero-request-servers/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} logs\r\n * @param {number} x\r\n * @param {number[]} queries\r\n * @return {number[]}\r\n */\r\nvar countServers = function(n, logs, x, queries) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] countServers(int n, int[][] logs, int x, int[] queries) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are some prizes on the X-axis. You are given an integer array prizePositions that is sorted in non-decreasing order, where prizePositions[i] is the position of the i^th prize. There could be different prizes at the same position on the line. You are also given an integer k.\nYou are allowed to select two segments with integer endpoints. The length of each segment must be k. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.\n\tFor example if k = 2, you can choose segments [1, 3] and [2, 4], and you will win any prize i that satisfies 1 <= prizePositions[i] <= 3 or 2 <= prizePositions[i] <= 4.\nReturn the maximum number of prizes you can win if you choose the two segments optimally.\nExample 1:\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\nExplanation: In this example, you can win all 7 prizes by selecting two segments [1, 3] and [3, 5].\nExample 2:\nInput: prizePositions = [1,2,3,4], k = 0\nOutput: 2\nExplanation: For this example, one choice for the segments is [3, 3] and [4, 4], and you will be able to get 2 prizes. \nConstraints:\n\t1 <= prizePositions.length <= 10^5\n\t1 <= prizePositions[i] <= 10^9\n\t0 <= k <= 10^9 \n\tprizePositions is sorted in non-decreasing order.\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}",
        "topics": [
            "Array",
            "Binary Search",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/maximize-win-from-two-segments/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} prizePositions\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar maximizeWin = function(prizePositions, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximizeWin(int[] prizePositions, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an integer array nums containing n integers, find the beauty of each subarray of size k.\nThe beauty of a subarray is the x^th smallest integer in the subarray if it is negative, or 0 if there are fewer than x negative integers.\nReturn an integer array containing n - k + 1 integers, which denote the beauty of the subarrays in order from the first index in the array.\n\tA subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nInput: nums = [1,-1,-3,-2,3], k = 3, x = 2\nOutput: [-1,-2,-2]\nExplanation: There are 3 subarrays with size k = 3. \nThe first subarray is [1, -1, -3] and the 2^nd smallest negative integer is -1.\u00a0\nThe second subarray is [-1, -3, -2] and the 2^nd smallest negative integer is -2.\u00a0\nThe third subarray is [-3, -2, 3]\u00a0and the 2^nd smallest negative integer is -2.\nExample 2:\nInput: nums = [-1,-2,-3,-4,-5], k = 2, x = 2\nOutput: [-1,-2,-3,-4]\nExplanation: There are 4 subarrays with size k = 2.\nFor [-1, -2], the 2^nd smallest negative integer is -1.\nFor [-2, -3], the 2^nd smallest negative integer is -2.\nFor [-3, -4], the 2^nd smallest negative integer is -3.\nFor [-4, -5], the 2^nd smallest negative integer is -4.\u00a0\nExample 3:\nInput: nums = [-3,1,2,-3,0,-3], k = 2, x = 1\nOutput: [-3,0,-3,-3,-3]\nExplanation: There are 5 subarrays with size k = 2.\nFor [-3, 1], the 1^st smallest negative integer is -3.\nFor [1, 2], there is no negative integer so the beauty is 0.\nFor [2, -3], the 1^st smallest negative integer is -3.\nFor [-3, 0], the 1^st smallest negative integer is -3.\nFor [0, -3], the 1^st smallest negative integer is -3.\nConstraints:\n\tn == nums.length\u00a0\n\t1 <= n <= 10^5\n\t1 <= k <= n\n\t1 <= x <= k\u00a0\n\t-50\u00a0<= nums[i] <= 50\u00a0",
        "topics": [
            "Array",
            "Hash Table",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/sliding-subarray-beauty/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @param {number} x\r\n * @return {number[]}\r\n */\r\nvar getSubarrayBeauty = function(nums, k, x) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a string s that consists of lowercase English letters.\nA string is called special if it is made up of only a single character. For example, the string \"abc\" is not special, whereas the strings \"ddd\", \"zz\", and \"f\" are special.\nReturn the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.\nA substring is a contiguous non-empty sequence of characters within a string.\nExample 1:\nInput: s = \"aaaa\"\nOutput: 2\nExplanation: The longest special substring which occurs thrice is \"aa\": substrings \"aaaa\", \"aaaa\", and \"aaaa\".\nIt can be shown that the maximum length achievable is 2.\nExample 2:\nInput: s = \"abcdef\"\nOutput: -1\nExplanation: There exists no special substring which occurs at least thrice. Hence return -1.\nExample 3:\nInput: s = \"abcaba\"\nOutput: 1\nExplanation: The longest special substring which occurs thrice is \"a\": substrings \"abcaba\", \"abcaba\", and \"abcaba\".\nIt can be shown that the maximum length achievable is 1.\nConstraints:\n\t3 <= s.length <= 5 * 10^5\n\ts consists of only lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Binary Search",
            "Sliding Window",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-ii/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximumLength(self, s: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar maximumLength = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximumLength(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a string s, find the length of the longest substring without repeating characters.\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\nExample 3:\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\nConstraints:\n\t0 <= s.length <= 5 * 10^4\n\ts consists of English letters, digits, symbols and spaces.",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar lengthOfLongestSubstring = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array nums and an integer k.\nA subarray is called equal if all of its elements are equal. Note that the empty subarray is an equal subarray.\nReturn the length of the longest possible equal subarray after deleting at most k elements from nums.\nA subarray is a contiguous, possibly empty sequence of elements within an array.\nExample 1:\nInput: nums = [1,3,2,3,1,3], k = 3\nOutput: 3\nExplanation: It's optimal to delete the elements at index 2 and index 4.\nAfter deleting them, nums becomes equal to [1, 3, 3, 3].\nThe longest equal subarray starts at i = 1 and ends at j = 3 with length equal to 3.\nIt can be proven that no longer equal subarrays can be created.\nExample 2:\nInput: nums = [1,1,2,2,1,1], k = 2\nOutput: 4\nExplanation: It's optimal to delete the elements at index 2 and index 3.\nAfter deleting them, nums becomes equal to [1, 1, 1, 1].\nThe array itself is an equal subarray, so the answer is 4.\nIt can be proven that no longer equal subarrays can be created.\nConstraints:\n\t1 <= nums.length <= 10^5\n\t1 <= nums[i] <= nums.length\n\t0 <= k <= nums.length",
        "topics": [
            "Array",
            "Hash Table",
            "Binary Search",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/find-the-longest-equal-subarray/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def longestEqualSubarray(self, nums: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar longestEqualSubarray = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int longestEqualSubarray(List<Integer> nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an array of integers arr and an integer target.\nYou have to find two non-overlapping sub-arrays of arr each with a sum equal target. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum.\nReturn the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays.\nExample 1:\nInput: arr = [3,2,2,4,3], target = 3\nOutput: 2\nExplanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.\nExample 2:\nInput: arr = [7,3,4,7], target = 7\nOutput: 2\nExplanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.\nExample 3:\nInput: arr = [4,3,2,6,2,3,4], target = 6\nOutput: -1\nExplanation: We have only one sub-array of sum = 6.\nConstraints:\n\t1 <= arr.length <= 10^5\n\t1 <= arr[i] <= 1000\n\t1 <= target <= 10^8",
        "topics": [
            "Array",
            "Hash Table",
            "Binary Search",
            "Dynamic Programming",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} arr\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar minSumOfLengths = function(arr, target) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minSumOfLengths(int[] arr, int target) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a digit string s that consists of digits from 0 to 9.\nA string is called semi-repetitive if there is at most one adjacent pair of the same digit. For example, \"0010\", \"002020\", \"0123\", \"2002\", and \"54944\" are semi-repetitive while the following are not: \"00101022\" (adjacent same digit pairs are 00 and 22), and \"1101234883\" (adjacent same digit pairs are 11 and 88).\nReturn the length of the longest semi-repetitive substring of s.\nExample 1:\nInput: s = \"52233\"\nOutput: 4\nExplanation:\nThe longest semi-repetitive substring is \"5223\". Picking the whole string \"52233\" has two adjacent same digit pairs 22 and 33, but at most one is allowed.\nExample 2:\nInput: s = \"5494\"\nOutput: 4\nExplanation:\ns is a semi-repetitive string.\nExample 3:\nInput: s = \"1111111\"\nOutput: 2\nExplanation:\nThe longest semi-repetitive substring is \"11\". Picking the substring \"111\" has two adjacent same digit pairs, but at most one is allowed.\nConstraints:\n\t1 <= s.length <= 50\n\t'0' <= s[i] <= '9'",
        "topics": [
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/find-the-longest-semi-repetitive-substring/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar longestSemiRepetitiveSubstring = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int longestSemiRepetitiveSubstring(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an array nums of non-negative integers and an integer k.\nAn array is called special if the bitwise OR of all of its elements is at least k.\nReturn the length of the shortest special non-empty subarray of nums, or return -1 if no special subarray exists.\nExample 1:\nInput: nums = [1,2,3], k = 2\nOutput: 1\nExplanation:\nThe subarray [3] has OR value of 3. Hence, we return 1.\nExample 2:\nInput: nums = [2,1,8], k = 10\nOutput: 3\nExplanation:\nThe subarray [2,1,8] has OR value of 11. Hence, we return 3.\nExample 3:\nInput: nums = [1,2], k = 0\nOutput: 1\nExplanation:\nThe subarray [1] has OR value of 1. Hence, we return 1.\nConstraints:\n\t1 <= nums.length <= 50\n\t0 <= nums[i] <= 50\n\t0 <= k < 64",
        "topics": [
            "Array",
            "Bit Manipulation",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/shortest-subarray-with-or-at-least-k-i/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar minimumSubarrayLength = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minimumSubarrayLength(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.\nExample 1:\nInput: nums = [1,2,3,1], k = 3\nOutput: true\nExample 2:\nInput: nums = [1,0,1,1], k = 1\nOutput: true\nExample 3:\nInput: nums = [1,2,3,1,2,3], k = 2\nOutput: false\nConstraints:\n\t1 <= nums.length <= 10^5\n\t-10^9 <= nums[i] <= 10^9\n\t0 <= k <= 10^5",
        "topics": [
            "Array",
            "Hash Table",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/contains-duplicate-ii/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {boolean}\r\n */\r\nvar containsNearbyDuplicate = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\nGiven an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\nA subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\nInput: nums = [1,3,2,2,5,2,3,7]\nOutput: 5\nExplanation: The longest harmonious subsequence is [3,2,2,2,3].\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: 2\nExample 3:\nInput: nums = [1,1,1,1]\nOutput: 0\nConstraints:\n\t1 <= nums.length <= 2 * 10^4\n\t-10^9 <= nums[i] <= 10^9",
        "topics": [
            "Array",
            "Hash Table",
            "Sliding Window",
            "Sorting",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/longest-harmonious-subsequence/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def findLHS(self, nums: List[int]) -> int:",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar findLHS = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int findLHS(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed string blocks of length n, where blocks[i] is either 'W' or 'B', representing the color of the i^th block. The characters 'W' and 'B' denote the colors white and black, respectively.\nYou are also given an integer k, which is the desired number of consecutive black blocks.\nIn one operation, you can recolor a white block such that it becomes a black block.\nReturn the minimum number of operations needed such that there is at least one occurrence of k consecutive black blocks.\nExample 1:\nInput: blocks = \"WBBWWBBWBW\", k = 7\nOutput: 3\nExplanation:\nOne way to achieve 7 consecutive black blocks is to recolor the 0th, 3rd, and 4th blocks\nso that blocks = \"BBBBBBBWBW\". \nIt can be shown that there is no way to achieve 7 consecutive black blocks in less than 3 operations.\nTherefore, we return 3.\nExample 2:\nInput: blocks = \"WBWBBBW\", k = 2\nOutput: 0\nExplanation:\nNo changes need to be made, since 2 consecutive black blocks already exist.\nTherefore, we return 0.\nConstraints:\n\tn == blocks.length\n\t1 <= n <= 100\n\tblocks[i] is either 'W' or 'B'.\n\t1 <= k <= n",
        "topics": [
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def minimumRecolors(self, blocks: str, k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} blocks\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar minimumRecolors = function(blocks, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minimumRecolors(String blocks, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array nums of length n. The number of ways to partition nums is the number of pivot indices that satisfy both conditions:\n\t1 <= pivot < n\n\tnums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]\nYou are also given an integer k. You can choose to change the value of one element of nums to k, or to leave the array unchanged.\nReturn the maximum possible number of ways to partition nums to satisfy both conditions after changing at most one element.\nExample 1:\nInput: nums = [2,-1,2], k = 3\nOutput: 1\nExplanation: One optimal approach is to change nums[0] to k. The array becomes [3,-1,2].\nThere is one way to partition the array:\n- For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.\nExample 2:\nInput: nums = [0,0,0], k = 1\nOutput: 2\nExplanation: The optimal approach is to leave the array unchanged.\nThere are two ways to partition the array:\n- For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.\n- For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.\nExample 3:\nInput: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\nOutput: 4\nExplanation: One optimal approach is to change nums[2] to k. The array becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14].\nThere are four ways to partition the array.\nConstraints:\n\tn == nums.length\n\t2 <= n <= 10^5\n\t-10^5 <= k, nums[i] <= 10^5",
        "topics": [
            "Array",
            "Hash Table",
            "Counting",
            "Enumeration",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def waysToPartition(self, nums: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar waysToPartition = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int waysToPartition(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 2D binary array grid. You need to find 3 non-overlapping rectangles having non-zero areas with horizontal and vertical sides such that all the 1's in grid lie inside these rectangles.\nReturn the minimum possible sum of the area of these rectangles.\nNote that the rectangles are allowed to touch.\nExample 1:\nInput: grid = [[1,0,1],[1,1,1]]\nOutput: 5\nExplanation:\n\tThe 1's at (0, 0) and (1, 0) are covered by a rectangle of area 2.\n\tThe 1's at (0, 2) and (1, 2) are covered by a rectangle of area 2.\n\tThe 1 at (1, 1) is covered by a rectangle of area 1.\nExample 2:\nInput: grid = [[1,0,1,0],[0,1,0,1]]\nOutput: 5\nExplanation:\n\tThe 1's at (0, 0) and (0, 2) are covered by a rectangle of area 3.\n\tThe 1 at (1, 1) is covered by a rectangle of area 1.\n\tThe 1 at (1, 3) is covered by a rectangle of area 1.\nConstraints:\n\t1 <= grid.length, grid[i].length <= 30\n\tgrid[i][j] is either 0 or 1.\n\tThe input is generated such that there are at least three 1's in grid.",
        "topics": [
            "Array",
            "Matrix",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/find-the-minimum-area-to-cover-all-ones-ii/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minimumSum(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar minimumSum = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minimumSum(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is an undirected graph with n nodes, numbered from 0 to n - 1.\nYou are given a 0-indexed integer array scores of length n where scores[i] denotes the score of node i. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nA node sequence is valid if it meets the following conditions:\n\tThere is an edge connecting every pair of adjacent nodes in the sequence.\n\tNo node appears more than once in the sequence.\nThe score of a node sequence is defined as the sum of the scores of the nodes in the sequence.\nReturn the maximum score of a valid node sequence with a length of 4. If no such sequence exists, return -1.\nExample 1:\nInput: scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\nOutput: 24\nExplanation: The figure above shows the graph and the chosen node sequence [0,1,2,3].\nThe score of the node sequence is 5 + 2 + 9 + 8 = 24.\nIt can be shown that no other node sequence has a score of more than 24.\nNote that the sequences [3,1,2,0] and [1,0,2,3] are also valid and have a score of 24.\nThe sequence [0,3,2,4] is not valid since no edge connects nodes 0 and 3.\nExample 2:\nInput: scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]\nOutput: -1\nExplanation: The figure above shows the graph.\nThere are no valid node sequences of length 4, so we return -1.\nConstraints:\n\tn == scores.length\n\t4 <= n <= 5 * 10^4\n\t1 <= scores[i] <= 10^8\n\t0 <= edges.length <= 5 * 10^4\n\tedges[i].length == 2\n\t0 <= ai, bi <= n - 1\n\tai != bi\n\tThere are no duplicate edges.",
        "topics": [
            "Array",
            "Graph",
            "Sorting",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/maximum-score-of-a-node-sequence/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} scores\r\n * @param {number[][]} edges\r\n * @return {number}\r\n */\r\nvar maximumScore = function(scores, edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximumScore(int[] scores, int[][] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Let's say a positive integer is a super-palindrome if it is a palindrome, and it is also the square of a palindrome.\nGiven two positive integers left and right represented as strings, return the number of super-palindromes integers in the inclusive range [left, right].\nExample 1:\nInput: left = \"4\", right = \"1000\"\nOutput: 4\nExplanation: 4, 9, 121, and 484 are superpalindromes.\nNote that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.\nExample 2:\nInput: left = \"1\", right = \"2\"\nOutput: 1\nConstraints:\n\t1 <= left.length, right.length <= 18\n\tleft and right consist of only digits.\n\tleft and right cannot have leading zeros.\n\tleft and right represent integers in the range [1, 10^18 - 1].\n\tleft is less than or equal to right.",
        "topics": [
            "Math",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/super-palindromes/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def superpalindromesInRange(self, left: str, right: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} left\r\n * @param {string} right\r\n * @return {number}\r\n */\r\nvar superpalindromesInRange = function(left, right) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int superpalindromesInRange(String left, String right) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Alice had a 0-indexed array arr consisting of n positive integers. She chose an arbitrary positive integer k and created two new 0-indexed integer arrays lower and higher in the following manner:\n\tlower[i] = arr[i] - k, for every index i where 0 <= i < n\n\thigher[i] = arr[i] + k, for every index i where 0 <= i < n\nUnfortunately, Alice lost all three arrays. However, she remembers the integers that were present in the arrays lower and higher, but not the array each integer belonged to. Help Alice and recover the original array.\nGiven an array nums consisting of 2n integers, where exactly n of the integers were present in lower and the remaining in higher, return the original array arr. In case the answer is not unique, return any valid array.\nNote: The test cases are generated such that there exists at least one valid array arr.\nExample 1:\nInput: nums = [2,10,6,4,8,12]\nOutput: [3,7,11]\nExplanation:\nIf arr = [3,7,11] and k = 1, we get lower = [2,6,10] and higher = [4,8,12].\nCombining lower and higher gives us [2,6,10,4,8,12], which is a permutation of nums.\nAnother valid possibility is that arr = [5,7,9] and k = 3. In that case, lower = [2,4,6] and higher = [8,10,12]. \nExample 2:\nInput: nums = [1,1,3,3]\nOutput: [2,2]\nExplanation:\nIf arr = [2,2] and k = 1, we get lower = [1,1] and higher = [3,3].\nCombining lower and higher gives us [1,1,3,3], which is equal to nums.\nNote that arr cannot be [1,3] because in that case, the only possible way to obtain [1,1,3,3] is with k = 0.\nThis is invalid since k must be positive.\nExample 3:\nInput: nums = [5,435]\nOutput: [220]\nExplanation:\nThe only possible combination is arr = [220] and k = 215. Using them, we get lower = [5] and higher = [435].\nConstraints:\n\t2 * n == nums.length\n\t1 <= n <= 1000\n\t1 <= nums[i] <= 10^9\n\tThe test cases are generated such that there exists at least one valid array arr.",
        "topics": [
            "Array",
            "Hash Table",
            "Sorting",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/recover-the-original-array/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def recoverArray(self, nums: List[int]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\nvar recoverArray = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] recoverArray(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.\nExample 1:\nInput: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nExample 2:\nInput: n = 9\nOutput: 3\nExplanation: 9 = 4 + 5 = 2 + 3 + 4\nExample 3:\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\nConstraints:\n\t1 <= n <= 10^9",
        "topics": [
            "Math",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/consecutive-numbers-sum/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def consecutiveNumbersSum(self, n: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar consecutiveNumbersSum = function(n) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int consecutiveNumbersSum(int n) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is a large (m - 1) x (n - 1) rectangular field with corners at (1, 1) and (m, n) containing some horizontal and vertical fences given in arrays hFences and vFences respectively.\nHorizontal fences are from the coordinates (hFences[i], 1) to (hFences[i], n) and vertical fences are from the coordinates (1, vFences[i]) to (m, vFences[i]).\nReturn the maximum area of a square field that can be formed by removing some fences (possibly none) or -1 if it is impossible to make a square field.\nSince the answer may be large, return it modulo 10^9 + 7.\nNote: The field is surrounded by two horizontal fences from the coordinates (1, 1) to (1, n) and (m, 1) to (m, n) and two vertical fences from the coordinates (1, 1) to (m, 1) and (1, n) to (m, n). These fences cannot be removed.\nExample 1:\nInput: m = 4, n = 3, hFences = [2,3], vFences = [2]\nOutput: 4\nExplanation: Removing the horizontal fence at 2 and the vertical fence at 2 will give a square field of area 4.\nExample 2:\nInput: m = 6, n = 7, hFences = [2], vFences = [4]\nOutput: -1\nExplanation: It can be proved that there is no way to create a square field by removing fences.\nConstraints:\n\t3 <= m, n <= 10^9\n\t1 <= hFences.length, vFences.length <= 600\n\t1 < hFences[i] < m\n\t1 < vFences[i] < n\n\thFences and vFences are unique.",
        "topics": [
            "Array",
            "Hash Table",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/maximum-square-area-by-removing-fences-from-a-field/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} m\r\n * @param {number} n\r\n * @param {number[]} hFences\r\n * @param {number[]} vFences\r\n * @return {number}\r\n */\r\nvar maximizeSquareArea = function(m, n, hFences, vFences) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximizeSquareArea(int m, int n, int[] hFences, int[] vFences) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array nums representing the score of students in an exam. The teacher would like to form one non-empty group of students with maximal strength, where the strength of a group of students of indices i0, i1, i2, ... , ik is defined as nums[i0] * nums[i1] * nums[i2] * ... * nums[ik\u200b].\nReturn the maximum strength of a group the teacher can create.\nExample 1:\nInput: nums = [3,-1,-5,2,5,-9]\nOutput: 1350\nExplanation: One way to form a group of maximal strength is to group the students at indices [0,2,3,4,5]. Their strength is 3 * (-5) * 2 * 5 * (-9) = 1350, which we can show is optimal.\nExample 2:\nInput: nums = [-4,-5,-4]\nOutput: 20\nExplanation: Group the students at indices [0, 1] . Then, we\u2019ll have a resulting strength of 20. We cannot achieve greater strength.\nConstraints:\n\t1 <= nums.length <= 13\n\t-9 <= nums[i] <= 9",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Backtracking",
            "Greedy",
            "Bit Manipulation",
            "Sorting",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/maximum-strength-of-a-group/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maxStrength(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maxStrength = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long maxStrength(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given two integers num and k, consider a set of positive integers with the following properties:\n\tThe units digit of each integer is k.\n\tThe sum of the integers is num.\nReturn the minimum possible size of such a set, or -1 if no such set exists.\nNote:\n\tThe set can contain multiple instances of the same integer, and the sum of an empty set is considered 0.\n\tThe units digit of a number is the rightmost digit of the number.\nExample 1:\nInput: num = 58, k = 9\nOutput: 2\nExplanation:\nOne valid set is [9,49], as the sum is 58 and each integer has a units digit of 9.\nAnother valid set is [19,39].\nIt can be shown that 2 is the minimum possible size of a valid set.\nExample 2:\nInput: num = 37, k = 2\nOutput: -1\nExplanation: It is not possible to obtain a sum of 37 using only integers that have a units digit of 2.\nExample 3:\nInput: num = 0, k = 7\nOutput: 0\nExplanation: The sum of an empty set is considered 0.\nConstraints:\n\t0 <= num <= 3000\n\t0 <= k <= 9",
        "topics": [
            "Math",
            "Dynamic Programming",
            "Greedy",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/sum-of-numbers-with-units-digit-k/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minimumNumbers(self, num: int, k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} num\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar minimumNumbers = function(num, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minimumNumbers(int num, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given three strings a, b, and c, your task is to find a string that has the minimum length and contains all three strings as substrings.\nIf there are multiple such strings, return the lexicographically smallest one.\nReturn a string denoting the answer to the problem.\nNotes\n\tA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\n\tA substring is a contiguous sequence of characters within a string.\nExample 1:\nInput: a = \"abc\", b = \"bca\", c = \"aaa\"\nOutput: \"aaabca\"\nExplanation:  We show that \"aaabca\" contains all the given strings: a = ans[2...4], b = ans[3..5], c = ans[0..2]. It can be shown that the length of the resulting string would be at least 6 and \"aaabca\" is the lexicographically smallest one.\nExample 2:\nInput: a = \"ab\", b = \"ba\", c = \"aba\"\nOutput: \"aba\"\nExplanation: We show that the string \"aba\" contains all the given strings: a = ans[0..1], b = ans[1..2], c = ans[0..2]. Since the length of c is 3, the length of the resulting string would be at least 3. It can be shown that \"aba\" is the lexicographically smallest one.\nConstraints:\n\t1 <= a.length, b.length, c.length <= 100\n\ta, b, c consist only of lowercase English letters.",
        "topics": [
            "String",
            "Greedy",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/shortest-string-that-contains-three-strings/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minimumString(self, a: str, b: str, c: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} a\r\n * @param {string} b\r\n * @param {string} c\r\n * @return {string}\r\n */\r\nvar minimumString = function(a, b, c) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String minimumString(String a, String b, String c) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given two integer arrays nums1 and nums2.\nFrom nums1 two elements have been removed, and all other elements have been increased (or decreased in the case of negative) by an integer, represented by the variable x.\nAs a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.\nReturn the minimum possible integer x that achieves this equivalence.\nExample 1:\nInput: nums1 = [4,20,16,12,8], nums2 = [14,18,10]\nOutput: -2\nExplanation:\nAfter removing elements at indices [0,4] and adding -2, nums1 becomes [18,14,10].\nExample 2:\nInput: nums1 = [3,5,5,3], nums2 = [7,7]\nOutput: 2\nExplanation:\nAfter removing elements at indices [0,3] and adding 2, nums1 becomes [7,7].\nConstraints:\n\t3 <= nums1.length <= 200\n\tnums2.length == nums1.length - 2\n\t0 <= nums1[i], nums2[i] <= 1000\n\tThe test cases are generated in a way that there is an integer x such that nums1 can become equal to nums2 by removing two elements and adding x to each element of nums1.",
        "topics": [
            "Array",
            "Two Pointers",
            "Sorting",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/find-the-integer-added-to-array-ii/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums1\r\n * @param {number[]} nums2\r\n * @return {number}\r\n */\r\nvar minimumAddedInteger = function(nums1, nums2) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minimumAddedInteger(int[] nums1, int[] nums2) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array nums of size n representing the cost of collecting different chocolates. The cost of collecting the chocolate at the index i\u00a0is nums[i]. Each chocolate is of a different type, and initially, the chocolate at the index\u00a0i\u00a0is of i^th type.\nIn one operation, you can do the following with an incurred cost of x:\n\tSimultaneously change the chocolate of i^th type to ((i + 1) mod n)^th type for all chocolates.\nReturn the minimum cost to collect chocolates of all types, given that you can perform as many operations as you would like.\nExample 1:\nInput: nums = [20,1,15], x = 5\nOutput: 13\nExplanation: Initially, the chocolate types are [0,1,2]. We will buy the 1^st\u00a0type of chocolate at a cost of 1.\nNow, we will perform the operation at a cost of 5, and the types of chocolates will become [1,2,0]. We will buy the 2^nd^ type of chocolate at a cost of 1.\nNow, we will again perform the operation at a cost of 5, and the chocolate types will become [2,0,1]. We will buy the 0^th type of chocolate at a cost of 1. \nThus, the total cost will become (1 + 5 + 1 + 5 + 1) = 13. We can prove that this is optimal.\nExample 2:\nInput: nums = [1,2,3], x = 4\nOutput: 6\nExplanation: We will collect all three types of chocolates at their own price without performing any operations. Therefore, the total cost is 1 + 2 + 3 = 6.\nConstraints:\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 10^9\n\t1 <= x <= 10^9",
        "topics": [
            "Array",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/collecting-chocolates/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minCost(self, nums: List[int], x: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} x\r\n * @return {number}\r\n */\r\nvar minCost = function(nums, x) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long minCost(int[] nums, int x) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an integer n, return the number of prime numbers that are strictly less than n.\nExample 1:\nInput: n = 10\nOutput: 4\nExplanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\nExample 2:\nInput: n = 0\nOutput: 0\nExample 3:\nInput: n = 1\nOutput: 0\nConstraints:\n\t0 <= n <= 5 * 10^6",
        "topics": [
            "Array",
            "Math",
            "Enumeration",
            "Number Theory"
        ],
        "url": "https://leetcode.com/problems/count-primes/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def countPrimes(self, n: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar countPrimes = function(n) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int countPrimes(int n) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer n. We say that two integers x and y form a prime number pair if:\n\t1 <= x <= y <= n\n\tx + y == n\n\tx and y are prime numbers\nReturn the 2D sorted list of prime number pairs [xi, yi]. The list should be sorted in increasing order of xi. If there are no prime number pairs at all, return an empty array.\nNote: A prime number is a natural number greater than 1 with only two factors, itself and 1.\nExample 1:\nInput: n = 10\nOutput: [[3,7],[5,5]]\nExplanation: In this example, there are two prime pairs that satisfy the criteria. \nThese pairs are [3,7] and [5,5], and we return them in the sorted order as described in the problem statement.\nExample 2:\nInput: n = 2\nOutput: []\nExplanation: We can show that there is no prime number pair that gives a sum of 2, so we return an empty array. \nConstraints:\n\t1 <= n <= 10^6",
        "topics": [
            "Array",
            "Math",
            "Enumeration",
            "Number Theory"
        ],
        "url": "https://leetcode.com/problems/prime-pairs-with-target-sum/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def findPrimePairs(self, n: int) -> List[List[int]]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @return {number[][]}\r\n */\r\nvar findPrimePairs = function(n) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<List<Integer>> findPrimePairs(int n) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given two positive integers n and limit.\nReturn the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.\nExample 1:\nInput: n = 5, limit = 2\nOutput: 3\nExplanation: There are 3 ways to distribute 5 candies such that no child gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).\nExample 2:\nInput: n = 3, limit = 3\nOutput: 10\nExplanation: There are 10 ways to distribute 3 candies such that no child gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1), (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1), (2, 1, 0) and (3, 0, 0).\nConstraints:\n\t1 <= n <= 10^6\n\t1 <= limit <= 10^6",
        "topics": [
            "Math",
            "Combinatorics",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/distribute-candies-among-children-ii/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def distributeCandies(self, n: int, limit: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number} limit\r\n * @return {number}\r\n */\r\nvar distributeCandies = function(n, limit) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long distributeCandies(int n, int limit) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an array arr of 4 digits, find the latest 24-hour time that can be made using each digit exactly once.\n24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.\nReturn the latest 24-hour time in \"HH:MM\" format. If no valid time can be made, return an empty string.\nExample 1:\nInput: arr = [1,2,3,4]\nOutput: \"23:41\"\nExplanation: The valid 24-hour times are \"12:34\", \"12:43\", \"13:24\", \"13:42\", \"14:23\", \"14:32\", \"21:34\", \"21:43\", \"23:14\", and \"23:41\". Of these times, \"23:41\" is the latest.\nExample 2:\nInput: arr = [5,5,5,5]\nOutput: \"\"\nExplanation: There are no valid 24-hour times as \"55:55\" is not valid.\nConstraints:\n\tarr.length == 4\n\t0 <= arr[i] <= 9",
        "topics": [
            "Array",
            "String",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/largest-time-for-given-digits/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} arr\r\n * @return {string}\r\n */\r\nvar largestTimeFromDigits = function(arr) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String largestTimeFromDigits(int[] arr) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer array digits, where each element is a digit. The array may contain duplicates.\nYou need to find all the unique integers that follow the given requirements:\n\tThe integer consists of the concatenation of three elements from digits in any arbitrary order.\n\tThe integer does not have leading zeros.\n\tThe integer is even.\nFor example, if the given digits were [1, 2, 3], integers 132 and 312 follow the requirements.\nReturn a sorted array of the unique integers.\nExample 1:\nInput: digits = [2,1,3,0]\nOutput: [102,120,130,132,210,230,302,310,312,320]\nExplanation: All the possible integers that follow the requirements are in the output array. \nNotice that there are no odd integers or integers with leading zeros.\nExample 2:\nInput: digits = [2,2,8,8,2]\nOutput: [222,228,282,288,822,828,882]\nExplanation: The same digit can be used as many times as it appears in digits. \nIn this example, the digit 8 is used twice each time in 288, 828, and 882. \nExample 3:\nInput: digits = [3,7,5]\nOutput: []\nExplanation: No even integers can be formed using the given digits.\nConstraints:\n\t3 <= digits.length <= 100\n\t0 <= digits[i] <= 9",
        "topics": [
            "Array",
            "Hash Table",
            "Sorting",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/finding-3-digit-even-numbers/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def findEvenNumbers(self, digits: List[int]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} digits\r\n * @return {number[]}\r\n */\r\nvar findEvenNumbers = function(digits) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] findEvenNumbers(int[] digits) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.\nAn integer m is a divisor of n if there exists an integer k such that n = k * m.\nExample 1:\nInput: n = 2\nOutput: false\nExplantion: 2 has only two divisors: 1 and 2.\nExample 2:\nInput: n = 4\nOutput: true\nExplantion: 4 has three divisors: 1, 2, and 4.\nConstraints:\n\t1 <= n <= 10^4",
        "topics": [
            "Math",
            "Enumeration",
            "Number Theory"
        ],
        "url": "https://leetcode.com/problems/three-divisors/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def isThree(self, n: int) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @return {boolean}\r\n */\r\nvar isThree = function(n) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean isThree(int n) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that:\n\tnums[a] + nums[b] + nums[c] == nums[d], and\n\ta < b < c < d\nExample 1:\nInput: nums = [1,2,3,6]\nOutput: 1\nExplanation: The only quadruplet that satisfies the requirement is (0, 1, 2, 3) because 1 + 2 + 3 == 6.\nExample 2:\nInput: nums = [3,3,6,4,5]\nOutput: 0\nExplanation: There are no such quadruplets in [3,3,6,4,5].\nExample 3:\nInput: nums = [1,1,1,3,5]\nOutput: 4\nExplanation: The 4 quadruplets that satisfy the requirement are:\n- (0, 1, 2, 3): 1 + 1 + 1 == 3\n- (0, 1, 3, 4): 1 + 1 + 3 == 5\n- (0, 2, 3, 4): 1 + 1 + 3 == 5\n- (1, 2, 3, 4): 1 + 1 + 3 == 5\nConstraints:\n\t4 <= nums.length <= 50\n\t1 <= nums[i] <= 100",
        "topics": [
            "Array",
            "Hash Table",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/count-special-quadruplets/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def countQuadruplets(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar countQuadruplets = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int countQuadruplets(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an array of integers nums of length n.\nThe cost of an array is the value of its first element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is 3.\nYou need to divide nums into 3 disjoint contiguous subarrays.\nReturn the minimum possible sum of the cost of these subarrays.\nExample 1:\nInput: nums = [1,2,3,12]\nOutput: 6\nExplanation: The best possible way to form 3 subarrays is: [1], [2], and [3,12] at a total cost of 1 + 2 + 3 = 6.\nThe other possible ways to form 3 subarrays are:\n- [1], [2,3], and [12] at a total cost of 1 + 2 + 12 = 15.\n- [1,2], [3], and [12] at a total cost of 1 + 3 + 12 = 16.\nExample 2:\nInput: nums = [5,4,3]\nOutput: 12\nExplanation: The best possible way to form 3 subarrays is: [5], [4], and [3] at a total cost of 5 + 4 + 3 = 12.\nIt can be shown that 12 is the minimum cost achievable.\nExample 3:\nInput: nums = [10,3,1,1]\nOutput: 12\nExplanation: The best possible way to form 3 subarrays is: [10,3], [1], and [1] at a total cost of 10 + 1 + 1 = 12.\nIt can be shown that 12 is the minimum cost achievable.\nConstraints:\n\t3 <= n <= 50\n\t1 <= nums[i] <= 50",
        "topics": [
            "Array",
            "Sorting",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def minimumCost(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar minimumCost = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minimumCost(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "A square triple (a,b,c) is a triple where a, b, and c are integers and a^2 + b^2 = c^2.\nGiven an integer n, return the number of square triples such that 1 <= a, b, c <= n.\nExample 1:\nInput: n = 5\nOutput: 2\nExplanation: The square triples are (3,4,5) and (4,3,5).\nExample 2:\nInput: n = 10\nOutput: 4\nExplanation: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10).\nConstraints:\n\t1 <= n <= 250",
        "topics": [
            "Math",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/count-square-sum-triples/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def countTriples(self, n: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar countTriples = function(n) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int countTriples(int n) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a string of English letters s, return the greatest English letter which occurs as both a lowercase and uppercase letter in s. The returned letter should be in uppercase. If no such letter exists, return an empty string.\nAn English letter b is greater than another letter a if b appears after a in the English alphabet.\nExample 1:\nInput: s = \"lEeTcOdE\"\nOutput: \"E\"\nExplanation:\nThe letter 'E' is the only letter to appear in both lower and upper case.\nExample 2:\nInput: s = \"arRAzFif\"\nOutput: \"R\"\nExplanation:\nThe letter 'R' is the greatest letter to appear in both lower and upper case.\nNote that 'A' and 'F' also appear in both lower and upper case, but 'R' is greater than 'F' or 'A'.\nExample 3:\nInput: s = \"AbCdEfGhIjK\"\nOutput: \"\"\nExplanation:\nThere is no letter that appears in both lower and upper case.\nConstraints:\n\t1 <= s.length <= 1000\n\ts consists of lowercase and uppercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/greatest-english-letter-in-upper-and-lower-case/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def greatestLetter(self, s: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar greatestLetter = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String greatestLetter(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.\nExample 1:\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\nExample 2:\nInput: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\nConstraints:\n\t3 <= nums.length <= 500\n\t-1000 <= nums[i] <= 1000\n\t-10^4 <= target <= 10^4",
        "topics": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/3sum-closest/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar threeSumClosest = function(nums, target) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int threeSumClosest(int[] nums, int target) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExample 1:\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\nExample 2:\nInput: coins = [2], amount = 3\nOutput: -1\nExample 3:\nInput: coins = [1], amount = 0\nOutput: 0\nConstraints:\n\t1 <= coins.length <= 12\n\t1 <= coins[i] <= 2^31 - 1\n\t0 <= amount <= 10^4",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/coin-change/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def coinChange(self, coins: List[int], amount: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} coins\r\n * @param {number} amount\r\n * @return {number}\r\n */\r\nvar coinChange = function(coins, amount) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int coinChange(int[] coins, int amount) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.\nA good subarray is a subarray where:\n\tits length is at least two, and\n\tthe sum of the elements of the subarray is a multiple of k.\nNote that:\n\tA subarray is a contiguous part of the array.\n\tAn integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.\nExample 1:\nInput: nums = [23,2,4,6,7], k = 6\nOutput: true\nExplanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\nExample 2:\nInput: nums = [23,2,6,4,7], k = 6\nOutput: true\nExplanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\nExample 3:\nInput: nums = [23,2,6,4,7], k = 13\nOutput: false\nConstraints:\n\t1 <= nums.length <= 10^5\n\t0 <= nums[i] <= 10^9\n\t0 <= sum(nums[i]) <= 2^31 - 1\n\t1 <= k <= 2^31 - 1",
        "topics": [
            "Array",
            "Hash Table",
            "Math",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/continuous-subarray-sum/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {boolean}\r\n */\r\nvar checkSubarraySum = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean checkSubarraySum(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:\n\"1\" -> 'A'\n\"2\" -> 'B'\n...\n\"25\" -> 'Y'\n\"26\" -> 'Z'\nHowever, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\").\nFor example, \"11106\" can be decoded into:\n\t\"AAJF\" with the grouping (1, 1, 10, 6)\n\t\"KJF\" with the grouping (11, 10, 6)\n\tThe grouping (1, 11, 06) is invalid because \"06\" is not a valid code (only \"6\" is valid).\nNote: there may be strings that are impossible to decode.\nGiven a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.\nThe test cases are generated so that the answer fits in a 32-bit integer.\nExample 1:\nInput: s = \"12\"\nOutput: 2\nExplanation:\n\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\nExample 2:\nInput: s = \"226\"\nOutput: 3\nExplanation:\n\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\nExample 3:\nInput: s = \"06\"\nOutput: 0\nExplanation:\n\"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). In this case, the string is not a valid encoding, so return 0.\nConstraints:\n\t1 <= s.length <= 100\n\ts contains only digits and may contain leading zero(s).",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/decode-ways/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def numDecodings(self, s: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar numDecodings = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numDecodings(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer array nums. The adjacent integers in nums will perform the float division.\n\tFor example, for nums = [2,3,4], we will evaluate the expression \"2/3/4\".\nHowever, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.\nReturn the corresponding expression that has the maximum value in string format.\nNote: your expression should not contain redundant parenthesis.\nExample 1:\nInput: nums = [1000,100,10,2]\nOutput: \"1000/(100/10/2)\"\nExplanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200\nHowever, the bold parenthesis in \"1000/((100/10)/2)\" are redundant since they do not influence the operation priority.\nSo you should return \"1000/(100/10/2)\".\nOther cases:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\nExample 2:\nInput: nums = [2,3,4]\nOutput: \"2/(3/4)\"\nExplanation: (2/(3/4)) = 8/3 = 2.667\nIt can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667\nConstraints:\n\t1 <= nums.length <= 10\n\t2 <= nums[i] <= 1000\n\tThere is only one optimal division for the given input.",
        "topics": [
            "Array",
            "Math",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/optimal-division/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def optimalDivision(self, nums: List[int]) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {string}\r\n */\r\nvar optimalDivision = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String optimalDivision(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\nExample 1:\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nExample 2:\nInput: s = \"a\"\nOutput: [[\"a\"]]\nConstraints:\n\t1 <= s.length <= 16\n\ts contains only lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/palindrome-partitioning/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def partition(self, s: str) -> List[List[str]]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {string[][]}\r\n */\r\nvar partition = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<List<String>> partition(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.\nExample 1:\nInput: s = \"owoztneoer\"\nOutput: \"012\"\nExample 2:\nInput: s = \"fviefuro\"\nOutput: \"45\"\nConstraints:\n\t1 <= s.length <= 10^5\n\ts[i] is one of the characters [\"e\",\"g\",\"f\",\"i\",\"h\",\"o\",\"n\",\"s\",\"r\",\"u\",\"t\",\"w\",\"v\",\"x\",\"z\"].\n\ts is guaranteed to be valid.",
        "topics": [
            "Hash Table",
            "Math",
            "String"
        ],
        "url": "https://leetcode.com/problems/reconstruct-original-digits-from-english/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def originalDigits(self, s: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar originalDigits = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String originalDigits(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].\nA node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).\nReturn an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.\nExample 1:\nInput: graph = [[1,2],[2,3],[5],[0],[5],[],[]]\nOutput: [2,4,5,6]\nExplanation: The given graph is shown above.\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\nExample 2:\nInput: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\nOutput: [4]\nExplanation:\nOnly node 4 is a terminal node, and every path starting at node 4 leads to node 4.\nConstraints:\n\tn == graph.length\n\t1 <= n <= 10^4\n\t0 <= graph[i].length <= n\n\t0 <= graph[i][j] <= n - 1\n\tgraph[i] is sorted in a strictly increasing order.\n\tThe graph may contain self-loops.\n\tThe number of edges in the graph will be in the range [1, 4 * 10^4].",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "url": "https://leetcode.com/problems/find-eventual-safe-states/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} graph\r\n * @return {number[]}\r\n */\r\nvar eventualSafeNodes = function(graph) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<Integer> eventualSafeNodes(int[][] graph) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "We run a\u00a0preorder\u00a0depth-first search (DFS) on the root of a binary tree.\nAt each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.\u00a0 If the depth of a node is D, the depth of its immediate child is D + 1.\u00a0 The depth of the root node is 0.\nIf a node has only one child, that child is guaranteed to be the left child.\nGiven the output traversal of this traversal, recover the tree and return its root.\nExample 1:\nInput: traversal = \"1-2--3--4-5--6--7\"\nOutput: [1,2,5,3,4,6,7]\nExample 2:\nInput: traversal = \"1-2--3---4-5--6---7\"\nOutput: [1,2,5,3,null,6,null,4,null,7]\nExample 3:\nInput: traversal = \"1-401--349---90--88\"\nOutput: [1,401,null,349,88,90]\nConstraints:\n\tThe number of nodes in the original tree is in the range [1, 1000].\n\t1 <= Node.val <= 10^9",
        "topics": [
            "String",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/description/",
        "difficulty": "Hard",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {string} traversal\r\n * @return {TreeNode}\r\n */\r\nvar recoverFromPreorder = function(traversal) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode recoverFromPreorder(String traversal) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,\n\tIf isLefti == 1, then childi is the left child of parenti.\n\tIf isLefti == 0, then childi is the right child of parenti.\nConstruct the binary tree described by descriptions and return its root.\nThe test cases will be generated such that the binary tree is valid.\nExample 1:\nInput: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]\nOutput: [50,20,80,15,17,19]\nExplanation: The root node is the node with value 50 since it has no parent.\nThe resulting binary tree is shown in the diagram.\nExample 2:\nInput: descriptions = [[1,2,1],[2,3,0],[3,4,1]]\nOutput: [1,2,null,null,3,4]\nExplanation: The root node is the node with value 1 since it has no parent.\nThe resulting binary tree is shown in the diagram.\nConstraints:\n\t1 <= descriptions.length <= 10^4\n\tdescriptions[i].length == 3\n\t1 <= parenti, childi <= 10^5\n\t0 <= isLefti <= 1\n\tThe binary tree described by descriptions is valid.",
        "topics": [
            "Array",
            "Hash Table",
            "Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/create-binary-tree-from-descriptions/description/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {number[][]} descriptions\r\n * @return {TreeNode}\r\n */\r\nvar createBinaryTree = function(descriptions) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode createBinaryTree(int[][] descriptions) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.\nReturn true if the value of the root is equal to the sum of the values of its two children, or false otherwise.\nExample 1:\nInput: root = [10,4,6]\nOutput: true\nExplanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n10 is equal to 4 + 6, so we return true.\nExample 2:\nInput: root = [5,3,1]\nOutput: false\nExplanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n5 is not equal to 3 + 1, so we return false.\nConstraints:\n\tThe tree consists only of the root, its left child, and its right child.\n\t-100 <= Node.val <= 100",
        "topics": [
            "Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/root-equals-sum-of-children/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {boolean}\r\n */\r\nvar checkTree = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean checkTree(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an m x n matrix, return all elements of the matrix in spiral order.\nExample 1:\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\nExample 2:\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\nConstraints:\n\tm == matrix.length\n\tn == matrix[i].length\n\t1 <= m, n <= 10\n\t-100 <= matrix[i][j] <= 100",
        "topics": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/spiral-matrix/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} matrix\r\n * @return {number[]}\r\n */\r\nvar spiralOrder = function(matrix) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<Integer> spiralOrder(int[][] matrix) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an m x n binary matrix mat, return the number of special positions in mat.\nA position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).\nExample 1:\nInput: mat = [[1,0,0],[0,0,1],[1,0,0]]\nOutput: 1\nExplanation: (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.\nExample 2:\nInput: mat = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3\nExplanation: (0, 0), (1, 1) and (2, 2) are special positions.\nConstraints:\n\tm == mat.length\n\tn == mat[i].length\n\t1 <= m, n <= 100\n\tmat[i][j] is either 0 or 1.",
        "topics": [
            "Array",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/special-positions-in-a-binary-matrix/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def numSpecial(self, mat: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} mat\r\n * @return {number}\r\n */\r\nvar numSpecial = function(mat) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numSpecial(int[][] mat) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an m x n integer matrix grid, where you can move from a cell to any adjacent cell in all 4 directions.\nReturn the number of strictly increasing paths in the grid such that you can start from any cell and end at any cell. Since the answer may be very large, return it modulo 10^9 + 7.\nTwo paths are considered different if they do not have exactly the same sequence of visited cells.\nExample 1:\nInput: grid = [[1,1],[3,4]]\nOutput: 8\nExplanation: The strictly increasing paths are:\n- Paths with length 1: [1], [1], [3], [4].\n- Paths with length 2: [1 -> 3], [1 -> 4], [3 -> 4].\n- Paths with length 3: [1 -> 3 -> 4].\nThe total number of paths is 4 + 3 + 1 = 8.\nExample 2:\nInput: grid = [[1],[2]]\nOutput: 3\nExplanation: The strictly increasing paths are:\n- Paths with length 1: [1], [2].\n- Paths with length 2: [1 -> 2].\nThe total number of paths is 2 + 1 = 3.\nConstraints:\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 1000\n\t1 <= m * n <= 10^5\n\t1 <= grid[i][j] <= 10^5",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort",
            "Memoization",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def countPaths(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar countPaths = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int countPaths(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer n. There is a complete binary tree with 2^n - 1 nodes. The root of that tree is the node with the value 1, and every node with a value val in the range [1, 2^n - 1 - 1] has two children where:\n\tThe left node has the value 2 * val, and\n\tThe right node has the value 2 * val + 1.\nYou are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, solve the following problem:\n\tAdd an edge between the nodes with values ai and bi.\n\tFind the length of the cycle in the graph.\n\tRemove the added edge between nodes with values ai and bi.\nNote that:\n\tA cycle is a path that starts and ends at the same node, and each edge in the path is visited only once.\n\tThe length of a cycle is the number of edges visited in the cycle.\n\tThere could be multiple edges between two nodes in the tree after adding the edge of the query.\nReturn an array answer of length m where answer[i] is the answer to the i^th query.\nExample 1:\nInput: n = 3, queries = [[5,3],[4,7],[2,3]]\nOutput: [4,5,3]\nExplanation: The diagrams above show the tree of 2^3 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n- After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes [5,2,1,3]. Thus answer to the first query is 4. We delete the added edge and process the next query.\n- After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes [4,2,1,3,7]. Thus answer to the second query is 5. We delete the added edge and process the next query.\n- After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes [2,1,3]. Thus answer to the third query is 3. We delete the added edge.\nExample 2:\nInput: n = 2, queries = [[1,2]]\nOutput: [2]\nExplanation: The diagram above shows the tree of 2^2 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n- After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes [2,1]. Thus answer for the first query is 2. We delete the added edge.\nConstraints:\n\t2 <= n <= 30\n\tm == queries.length\n\t1 <= m <= 10^5\n\tqueries[i].length == 2\n\t1 <= ai, bi <= 2^n - 1\n\tai != bi",
        "topics": [
            "Array",
            "Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/cycle-length-queries-in-a-tree/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} queries\r\n * @return {number[]}\r\n */\r\nvar cycleLengthQueries = function(n, queries) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] cycleLengthQueries(int n, int[][] queries) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, calculate the vertical order traversal of the binary tree.\nFor each node at position (row, col), its left and right children will be at positions (row + 1, col - 1) and (row + 1, col + 1) respectively. The root of the tree is at (0, 0).\nThe vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\nReturn the vertical order traversal of the binary tree.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[9],[3,15],[20],[7]]\nExplanation:\nColumn -1: Only node 9 is in this column.\nColumn 0: Nodes 3 and 15 are in this column in that order from top to bottom.\nColumn 1: Only node 20 is in this column.\nColumn 2: Only node 7 is in this column.\nExample 2:\nInput: root = [1,2,3,4,5,6,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\nColumn -2: Only node 4 is in this column.\nColumn -1: Only node 2 is in this column.\nColumn 0: Nodes 1, 5, and 6 are in this column.\n          1 is at the top, so it comes first.\n          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.\nColumn 1: Only node 3 is in this column.\nColumn 2: Only node 7 is in this column.\nExample 3:\nInput: root = [1,2,3,4,6,5,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\nThis case is the exact same as example 2, but with nodes 5 and 6 swapped.\nNote that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 1000].\n\t0 <= Node.val <= 1000",
        "topics": [
            "Hash Table",
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Sorting",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/",
        "difficulty": "Hard",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[][]}\r\n */\r\nvar verticalTraversal = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a non-negative integer array nums. In one operation, you must:\n\tChoose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.\n\tSubtract x from every positive element in nums.\nReturn the minimum number of operations to make every element in nums equal to 0.\nExample 1:\nInput: nums = [1,5,0,3,5]\nOutput: 3\nExplanation:\nIn the first operation, choose x = 1. Now, nums = [0,4,0,2,4].\nIn the second operation, choose x = 2. Now, nums = [0,2,0,0,2].\nIn the third operation, choose x = 2. Now, nums = [0,0,0,0,0].\nExample 2:\nInput: nums = [0]\nOutput: 0\nExplanation: Each element in nums is already 0 so no operations are needed.\nConstraints:\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 100",
        "topics": [
            "Array",
            "Hash Table",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/make-array-zero-by-subtracting-equal-amounts/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def minimumOperations(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar minimumOperations = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minimumOperations(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an array of integers stones where stones[i] is the weight of the i^th stone.\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\n\tIf x == y, both stones are destroyed, and\n\tIf x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\nAt the end of the game, there is at most one stone left.\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\nExample 1:\nInput: stones = [2,7,4,1,8,1]\nOutput: 1\nExplanation: \nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\nExample 2:\nInput: stones = [1]\nOutput: 1\nConstraints:\n\t1 <= stones.length <= 30\n\t1 <= stones[i] <= 1000",
        "topics": [
            "Array",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/last-stone-weight/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def lastStoneWeight(self, stones: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} stones\r\n * @return {number}\r\n */\r\nvar lastStoneWeight = function(stones) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int lastStoneWeight(int[] stones) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the i^th worker and wage[i] is the minimum wage expectation for the i^th worker.\nWe want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:\n\tEvery worker in the paid group must be paid at least their minimum wage expectation.\n\tIn the group, each worker's pay must be directly proportional to their quality. This means if a worker\u2019s quality is double that of another worker in the group, then they must be paid twice as much as the other worker.\nGiven the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10^-5 of the actual answer will be accepted.\nExample 1:\nInput: quality = [10,20,5], wage = [70,50,30], k = 2\nOutput: 105.00000\nExplanation: We pay 70 to 0^th worker and 35 to 2^nd worker.\nExample 2:\nInput: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\nOutput: 30.66667\nExplanation: We pay 4 to 0^th worker, 13.33333 to 2^nd and 3^rd workers separately.\nConstraints:\n\tn == quality.length == wage.length\n\t1 <= k <= n <= 10^4\n\t1 <= quality[i], wage[i] <= 10^4",
        "topics": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/minimum-cost-to-hire-k-workers/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} quality\r\n * @param {number[]} wage\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar mincostToHireWorkers = function(quality, wage, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public double mincostToHireWorkers(int[] quality, int[] wage, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You have k lists of sorted integers in non-decreasing\u00a0order. Find the smallest range that includes at least one number from each of the k lists.\nWe define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.\nExample 1:\nInput: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\nOutput: [20,24]\nExplanation: \nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\nList 3: [5, 18, 22, 30], 22 is in range [20,24].\nExample 2:\nInput: nums = [[1,2,3],[1,2,3],[1,2,3]]\nOutput: [1,1]\nConstraints:\n\tnums.length == k\n\t1 <= k <= 3500\n\t1 <= nums[i].length <= 50\n\t-10^5 <= nums[i][j] <= 10^5\n\tnums[i]\u00a0is sorted in non-decreasing order.",
        "topics": [
            "Array",
            "Hash Table",
            "Greedy",
            "Sliding Window",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} nums\r\n * @return {number[]}\r\n */\r\nvar smallestRange = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] smallestRange(List<List<Integer>> nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You have n packages that you are trying to place in boxes, one package in each box. There are m suppliers that each produce boxes of different sizes (with infinite supply). A package can be placed in a box if the size of the package is less than or equal to the size of the box.\nThe package sizes are given as an integer array packages, where packages[i] is the size of the i^th package. The suppliers are given as a 2D integer array boxes, where boxes[j] is an array of box sizes that the j^th supplier produces.\nYou want to choose a single supplier and use boxes from them such that the total wasted space is minimized. For each package in a box, we define the space wasted to be size of the box - size of the package. The total wasted space is the sum of the space wasted in all the boxes.\n\tFor example, if you have to fit packages with sizes [2,3,5] and the supplier offers boxes of sizes [4,8], you can fit the packages of size-2 and size-3 into two boxes of size-4 and the package with size-5 into a box of size-8. This would result in a waste of (4-2) + (4-3) + (8-5) = 6.\nReturn the minimum total wasted space by choosing the box supplier optimally, or -1 if it is impossible to fit all the packages inside boxes. Since the answer may be large, return it modulo 10^9 + 7.\nExample 1:\nInput: packages = [2,3,5], boxes = [[4,8],[2,8]]\nOutput: 6\nExplanation: It is optimal to choose the first supplier, using two size-4 boxes and one size-8 box.\nThe total waste is (4-2) + (4-3) + (8-5) = 6.\nExample 2:\nInput: packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]\nOutput: -1\nExplanation: There is no box that the package of size 5 can fit in.\nExample 3:\nInput: packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]\nOutput: 9\nExplanation: It is optimal to choose the third supplier, using two size-5 boxes, two size-10 boxes, and two size-14 boxes.\nThe total waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9.\nConstraints:\n\tn == packages.length\n\tm == boxes.length\n\t1 <= n <= 10^5\n\t1 <= m <= 10^5\n\t1 <= packages[i] <= 10^5\n\t1 <= boxes[j].length <= 10^5\n\t1 <= boxes[j][k] <= 10^5\n\tsum(boxes[j].length) <= 10^5\n\tThe elements in boxes[j] are distinct.",
        "topics": [
            "Array",
            "Binary Search",
            "Sorting",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/minimum-space-wasted-from-packaging/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} packages\r\n * @param {number[][]} boxes\r\n * @return {number}\r\n */\r\nvar minWastedSpace = function(packages, boxes) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minWastedSpace(int[] packages, int[][] boxes) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied).\nYou are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements:\n\tCover all the empty cells.\n\tDo not cover any of the occupied cells.\n\tWe can put as many stamps as we want.\n\tStamps can overlap with each other.\n\tStamps are not allowed to be rotated.\n\tStamps must stay completely inside the grid.\nReturn true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false.\nExample 1:\nInput: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3\nOutput: true\nExplanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.\nExample 2:\nInput: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 \nOutput: false \nExplanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.\nConstraints:\n\tm == grid.length\n\tn == grid[r].length\n\t1 <= m, n <= 10^5\n\t1 <= m * n <= 2 * 10^5\n\tgrid[r][c] is either 0 or 1.\n\t1 <= stampHeight, stampWidth <= 10^5",
        "topics": [
            "Array",
            "Greedy",
            "Matrix",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/stamping-the-grid/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @param {number} stampHeight\r\n * @param {number} stampWidth\r\n * @return {boolean}\r\n */\r\nvar possibleToStamp = function(grid, stampHeight, stampWidth) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.\nExample 1:\nInput: hours = [9,9,6,0,6,6,9]\nOutput: 3\nExplanation: The longest well-performing interval is [9,9,6].\nExample 2:\nInput: hours = [6,6,6]\nOutput: 0\nConstraints:\n\t1 <= hours.length <= 10^4\n\t0 <= hours[i] <= 16",
        "topics": [
            "Array",
            "Hash Table",
            "Stack",
            "Monotonic Stack",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/longest-well-performing-interval/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def longestWPI(self, hours: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} hours\r\n * @return {number}\r\n */\r\nvar longestWPI = function(hours) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int longestWPI(int[] hours) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array nums, an integer modulo, and an integer k.\nYour task is to find the count of subarrays that are interesting.\nA subarray nums[l..r] is interesting if the following condition holds:\n\tLet cnt be the number of indices i in the range [l, r] such that nums[i] % modulo == k. Then, cnt % modulo == k.\nReturn an integer denoting the count of interesting subarrays. \nNote: A subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nInput: nums = [3,2,4], modulo = 2, k = 1\nOutput: 3\nExplanation: In this example the interesting subarrays are: \nThe subarray nums[0..0] which is [3]. \n- There is only one index, i = 0, in the range [0, 0] that satisfies nums[i] % modulo == k. \n- Hence, cnt = 1 and cnt % modulo == k.  \nThe subarray nums[0..1] which is [3,2].\n- There is only one index, i = 0, in the range [0, 1] that satisfies nums[i] % modulo == k.  \n- Hence, cnt = 1 and cnt % modulo == k.\nThe subarray nums[0..2] which is [3,2,4]. \n- There is only one index, i = 0, in the range [0, 2] that satisfies nums[i] % modulo == k. \n- Hence, cnt = 1 and cnt % modulo == k. \nIt can be shown that there are no other interesting subarrays. So, the answer is 3.\nExample 2:\nInput: nums = [3,1,9,6], modulo = 3, k = 0\nOutput: 2\nExplanation: In this example the interesting subarrays are: \nThe subarray nums[0..3] which is [3,1,9,6]. \n- There are three indices, i = 0, 2, 3, in the range [0, 3] that satisfy nums[i] % modulo == k. \n- Hence, cnt = 3 and cnt % modulo == k. \nThe subarray nums[1..1] which is [1]. \n- There is no index, i, in the range [1, 1] that satisfies nums[i] % modulo == k. \n- Hence, cnt = 0 and cnt % modulo == k. \nIt can be shown that there are no other interesting subarrays. So, the answer is 2.\nConstraints:\n\t1 <= nums.length <= 10^5 \n\t1 <= nums[i] <= 10^9\n\t1 <= modulo <= 10^9\n\t0 <= k < modulo",
        "topics": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/count-of-interesting-subarrays/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} modulo\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar countInterestingSubarrays = function(nums, modulo, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long countInterestingSubarrays(List<Integer> nums, int modulo, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "An ant is on a boundary. It sometimes goes left and sometimes right.\nYou are given an array of non-zero integers nums. The ant starts reading nums from the first element of it to its end. At each step, it moves according to the value of the current element:\n\tIf nums[i] < 0, it moves left by -nums[i] units.\n\tIf nums[i] > 0, it moves right by nums[i] units.\nReturn the number of times the ant returns to the boundary.\nNotes:\n\tThere is an infinite space on both sides of the boundary.\n\tWe check whether the ant is on the boundary only after it has moved |nums[i]| units. In other words, if the ant crosses the boundary during its movement, it does not count.\nExample 1:\nInput: nums = [2,3,-5]\nOutput: 1\nExplanation: After the first step, the ant is 2 steps to the right of the boundary.\nAfter the second step, the ant is 5 steps to the right of the boundary.\nAfter the third step, the ant is on the boundary.\nSo the answer is 1.\nExample 2:\nInput: nums = [3,2,-3,-4]\nOutput: 0\nExplanation: After the first step, the ant is 3 steps to the right of the boundary.\nAfter the second step, the ant is 5 steps to the right of the boundary.\nAfter the third step, the ant is 2 steps to the right of the boundary.\nAfter the fourth step, the ant is 2 steps to the left of the boundary.\nThe ant never returned to the boundary, so the answer is 0.\nConstraints:\n\t1 <= nums.length <= 100\n\t-10 <= nums[i] <= 10\n\tnums[i] != 0",
        "topics": [
            "Array",
            "Simulation",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/ant-on-the-boundary/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def returnToBoundaryCount(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar returnToBoundaryCount = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int returnToBoundaryCount(int[] nums) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:\n\tA word is defined as a character sequence consisting of non-space characters only.\n\tEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n\tThe input array words contains at least one word.\nExample 1:\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n\u00a0 \u00a0\"This \u00a0 \u00a0is \u00a0 \u00a0an\",\n\u00a0 \u00a0\"example \u00a0of text\",\n\u00a0 \u00a0\"justification. \u00a0\"\n]\nExample 2:\nInput: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n\u00a0 \"What \u00a0 must \u00a0 be\",\n\u00a0 \"acknowledgment \u00a0\",\n\u00a0 \"shall be \u00a0 \u00a0 \u00a0 \u00a0\"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\nExample 3:\nInput: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n\u00a0 \"Science \u00a0is \u00a0what we\",\n  \"understand \u00a0 \u00a0 \u00a0well\",\n\u00a0 \"enough to explain to\",\n\u00a0 \"a \u00a0computer. \u00a0Art is\",\n\u00a0 \"everything \u00a0else \u00a0we\",\n\u00a0 \"do \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"\n]\nConstraints:\n\t1 <= words.length <= 300\n\t1 <= words[i].length <= 20\n\twords[i] consists of only English letters and symbols.\n\t1 <= maxWidth <= 100\n\twords[i].length <= maxWidth",
        "topics": [
            "Array",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/text-justification/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string[]} words\r\n * @param {number} maxWidth\r\n * @return {string[]}\r\n */\r\nvar fullJustify = function(words, maxWidth) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<String> fullJustify(String[] words, int maxWidth) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are:\n\tPlayers take turns placing characters into empty squares ' '.\n\tThe first player A always places 'X' characters, while the second player B always places 'O' characters.\n\t'X' and 'O' characters are always placed into empty squares, never on filled ones.\n\tThe game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.\n\tThe game also ends if all squares are non-empty.\n\tNo more moves can be played if the game is over.\nGiven a 2D integer array moves where moves[i] = [rowi, coli] indicates that the i^th move will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B). In case the game ends in a draw return \"Draw\". If there are still movements to play return \"Pending\".\nYou can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first.\nExample 1:\nInput: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]\nOutput: \"A\"\nExplanation: A wins, they always play first.\nExample 2:\nInput: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]\nOutput: \"B\"\nExplanation: B wins.\nExample 3:\nInput: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]\nOutput: \"Draw\"\nExplanation: The game ends in a draw since there are no moves to make.\nConstraints:\n\t1 <= moves.length <= 9\n\tmoves[i].length == 2\n\t0 <= rowi, coli <= 2\n\tThere are no repeated elements on moves.\n\tmoves follow the rules of tic tac toe.",
        "topics": [
            "Array",
            "Hash Table",
            "Matrix",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def tictactoe(self, moves: List[List[int]]) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} moves\r\n * @return {string}\r\n */\r\nvar tictactoe = function(moves) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String tictactoe(int[][] moves) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given two binary strings a and b, return their sum as a binary string.\nExample 1:\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\nExample 2:\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\nConstraints:\n\t1 <= a.length, b.length <= 10^4\n\ta and b consist\u00a0only of '0' or '1' characters.\n\tEach string does not contain leading zeros except for the zero itself.",
        "topics": [
            "Math",
            "String",
            "Bit Manipulation",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/add-binary/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def addBinary(self, a: str, b: str) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} a\r\n * @param {string} b\r\n * @return {string}\r\n */\r\nvar addBinary = function(a, b) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String addBinary(String a, String b) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is a directed graph consisting of n nodes numbered from 0 to n - 1 and n directed edges.\nYou are given a 0-indexed array edges where edges[i] indicates that there is an edge from node i to node edges[i].\nConsider the following process on the graph:\n\tYou start from a node x and keep visiting other nodes through edges until you reach a node that you have already visited before on this same process.\nReturn an array answer where answer[i] is the number of different nodes that you will visit if you perform the process starting from node i.\nExample 1:\nInput: edges = [1,2,0,0]\nOutput: [3,3,3,4]\nExplanation: We perform the process starting from each node in the following way:\n- Starting from node 0, we visit the nodes 0 -> 1 -> 2 -> 0. The number of different nodes we visit is 3.\n- Starting from node 1, we visit the nodes 1 -> 2 -> 0 -> 1. The number of different nodes we visit is 3.\n- Starting from node 2, we visit the nodes 2 -> 0 -> 1 -> 2. The number of different nodes we visit is 3.\n- Starting from node 3, we visit the nodes 3 -> 0 -> 1 -> 2 -> 0. The number of different nodes we visit is 4.\nExample 2:\nInput: edges = [1,2,3,4,0]\nOutput: [5,5,5,5,5]\nExplanation: Starting from any node we can visit every node in the graph in the process.\nConstraints:\n\tn == edges.length\n\t2 <= n <= 10^5\n\t0 <= edges[i] <= n - 1\n\tedges[i] != i",
        "topics": [
            "Dynamic Programming",
            "Graph",
            "Memoization"
        ],
        "url": "https://leetcode.com/problems/count-visited-nodes-in-a-directed-graph/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def countVisitedNodes(self, edges: List[int]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} edges\r\n * @return {number[]}\r\n */\r\nvar countVisitedNodes = function(edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] countVisitedNodes(List<Integer> edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.\nThe graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph.\nThe mouse starts at node 1 and goes first, the cat starts at node 2 and goes second, and there is a hole at node 0.\nDuring each player's turn, they must travel along one\u00a0edge of the graph that meets where they are.\u00a0 For example, if the Mouse is at node 1, it must travel to any node in graph[1].\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0).\nThen, the game can end in three\u00a0ways:\n\tIf ever the Cat occupies the same node as the Mouse, the Cat wins.\n\tIf ever the Mouse reaches the Hole, the Mouse wins.\n\tIf ever a position is repeated (i.e., the players are in the same position as a previous turn, and\u00a0it is the same player's turn to move), the game is a draw.\nGiven a graph, and assuming both players play optimally, return\n\t1\u00a0if the mouse wins the game,\n\t2\u00a0if the cat wins the game, or\n\t0\u00a0if the game is a draw.\nExample 1:\nInput: graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\nOutput: 0\nExample 2:\nInput: graph = [[1,3],[0],[3],[0,2]]\nOutput: 1\nConstraints:\n\t3 <= graph.length <= 50\n\t1\u00a0<= graph[i].length < graph.length\n\t0 <= graph[i][j] < graph.length\n\tgraph[i][j] != i\n\tgraph[i] is unique.\n\tThe mouse and the cat can always move.\u00a0",
        "topics": [
            "Math",
            "Dynamic Programming",
            "Graph",
            "Topological Sort",
            "Memoization",
            "Game Theory"
        ],
        "url": "https://leetcode.com/problems/cat-and-mouse/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def catMouseGame(self, graph: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} graph\r\n * @return {number}\r\n */\r\nvar catMouseGame = function(graph) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int catMouseGame(int[][] graph) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\nThe edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\nReturn the probability that after t seconds the frog is on the vertex target. Answers within 10^-5 of the actual answer will be accepted.\nExample 1:\nInput: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\nOutput: 0.16666666666666666 \nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. \nExample 2:\nInput: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\nOutput: 0.3333333333333333\nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. \nConstraints:\n\t1 <= n <= 100\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t1 <= ai, bi <= n\n\t1 <= t <= 50\n\t1 <= target <= n",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/frog-position-after-t-seconds/description/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} edges\r\n * @param {number} t\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar frogPosition = function(n, edges, t, target) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public double frogPosition(int n, int[][] edges, int t, int target) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nAt every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:\n\tthe price needed to open the gate at node i, if amount[i] is negative, or,\n\tthe cash reward obtained on opening the gate at node i, otherwise.\nThe game goes on as follows:\n\tInitially, Alice is at node 0 and Bob is at node bob.\n\tAt every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.\n\tFor every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:\n\t\tIf the gate is already open, no price will be required, nor will there be any cash reward.\n\t\tIf Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is c, then both Alice and Bob pay\u00a0c / 2 each. Similarly, if the reward at the gate is c, both of them receive c / 2 each.\n\tIf Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node 0, he stops moving. Note that these events are independent of each other.\nReturn the maximum net income Alice can have if she travels towards the optimal leaf node.\nExample 1:\nInput: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]\nOutput: 6\nExplanation: \nThe above diagram represents the given tree. The game goes as follows:\n- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.\n  Alice's net income is now -2.\n- Both Alice and Bob move to node 1. \n\u00a0 Since they reach here simultaneously, they open the gate together and share the reward.\n\u00a0 Alice's net income becomes -2 + (4 / 2) = 0.\n- Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.\n\u00a0 Bob moves on to node 0, and stops moving.\n- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.\nNow, neither Alice nor Bob can make any further moves, and the game ends.\nIt is not possible for Alice to get a higher net income.\nExample 2:\nInput: edges = [[0,1]], bob = 1, amount = [-7280,2350]\nOutput: -7280\nExplanation: \nAlice follows the path 0->1 whereas Bob follows the path 1->0.\nThus, Alice opens the gate at node 0 only. Hence, her net income is -7280. \nConstraints:\n\t2 <= n <= 10^5\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t0 <= ai, bi < n\n\tai != bi\n\tedges represents a valid tree.\n\t1 <= bob < n\n\tamount.length == n\n\tamount[i] is an even integer in the range [-10^4, 10^4].",
        "topics": [
            "Array",
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/most-profitable-path-in-a-tree/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} edges\r\n * @param {number} bob\r\n * @param {number[]} amount\r\n * @return {number}\r\n */\r\nvar mostProfitablePath = function(edges, bob, amount) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\tFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\nExample 2:\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\nExample 3:\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\nConstraints:\n\t1 <= numCourses <= 2000\n\t0 <= prerequisites.length <= numCourses * (numCourses - 1)\n\tprerequisites[i].length == 2\n\t0 <= ai, bi < numCourses\n\tai != bi\n\tAll the pairs [ai, bi] are distinct.",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "url": "https://leetcode.com/problems/course-schedule-ii/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} numCourses\r\n * @param {number[][]} prerequisites\r\n * @return {number[]}\r\n */\r\nvar findOrder = function(numCourses, prerequisites) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes a bidirectional path between garden xi to garden yi. In each garden, you want to plant one of 4 types of flowers.\nAll gardens have at most 3 paths coming into or leaving it.\nYour task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.\nReturn any such a choice as an array answer, where answer[i] is the type of flower planted in the (i+1)^th garden. The flower types are denoted 1, 2, 3, or 4. It is guaranteed an answer exists.\nExample 1:\nInput: n = 3, paths = [[1,2],[2,3],[3,1]]\nOutput: [1,2,3]\nExplanation:\nGardens 1 and 2 have different types.\nGardens 2 and 3 have different types.\nGardens 3 and 1 have different types.\nHence, [1,2,3] is a valid answer. Other valid answers include [1,2,4], [1,4,2], and [3,2,1].\nExample 2:\nInput: n = 4, paths = [[1,2],[3,4]]\nOutput: [1,2,1,2]\nExample 3:\nInput: n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]\nOutput: [1,2,3,4]\nConstraints:\n\t1 <= n <= 10^4\n\t0 <= paths.length <= 2 * 10^4\n\tpaths[i].length == 2\n\t1 <= xi, yi <= n\n\txi != yi\n\tEvery garden has at most 3 paths coming into or leaving it.",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/flower-planting-with-no-adjacent/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def gardenNoAdj(self, n: int, paths: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} paths\r\n * @return {number[]}\r\n */\r\nvar gardenNoAdj = function(n, paths) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] gardenNoAdj(int n, int[][] paths) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nYou want to determine if there is a valid path that exists from vertex source to vertex destination.\nGiven edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.\nExample 1:\nInput: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2\nOutput: true\nExplanation: There are two paths from vertex 0 to vertex 2:\n- 0 \u2192 1 \u2192 2\n- 0 \u2192 2\nExample 2:\nInput: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5\nOutput: false\nExplanation: There is no path from vertex 0 to vertex 5.\nConstraints:\n\t1 <= n <= 2 * 10^5\n\t0 <= edges.length <= 2 * 10^5\n\tedges[i].length == 2\n\t0 <= ui, vi <= n - 1\n\tui != vi\n\t0 <= source, destination <= n - 1\n\tThere are no duplicate edges.\n\tThere are no self edges.",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/find-if-path-exists-in-graph/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} edges\r\n * @param {number} source\r\n * @param {number} destination\r\n * @return {boolean}\r\n */\r\nvar validPath = function(n, edges, source, destination) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public boolean validPath(int n, int[][] edges, int source, int destination) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an array nums that consists of positive integers.\nThe GCD of a sequence of numbers is defined as the greatest integer that divides all the numbers in the sequence evenly.\n\tFor example, the GCD of the sequence [4,6,16] is 2.\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\tFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\nReturn the number of different GCDs among all non-empty subsequences of nums.\nExample 1:\nInput: nums = [6,10,3]\nOutput: 5\nExplanation: The figure shows all the non-empty subsequences and their GCDs.\nThe different GCDs are 6, 10, 3, 2, and 1.\nExample 2:\nInput: nums = [5,15,40,5,6]\nOutput: 7\nConstraints:\n\t1 <= nums.length <= 10^5\n\t1 <= nums[i] <= 2 * 10^5",
        "topics": [
            "undefined"
        ],
        "url": "https://leetcode.com/problems/number-of-different-subsequences-gcds/description/",
        "difficulty": "Hard",
        "givenPythonCode": "\r\n",
        "givenJsCode": "\r\n",
        "givenJavaCode": "\r\n"
    },
    {
        "excercise": "You are given a string s. s[i] is either a lowercase English letter or '?'.\nFor a string t having length m containing only lowercase English letters, we define the function cost(i) for an index i\u00a0as the number of characters equal to t[i]\u00a0that appeared before it, i.e. in the range [0, i - 1].\nThe value of t is the sum of cost(i) for all indices i.\nFor example, for the string t = \"aab\":\n\tcost(0) = 0\n\tcost(1) = 1\n\tcost(2) = 0\n\tHence, the value of \"aab\" is 0 + 1 + 0 = 1.\nYour task is to replace all occurrences of '?' in s with any lowercase English letter so that the value of s is minimized.\nReturn a string denoting the modified string with replaced occurrences of '?'. If there are multiple strings resulting in the minimum value, return the lexicographically smallest one.\nExample 1:\nInput:   s = \"???\" \nOutput:   \"abc\" \nExplanation:  In this example, we can replace the occurrences of '?' to make s equal to \"abc\".\nFor \"abc\", cost(0) = 0, cost(1) = 0, and cost(2) = 0.\nThe value of \"abc\" is 0.\nSome other modifications of s that have a value of 0 are \"cba\", \"abz\", and, \"hey\".\nAmong all of them, we choose the lexicographically smallest.\nExample 2:\nInput:  s = \"a?a?\"\nOutput:  \"abac\"\nExplanation:  In this example, the occurrences of '?' can be replaced to make s equal to \"abac\".\nFor \"abac\", cost(0) = 0, cost(1) = 0, cost(2) = 1, and cost(3) = 0.\nThe value of \"abac\" is\u00a01.\nConstraints:\n\t1 <= s.length <= 10^5\n\ts[i] is either a lowercase English letter or '?'.",
        "topics": [
            "Hash Table",
            "String",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/replace-question-marks-in-string-to-minimize-its-value/description/",
        "difficulty": "Medium",
        "givenPythonCode": "\r\n",
        "givenJsCode": "\r\n",
        "givenJavaCode": "\r\n"
    },
    {
        "excercise": "You are given a string s, which is known to be a concatenation of anagrams of some string t.\nReturn the minimum possible length of the string t.\nAn anagram is formed by rearranging the letters of a string. For example, \"aab\", \"aba\", and, \"baa\" are anagrams of \"aab\".\nExample 1:\nInput: s = \"abba\"\nOutput: 2\nExplanation:\nOne possible string t could be \"ba\".\nExample 2:\nInput: s = \"cdef\"\nOutput: 4\nExplanation:\nOne possible string t could be \"cdef\", notice that t can be equal to s.\nConstraints:\n\t1 <= s.length <= 10^5\n\ts consist only of lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/minimum-length-of-anagram-concatenation/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def minAnagramLength(self, s: str) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar minAnagramLength = function(s) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minAnagramLength(String s) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.\nExample 1:\nInput: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\nOutput: \"ball\"\nExplanation: \n\"hit\" occurs 3 times, but it is a banned word.\n\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as \"ball,\"), \nand that \"hit\" isn't the answer even though it occurs more because it is banned.\nExample 2:\nInput: paragraph = \"a.\", banned = []\nOutput: \"a\"\nConstraints:\n\t1 <= paragraph.length <= 1000\n\tparagraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".\n\t0 <= banned.length <= 100\n\t1 <= banned[i].length <= 10\n\tbanned[i] consists of only lowercase English letters.",
        "topics": [
            "Array",
            "Hash Table",
            "String",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/most-common-word/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} paragraph\r\n * @param {string[]} banned\r\n * @return {string}\r\n */\r\nvar mostCommonWord = function(paragraph, banned) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public String mostCommonWord(String paragraph, String[] banned) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:\n\tThe length of the subarray is k, and\n\tAll the elements of the subarray are distinct.\nReturn the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0.\nA subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nInput: nums = [1,5,4,2,9,9,9], k = 3\nOutput: 15\nExplanation: The subarrays of nums with length 3 are:\n- [1,5,4] which meets the requirements and has a sum of 10.\n- [5,4,2] which meets the requirements and has a sum of 11.\n- [4,2,9] which meets the requirements and has a sum of 15.\n- [2,9,9] which does not meet the requirements because the element 9 is repeated.\n- [9,9,9] which does not meet the requirements because the element 9 is repeated.\nWe return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions\nExample 2:\nInput: nums = [4,4,4], k = 3\nOutput: 0\nExplanation: The subarrays of nums with length 3 are:\n- [4,4,4] which does not meet the requirements because the element 4 is repeated.\nWe return 0 because no subarrays meet the conditions.\nConstraints:\n\t1 <= k <= nums.length <= 10^5\n\t1 <= nums[i] <= 10^5",
        "topics": [
            "Array",
            "Hash Table",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar maximumSubarraySum = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public long maximumSubarraySum(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.\nReturn the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.\nExample 1:\nInput: s = \"aabaaaacaabc\", k = 2\nOutput: 8\nExplanation: \nTake three characters from the left of s. You now have two 'a' characters, and one 'b' character.\nTake five characters from the right of s. You now have four 'a' characters, two 'b' characters, and two 'c' characters.\nA total of 3 + 5 = 8 minutes is needed.\nIt can be proven that 8 is the minimum number of minutes needed.\nExample 2:\nInput: s = \"a\", k = 1\nOutput: -1\nExplanation: It is not possible to take one 'b' or 'c' so return -1.\nConstraints:\n\t1 <= s.length <= 10^5\n\ts consists of only the letters 'a', 'b', and 'c'.\n\t0 <= k <= s.length",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def takeCharacters(self, s: str, k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string} s\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar takeCharacters = function(s, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int takeCharacters(String s, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an integer array nums consisting of n elements, and an integer k.\nFind a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10^-5 will be accepted.\nExample 1:\nInput: nums = [1,12,-5,-6,50,3], k = 4\nOutput: 12.75000\nExplanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75\nExample 2:\nInput: nums = [5], k = 1\nOutput: 5.00000\nConstraints:\n\tn == nums.length\n\t1 <= k <= n <= 10^5\n\t-10^4 <= nums[i] <= 10^4",
        "topics": [
            "Array",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/maximum-average-subarray-i/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def findMaxAverage(self, nums: List[int], k: int) -> float:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar findMaxAverage = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public double findMaxAverage(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a 0-indexed integer array nums, where nums[i] represents the score of the i^th student. You are also given an integer k.\nPick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.\nReturn the minimum possible difference.\nExample 1:\nInput: nums = [90], k = 1\nOutput: 0\nExplanation: There is one way to pick score(s) of one student:\n- [90]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.\nExample 2:\nInput: nums = [9,4,1,7], k = 2\nOutput: 2\nExplanation: There are six ways to pick score(s) of two students:\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.\n- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2.\nConstraints:\n\t1 <= k <= nums.length <= 1000\n\t0 <= nums[i] <= 10^5",
        "topics": [
            "Array",
            "Sliding Window",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/description/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def minimumDifference(self, nums: List[int], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar minimumDifference = function(nums, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minimumDifference(int[] nums, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an array of positive integers nums.\nYou need to select a subset of nums which satisfies the following condition:\n\tYou can place the selected elements in a 0-indexed array such that it follows the pattern: [x, x^2, x^4, ..., x^k/2, x^k, x^k/2, ..., x^4, x^2, x] (Note that k can be be any non-negative power of 2). For example, [2, 4, 16, 4, 2] and [3, 9, 3] follow the pattern while [2, 4, 8, 4, 2] does not.\nReturn the maximum number of elements in a subset that satisfies these conditions.\nExample 1:\nInput: nums = [5,4,1,2,2]\nOutput: 3\nExplanation: We can select the subset {4,2,2}, which can be placed in the array as [2,4,2] which follows the pattern and 2^2 == 4. Hence the answer is 3.\nExample 2:\nInput: nums = [1,3,2,4]\nOutput: 1\nExplanation: We can select the subset {1}, which can be placed in the array as [1] which follows the pattern. Hence the answer is 1. Note that we could have also selected the subsets {2}, {3}, or {4}, there may be multiple subsets which provide the same answer. \nConstraints:\n\t2 <= nums.length <= 10^5\n\t1 <= nums[i] <= 10^9",
        "topics": [
            "Array",
            "Hash Table",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/find-the-maximum-number-of-elements-in-subset/description/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def maximumLength(self, nums: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maximumLength = function(nums) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int maximumLength(int[] nums) {\r\n        \r\n    }\r\n}"
    }
]