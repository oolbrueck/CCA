[
    {
        "excercise": "You are given an integer array cards of length 4. You have four cards, each containing a number in the range [1, 9]. You should arrange the numbers on these cards in a mathematical expression using the operators ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24.\nYou are restricted with the following rules:\n\tThe division operator '/' represents real division, not integer division.\n\t\tFor example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.\n\tEvery operation done is between two numbers. In particular, we cannot use '-' as a unary operator.\n\t\tFor example, if cards = [1, 1, 1, 1], the expression \"-1 - 1 - 1 - 1\" is not allowed.\n\tYou cannot concatenate numbers together\n\t\tFor example, if cards = [1, 2, 1, 2], the expression \"12 + 12\" is not valid.\nReturn true if you can get such expression that evaluates to 24, and false otherwise.\nExample 1:\nInput: cards = [4,1,8,7]\nOutput: true\nExplanation: (8-4) * (7-1) = 24\nExample 2:\nInput: cards = [1,2,1,2]\nOutput: false\nConstraints:\n\tcards.length == 4\n\t1 <= cards[i] <= 9",
        "topics": [
            "Array",
            "Math",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/24-game/",
        "givenPythonCode": "class Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        ",
        "givenJsCode": "class Solution {\n    public boolean judgePoint24(int[] cards) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} cards\n * @return {boolean}\n */\nvar judgePoint24 = function(cards) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.\nExample 1:\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\nExample 2:\nInput: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\nConstraints:\n\t3 <= nums.length <= 500\n\t-1000 <= nums[i] <= 1000\n\t-10^4 <= target <= 10^4",
        "topics": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/3sum-closest/",
        "givenPythonCode": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threeSumClosest = function(nums, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "ung\u00fcltig"
    },
    {
        "excercise": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\nExample 2:\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\nExample 3:\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\nConstraints:\n\t3 <= nums.length <= 3000\n\t-10^5 <= nums[i] <= 10^5",
        "topics": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/3sum/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\n                while (lo < hi) {\n                    if (nums[lo] + nums[hi] == sum) {\n                        res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));\n                        while (lo < hi && nums[lo] == nums[lo + 1]) lo++;\n                        while (lo < hi && nums[hi] == nums[hi - 1]) hi--;\n                        lo++;\n                        hi--;\n                    } else if (nums[lo] + nums[hi] < sum) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n}\n\n",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\n\t0 <= i, j, k, l < n\n\tnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\nExample 1:\nInput: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\nOutput: 2\nExplanation:\nThe two tuples are:\n1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\nExample 2:\nInput: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\nOutput: 1\nConstraints:\n\tn == nums1.length\n\tn == nums2.length\n\tn == nums3.length\n\tn == nums4.length\n\t1 <= n <= 200\n\t-2^28 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 2^28",
        "topics": [
            "Array",
            "Hash Table"
        ],
        "url": "https://leetcode.com/problems/4sum-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number[]} nums3\n * @param {number[]} nums4\n * @return {number}\n */\nvar fourSumCount = function(nums1, nums2, nums3, nums4) {\n    \n};",
        "givenJsCode": "class Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\t0 <= a, b, c, d < n\n\ta, b, c, and d are distinct.\n\tnums[a] + nums[b] + nums[c] + nums[d] == target\nYou may return the answer in any order.\nExample 1:\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\nExample 2:\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\nConstraints:\n\t1 <= nums.length <= 200\n\t-10^9 <= nums[i] <= 10^9\n\t-10^9 <= target <= 10^9",
        "topics": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/4sum/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nvar fourSum = function(nums, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two binary strings a and b, return their sum as a binary string.\nExample 1:\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\nExample 2:\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\nConstraints:\n\t1 <= a.length, b.length <= 10^4\n\ta and b consist only of '0' or '1' characters.\n\tEach string does not contain leading zeros except for the zero itself.",
        "topics": [
            "Math",
            "String",
            "Bit Manipulation",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/add-binary/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} a\n * @param {string} b\n * @return {string}\n */\nvar addBinary = function(a, b) {\n    \n};",
        "givenJsCode": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String addBinary(String a, String b) {\n        \n    }\n}"
    },
    {
        "excercise": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.\nExample 1:\nInput: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"\nExample 2:\nInput: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"\nExample 3:\nInput: num1 = \"0\", num2 = \"0\"\nOutput: \"0\"\nConstraints:\n\t1 <= num1.length, num2.length <= 10^4\n\tnum1 and num2 consist of only digits.\n\tnum1 and num2 don't have any leading zeros except for the zero itself.",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/add-strings/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar addStrings = function(num1, num2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String addStrings(String num1, String num2) {\n        \n    }\n}"
    },
    {
        "excercise": "An additive number is a string whose digits can form an additive sequence.\nA valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\nGiven a string containing only digits, return true if it is an additive number or false otherwise.\nNote: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\nExample 1:\nInput: \"112358\"\nOutput: true\nExplanation: \nThe digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\nExample 2:\nInput: \"199100199\"\nOutput: true\nExplanation: \nThe additive sequence is: 1, 99, 100, 199. \n1 + 99 = 100, 99 + 100 = 199\nConstraints:\n\t1 <= num.length <= 35\n\tnum consists only of digits.\nFollow up: How would you handle overflow for very large input integers?",
        "topics": [
            "String",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/additive-number/",
        "givenPythonCode": "/**\n * @param {string} num\n * @return {boolean}\n */\nvar isAdditiveNumber = function(num) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isAdditiveNumber(String num) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\tFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\n\tFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\tFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\nThe test cases are generated so that the answer fits in 32-bit integer.\nExample 1:\nInput: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]\nExample 2:\nInput: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic.\nConstraints:\n\t1  <= nums.length <= 1000\n\t-2^31 <= nums[i] <= 2^31 - 1",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/arithmetic-slices-ii-subsequence/",
        "givenPythonCode": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int numberOfArithmeticSlices(int[] nums) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfArithmeticSlices = function(nums) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\tFor example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.\nGiven an integer array nums, return the number of arithmetic subarrays of nums.\nA subarray is a contiguous subsequence of the array.\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: 3\nExplanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.\nExample 2:\nInput: nums = [1]\nOutput: 0\nConstraints:\n\t1 <= nums.length <= 5000\n\t-1000 <= nums[i] <= 1000",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/arithmetic-slices/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfArithmeticSlices = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int numberOfArithmeticSlices(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].\nYou should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:\n\tThe first element in s[k] starts with the selection of the element nums[k] of index = k.\n\tThe next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.\n\tWe stop adding right before a duplicate element occurs in s[k].\nReturn the longest length of a set s[k].\nExample 1:\nInput: nums = [5,4,0,3,1,6,2]\nOutput: 4\nExplanation: \nnums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.\nOne of the longest sets s[k]:\ns[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}\nExample 2:\nInput: nums = [0,1,2]\nOutput: 1\nConstraints:\n\t1 <= nums.length <= 10^5\n\t0 <= nums[i] < nums.length\n\tAll the values of nums are unique.",
        "topics": [
            "Array",
            "Depth-First Search"
        ],
        "url": "https://leetcode.com/problems/array-nesting/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar arrayNesting = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def arrayNesting(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int arrayNesting(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\nExample 1:\nInput: g = [1,2,3], s = [1,1]\nOutput: 1\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\nExample 2:\nInput: g = [1,2], s = [1,2,3]\nOutput: 2\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\nConstraints:\n\t1 <= g.length <= 3 * 10^4\n\t0 <= s.length <= 3 * 10^4\n\t1 <= g[i], s[j] <= 2^31 - 1",
        "topics": [
            "Array",
            "Two Pointers",
            "Greedy",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/assign-cookies/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} g\n * @param {number[]} s\n * @return {number}\n */\nvar findContentChildren = function(g, s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string s which represents an expression, evaluate this expression and return its value. \nThe integer division should truncate toward zero.\nYou may assume that the given expression is always valid. All intermediate results will be in the range of [-2^31, 2^31 - 1].\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\nExample 1:\nInput: s = \"3+2*2\"\nOutput: 7\nExample 2:\nInput: s = \" 3/2 \"\nOutput: 1\nExample 3:\nInput: s = \" 3+5 / 2 \"\nOutput: 5\nConstraints:\n\t1 <= s.length <= 3 * 10^5\n\ts consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces.\n\ts represents a valid expression.\n\tAll the integers in the expression are non-negative integers in the range [0, 2^31 - 1].\n\tThe answer is guaranteed to fit in a 32-bit integer.",
        "topics": [
            "Math",
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/basic-calculator-ii/",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar calculate = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def calculate(self, s: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int calculate(String s) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an integer array prices where prices[i] is the price of a given stock on the i^th day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nExample 2:\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\nExample 3:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\nConstraints:\n\t1 <= prices.length <= 3 * 10^4\n\t0 <= prices[i] <= 10^4",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/",
        "givenPythonCode": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};",
        "givenJsCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\nFind the maximum profit you can achieve. You may complete at most two transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\nExample 3:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\nConstraints:\n\t1 <= prices.length <= 10^5\n\t0 <= prices[i] <= 10^5",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/",
        "givenPythonCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an integer array prices where prices[i] is the price of a given stock on the i^th day, and an integer k.\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\nExample 2:\nInput: k = 2, prices = [3,2,6,5,0,3]\nOutput: 7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nConstraints:\n\t1 <= k <= 100\n\t1 <= prices.length <= 1000\n\t0 <= prices[i] <= 1000",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/",
        "givenPythonCode": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "givenJsCode": "/**\n * @param {number} k\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(k, prices) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int maxProfit(int k, int[] prices) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\tAfter you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nInput: prices = [1,2,3,0,2]\nOutput: 3\nExplanation: transactions = [buy, sell, cooldown, buy, sell]\nExample 2:\nInput: prices = [1]\nOutput: 0\nConstraints:\n\t1 <= prices.length <= 5000\n\t0 <= prices[i] <= 1000",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/",
        "givenPythonCode": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};",
        "givenJsCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\nExample 1:\nInput: left = 5, right = 7\nOutput: 4\nExample 2:\nInput: left = 0, right = 0\nOutput: 0\nExample 3:\nInput: left = 1, right = 2147483647\nOutput: 0\nConstraints:\n\t0 <= left <= right <= 2^31 - 1",
        "topics": [
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/",
        "givenPythonCode": "/**\n * @param {number} left\n * @param {number} right\n * @return {number}\n */\nvar rangeBitwiseAnd = function(left, right) {\n    \n};",
        "givenJsCode": "class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int rangeBitwiseAnd(int left, int right) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are playing the Bulls and Cows game with your friend.\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\n\tThe number of \"bulls\", which are digits in the guess that are in the correct position.\n\tThe number of \"cows\", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.\nGiven the secret number secret and your friend's guess guess, return the hint for your friend's guess.\nThe hint should be formatted as \"xAyB\", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.\nExample 1:\nInput: secret = \"1807\", guess = \"7810\"\nOutput: \"1A3B\"\nExplanation: Bulls are connected with a '|' and cows are underlined:\n\"1807\"\n  |\n\"7810\"\nExample 2:\nInput: secret = \"1123\", guess = \"0111\"\nOutput: \"1A1B\"\nExplanation: Bulls are connected with a '|' and cows are underlined:\n\"1123\"        \"1123\"\n  |      or     |\n\"0111\"        \"0111\"\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\nConstraints:\n\t1 <= secret.length, guess.length <= 1000\n\tsecret.length == guess.length\n\tsecret and guess consist of digits only.",
        "topics": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/bulls-and-cows/",
        "givenPythonCode": "/**\n * @param {string} secret\n * @param {string} guess\n * @return {string}\n */\nvar getHint = function(secret, guess) {\n    \n};",
        "givenJsCode": "class Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String getHint(String secret, String guess) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\nIf you burst the i^th balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\nReturn the maximum coins you can collect by bursting the balloons wisely.\nExample 1:\nInput: nums = [3,1,5,8]\nOutput: 167\nExplanation:\nnums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\nExample 2:\nInput: nums = [1,5]\nOutput: 10\nConstraints:\n\tn == nums.length\n\t1 <= n <= 300\n\t0 <= nums[i] <= 100",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/burst-balloons/",
        "givenPythonCode": "class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int maxCoins(int[] nums) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxCoins = function(nums) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an array routes representing bus routes where routes[i] is a bus route that the i^th bus repeats forever.\n\tFor example, if routes[0] = [1, 5, 7], this means that the 0^th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.\nYou will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.\nReturn the least number of buses you must take to travel from source to target. Return -1 if it is not possible.\nExample 1:\nInput: routes = [[1,2,7],[3,6,7]], source = 1, target = 6\nOutput: 2\nExplanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\nExample 2:\nInput: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\nOutput: -1\nConstraints:\n\t1 <= routes.length <= 500.\n\t1 <= routes[i].length <= 10^5\n\tAll the values of routes[i] are unique.\n\tsum(routes[i].length) <= 10^5\n\t0 <= routes[i][j] < 10^6\n\t0 <= source, target < 10^6",
        "topics": [
            "Array",
            "Hash Table",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/bus-routes/",
        "givenPythonCode": "class Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int numBusesToDestination(int[][] routes, int source, int target) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[][]} routes\n * @param {number} source\n * @param {number} target\n * @return {number}\n */\nvar numBusesToDestination = function(routes, source, target) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\n\tEach child must have at least one candy.\n\tChildren with a higher rating get more candies than their neighbors.\nReturn the minimum number of candies you need to have to distribute the candies to the children.\nExample 1:\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\nExample 2:\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\nConstraints:\n\tn == ratings.length\n\t1 <= n <= 2 * 10^4\n\t0 <= ratings[i] <= 2 * 10^4",
        "topics": [
            "Array",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/candy/",
        "givenPythonCode": "class Solution:\n    def candy(self, ratings: List[int]) -> int:",
        "givenJsCode": "/**\n * @param {number[]} ratings\n * @return {number}\n */\nvar candy = function(ratings) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int candy(int[] ratings) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\nYou may assume that you have an infinite number of each kind of coin.\nThe answer is guaranteed to fit into a signed 32-bit integer.\nExample 1:\nInput: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nExample 2:\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.\nExample 3:\nInput: amount = 10, coins = [10]\nOutput: 1\nConstraints:\n\t1 <= coins.length <= 300\n\t1 <= coins[i] <= 5000\n\tAll the values of coins are unique.\n\t0 <= amount <= 5000",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/coin-change-ii/",
        "givenPythonCode": "/**\n * @param {number} amount\n * @param {number[]} coins\n * @return {number}\n */\nvar change = function(amount, coins) {\n    \n};",
        "givenJsCode": "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int change(int amount, int[] coins) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExample 1:\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\nExample 2:\nInput: coins = [2], amount = 3\nOutput: -1\nExample 3:\nInput: coins = [1], amount = 0\nOutput: 0\nConstraints:\n\t1 <= coins.length <= 12\n\t1 <= coins[i] <= 2^31 - 1\n\t0 <= amount <= 10^4",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/coin-change/",
        "givenPythonCode": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nvar coinChange = function(coins, amount) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        \n    }\n}",
        "difficulty": "LeetCode Logo\r\nProblem List\r\n0\r\n\r\navatar\r\nPremium\r\nDebugging...\r\nDebugging...\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nRun\r\nDescription\r\nEditorial\r\nEditorial\r\nSolutions\r\nSolutions\r\nSubmissions\r\nSubmissions\r\n\r\n\r\nCode\r\nTestcase\r\nTest Result\r\nTest Result\r\n518. Coin Change II\r\nMedium\r\nTopics\r\nCompanies\r\nYou are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\r\n\r\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\r\n\r\nYou may assume that you have an infinite number of each kind of coin.\r\n\r\nThe answer is guaranteed to fit into a signed 32-bit integer.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: amount = 5, coins = [1,2,5]\r\nOutput: 4\r\nExplanation: there are four ways to make up the amount:\r\n5=5\r\n5=2+2+1\r\n5=2+1+1+1\r\n5=1+1+1+1+1\r\nExample 2:\r\n\r\nInput: amount = 3, coins = [2]\r\nOutput: 0\r\nExplanation: the amount of 3 cannot be made up just with coins of 2.\r\nExample 3:\r\n\r\nInput: amount = 10, coins = [10]\r\nOutput: 1\r\n \r\n\r\nConstraints:\r\n\r\n1 <= coins.length <= 300\r\n1 <= coins[i] <= 5000\r\nAll the values of coins are unique.\r\n0 <= amount <= 5000\r\nSeen this question in a real interview before?\r\n1/5\r\nYes\r\nNo\r\nAccepted\r\n657K\r\nSubmissions\r\n1M\r\nAcceptance Rate\r\n64.4%\r\nTopics\r\nCompanies\r\nSimilar Questions\r\nDiscussion (81)\r\n\r\nChoose a type\r\n\r\n\r\n\r\nCopyright \u00a9\ufe0f 2024 LeetCode All rights reserved\r\n\r\n9.4K\r\n\r\n\r\n81\r\n\r\n\r\n\r\nJavaScript\r\nAuto\r\n\r\n\r\n\r\n\r\n\r\n12345678\r\n/**\r\n * @param {number} amount\r\n * @param {number[]} coins\r\n * @return {number}\r\n */\r\nvar change = function(amount, coins) {\r\n    \r\n};\r\nSaved\r\nCase 1\r\nCase 2\r\nCase 3\r\n\r\namount =\r\n5\r\ncoins =\r\n[1,2,5]\r\n1\r\n5\r\n[1,2,5]\r\n3\r\n[2]\r\n10\r\n[10]\r\n"
    },
    {
        "excercise": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.\nExample 1:\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\nExample 2:\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\nConstraints:\n\t1 <= candidates.length <= 100\n\t1 <= candidates[i] <= 50\n\t1 <= target <= 30",
        "topics": [
            "Array",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/combination-sum-ii/",
        "givenPythonCode": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\n\tOnly numbers 1 through 9 are used.\n\tEach number is used at most once.\nReturn a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\nExample 1:\nInput: k = 3, n = 7\nOutput: [[1,2,4]]\nExplanation:\n1 + 2 + 4 = 7\nThere are no other valid combinations.\nExample 2:\nInput: k = 3, n = 9\nOutput: [[1,2,6],[1,3,5],[2,3,4]]\nExplanation:\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\nExample 3:\nInput: k = 4, n = 1\nOutput: []\nExplanation: There are no valid combinations.\nUsing 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.\nConstraints:\n\t2 <= k <= 9\n\t1 <= n <= 60",
        "topics": [
            "Array",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/combination-sum-iii/",
        "givenPythonCode": "/**\n * @param {number} k\n * @param {number} n\n * @return {number[][]}\n */\nvar combinationSum3 = function(k, n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\nThe test cases are generated so that the answer can fit in a 32-bit integer.\nExample 1:\nInput: nums = [1,2,3], target = 4\nOutput: 7\nExplanation:\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\nExample 2:\nInput: nums = [9], target = 3\nOutput: 0\nConstraints:\n\t1 <= nums.length <= 200\n\t1 <= nums[i] <= 1000\n\tAll the elements of nums are unique.\n\t1 <= target <= 1000\nFollow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/combination-sum-iv/",
        "givenPythonCode": "class Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar combinationSum4 = function(nums, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int combinationSum4(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\nExample 1:\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\nExample 2:\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\nExample 3:\nInput: candidates = [2], target = 1\nOutput: []\nConstraints:\n\t1 <= candidates.length <= 30\n\t2 <= candidates[i] <= 40\n\tAll elements of candidates are distinct.\n\t1 <= target <= 40",
        "topics": [
            "Array",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/combination-sum/",
        "givenPythonCode": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        ",
        "givenJsCode": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function(candidates, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.\nExample 1:\nInput: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\nExample 2:\nInput: n = 1, k = 1\nOutput: [[1]]\nExplanation: There is 1 choose 1 = 1 total combination.\nConstraints:\n\t1 <= n <= 20\n\t1 <= k <= n",
        "topics": [
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/combinations/",
        "givenPythonCode": "/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two version strings, version1 and version2, compare them. A version string consists of revisions separated by dots '.'. The value of the revision is its integer conversion ignoring leading zeros.\nTo compare version strings, compare their revision values in left-to-right order. If one of the version strings has fewer revisions, treat the missing revision values as 0.\nReturn the following:\n\tIf version1 < version2, return -1.\n\tIf version1 > version2, return 1.\n\tOtherwise, return 0.\nExample 1:\nInput: version1 = \"1.2\", version2 = \"1.10\"\nOutput: -1\nExplanation:\nversion1's second revision is \"2\" and version2's second revision is \"10\": 2 < 10, so version1 < version2.\nExample 2:\nInput: version1 = \"1.01\", version2 = \"1.001\"\nOutput: 0\nExplanation:\nIgnoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\".\nExample 3:\nInput: version1 = \"1.0\", version2 = \"1.0.0.0\"\nOutput: 0\nExplanation:\nversion1 has less revisions, which means every missing revision are treated as \"0\".\nConstraints:\n\t1 <= version1.length, version2.length <= 500\n\tversion1 and version2 only contain digits and '.'.\n\tversion1 and version2 are valid version numbers.\n\tAll the given revisions in version1 and version2 can be stored in a 32-bit integer.",
        "topics": [
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/compare-version-numbers/",
        "givenPythonCode": "/**\n * @param {string} version1\n * @param {string} version2\n * @return {number}\n */\nvar compareVersion = function(version1, version2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int compareVersion(String version1, String version2) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A complex number can be represented as a string on the form \"real+imaginaryi\" where:\n\treal is the real part and is an integer in the range [-100, 100].\n\timaginary is the imaginary part and is an integer in the range [-100, 100].\n\ti^2 == -1.\nGiven two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications.\nExample 1:\nInput: num1 = \"1+1i\", num2 = \"1+1i\"\nOutput: \"0+2i\"\nExplanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.\nExample 2:\nInput: num1 = \"1+-1i\", num2 = \"1+-1i\"\nOutput: \"0+-2i\"\nExplanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.\nConstraints:\n\tnum1 and num2 are valid complex numbers.",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/complex-number-multiplication/",
        "givenPythonCode": "/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar complexNumberMultiply = function(num1, num2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String complexNumberMultiply(String num1, String num2) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.\nExample 1:\nInput: nums = [1,2,3,1], k = 3\nOutput: true\nExample 2:\nInput: nums = [1,0,1,1], k = 1\nOutput: true\nExample 3:\nInput: nums = [1,2,3,1,2,3], k = 2\nOutput: false\nConstraints:\n\t1 <= nums.length <= 10^5\n\t-10^9 <= nums[i] <= 10^9\n\t0 <= k <= 10^5",
        "topics": [
            "Array",
            "Hash Table",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/contains-duplicate-ii/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {boolean}\n */\nvar containsNearbyDuplicate = function(nums, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: true\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: false\nExample 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\nConstraints:\n\t1 <= nums.length <= 10^5\n\t-10^9 <= nums[i] <= 10^9",
        "topics": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/contains-duplicate/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar containsDuplicate = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.\nExample 1:\nInput: nums = [0,1]\nOutput: 2\nExplanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\nExample 2:\nInput: nums = [0,1,0]\nOutput: 2\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\nConstraints:\n\t1 <= nums.length <= 10^5\n\tnums[i] is either 0 or 1.",
        "topics": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/contiguous-array/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxLength = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findMaxLength(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findMaxLength(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.\nA good subarray is a subarray where:\n\tits length is at least two, and\n\tthe sum of the elements of the subarray is a multiple of k.\nNote that:\n\tA subarray is a contiguous part of the array.\n\tAn integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.\nExample 1:\nInput: nums = [23,2,4,6,7], k = 6\nOutput: true\nExplanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\nExample 2:\nInput: nums = [23,2,6,4,7], k = 6\nOutput: true\nExplanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\nExample 3:\nInput: nums = [23,2,6,4,7], k = 13\nOutput: false\nConstraints:\n\t1 <= nums.length <= 10^5\n\t0 <= nums[i] <= 10^9\n\t0 <= sum(nums[i]) <= 2^31 - 1\n\t1 <= k <= 2^31 - 1",
        "topics": [
            "Array",
            "Hash Table",
            "Math",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/continuous-subarray-sum/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {boolean}\n */\nvar checkSubarraySum = function(nums, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        \n    }\n}",
        "difficulty": "LeetCode Logo\r\nProblem List\r\n-\r\n\r\navatar\r\nPremium\r\nDebugging...\r\nDebugging...\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nRun\r\nDescription\r\nEditorial\r\nEditorial\r\nSolutions\r\nSolutions\r\nSubmissions\r\nSubmissions\r\n\r\n\r\nCode\r\nTestcase\r\nTest Result\r\nTest Result\r\n525. Contiguous Array\r\nMedium\r\nTopics\r\nCompanies\r\nGiven a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [0,1]\r\nOutput: 2\r\nExplanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\r\nExample 2:\r\n\r\nInput: nums = [0,1,0]\r\nOutput: 2\r\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\r\n \r\n\r\nConstraints:\r\n\r\n1 <= nums.length <= 105\r\nnums[i] is either 0 or 1.\r\n\r\nSeen this question in a real interview before?\r\n1/5\r\nYes\r\nNo\r\nAccepted\r\n467.7K\r\nSubmissions\r\n955.4K\r\nAcceptance Rate\r\n49.0%\r\nTopics\r\nCompanies\r\nSimilar Questions\r\nDiscussion (95)\r\n\r\nChoose a type\r\n\r\n\r\n\r\nCopyright \u00a9\ufe0f 2024 LeetCode All rights reserved\r\n\r\n7.9K\r\n\r\n\r\n95\r\n\r\n\r\n\r\nCase 1\r\nCase 2\r\n\r\nnums =\r\n[0,1]\r\n1\r\n[0,1]\r\n[0,1,0]\r\n"
    },
    {
        "excercise": "Given an integer num, return a string representing its hexadecimal representation. For negative integers, two\u00e2\u20ac\u2122s complement method is used.\nAll the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.\nNote: You are not allowed to use any built-in library method to directly solve this problem.\nExample 1:\nInput: num = 26\nOutput: \"1a\"\nExample 2:\nInput: num = -1\nOutput: \"ffffffff\"\nConstraints:\n\t-2^31 <= num <= 2^31 - 1",
        "topics": [
            "Math",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/convert-a-number-to-hexadecimal/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} num\n * @return {string}\n */\nvar toHex = function(num) {\n    \n};",
        "givenJsCode": "class Solution:\n    def toHex(self, num: int) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String toHex(int num) {\n        \n    }\n}"
    },
    {
        "excercise": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\tcountAndSay(1) = \"1\"\n\tcountAndSay(n) is the run-length encoding of countAndSay(n - 1).\nRun-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string \"3322251\" we replace \"33\" with \"23\", replace \"222\" with \"32\", replace \"5\" with \"15\" and replace \"1\" with \"11\". Thus the compressed string becomes \"23321511\".\nGiven a positive integer n, return the n^th element of the count-and-say sequence.\nExample 1:\nInput: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = RLE of \"1\" = \"11\"\ncountAndSay(3) = RLE of \"11\" = \"21\"\ncountAndSay(4) = RLE of \"21\" = \"1211\"\nExample 2:\nInput: n = 1\nOutput: \"1\"\nExplanation:\nThis is the base case.\nConstraints:\n\t1 <= n <= 30\nFollow up: Could you solve it iteratively?",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/count-and-say/",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {string}\n */\nvar countAndSay = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String countAndSay(int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n.\nExample 1:\nInput: n = 2\nOutput: 91\nExplanation: The answer should be the total numbers in the range of 0 \u00e2\u2030\u00a4 x < 100, excluding 11,22,33,44,55,66,77,88,99\nExample 2:\nInput: n = 0\nOutput: 1\nConstraints:\n\t0 <= n <= 8",
        "topics": [
            "Math",
            "Dynamic Programming",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/count-numbers-with-unique-digits/",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar countNumbersWithUniqueDigits = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int countNumbersWithUniqueDigits(int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\nExample 1:\nInput: n = 2\nOutput: [0,1,1]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\nExample 2:\nInput: n = 5\nOutput: [0,1,1,2,1,2]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\nConstraints:\n\t0 <= n <= 10^5\nFollow up:\n\tIt is very easy to come up with a solution with a runtime of O(n log n). Can you do it in linear time O(n) and possibly in a single pass?\n\tCan you do it without using any built-in function (i.e., like __builtin_popcount in C++)?",
        "topics": [
            "Dynamic Programming",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/counting-bits/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {number[]}\n */\nvar countBits = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] countBits(int n) {\n        \n    }\n}"
    },
    {
        "excercise": "There are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the i^th course should be taken continuously for durationi days and must be finished before or on lastDayi.\nYou will start on the 1^st day and you cannot take two or more courses simultaneously.\nReturn the maximum number of courses that you can take.\nExample 1:\nInput: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]\nOutput: 3\nExplanation: \nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1^st course, it costs 100 days so you will finish it on the 100^th day, and ready to take the next course on the 101^st day.\nSecond, take the 3^rd course, it costs 1000 days so you will finish it on the 1100^th day, and ready to take the next course on the 1101^st day. \nThird, take the 2^nd course, it costs 200 days so you will finish it on the 1300^th day. \nThe 4^th course cannot be taken now, since you will finish it on the 3300^th day, which exceeds the closed date.\nExample 2:\nInput: courses = [[1,2]]\nOutput: 1\nExample 3:\nInput: courses = [[3,2],[4,3]]\nOutput: 0\nConstraints:\n\t1 <= courses.length <= 10^4\n\t1 <= durationi, lastDayi <= 10^4",
        "topics": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/course-schedule-iii/",
        "givenPythonCode": "class Solution:\n    def scheduleCourse(self, courses: List[List[int]]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[][]} courses\n * @return {number}\n */\nvar scheduleCourse = function(courses) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int scheduleCourse(int[][] courses) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A message containing letters from A-Z can be encoded into numbers using the following mapping:\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\nTo decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\n\t\"AAJF\" with the grouping (1 1 10 6)\n\t\"KJF\" with the grouping (11 10 6)\nNote that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".\nIn addition to the mapping above, an encoded message may contain the '*' character, which can represent any digit from '1' to '9' ('0' is excluded). For example, the encoded message \"1*\" may represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\". Decoding \"1*\" is equivalent to decoding any of the encoded messages it can represent.\nGiven a string s consisting of digits and '*' characters, return the number of ways to decode it.\nSince the answer may be very large, return it modulo 10^9 + 7.\nExample 1:\nInput: s = \"*\"\nOutput: 9\nExplanation: The encoded message can represent any of the encoded messages \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", or \"9\".\nEach of these can be decoded to the strings \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", and \"I\" respectively.\nHence, there are a total of 9 ways to decode \"*\".\nExample 2:\nInput: s = \"1*\"\nOutput: 18\nExplanation: The encoded message can represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\".\nEach of these encoded messages have 2 ways to be decoded (e.g. \"11\" can be decoded to \"AA\" or \"K\").\nHence, there are a total of 9 * 2 = 18 ways to decode \"1*\".\nExample 3:\nInput: s = \"2*\"\nOutput: 15\nExplanation: The encoded message can represent any of the encoded messages \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", or \"29\".\n\"21\", \"22\", \"23\", \"24\", \"25\", and \"26\" have 2 ways of being decoded, but \"27\", \"28\", and \"29\" only have 1 way.\nHence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode \"2*\".\nConstraints:\n\t1 <= s.length <= 10^5\n\ts[i] is a digit or '*'.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/decode-ways-ii/",
        "givenPythonCode": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int numDecodings(String s) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar numDecodings = function(s) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:\n\"1\" -> 'A'\n\"2\" -> 'B'\n...\n\"25\" -> 'Y'\n\"26\" -> 'Z'\nHowever, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\").\nFor example, \"11106\" can be decoded into:\n\t\"AAJF\" with the grouping (1, 1, 10, 6)\n\t\"KJF\" with the grouping (11, 10, 6)\n\tThe grouping (1, 11, 06) is invalid because \"06\" is not a valid code (only \"6\" is valid).\nNote: there may be strings that are impossible to decode.\nGiven a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.\nThe test cases are generated so that the answer fits in a 32-bit integer.\nExample 1:\nInput: s = \"12\"\nOutput: 2\nExplanation:\n\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\nExample 2:\nInput: s = \"226\"\nOutput: 3\nExplanation:\n\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\nExample 3:\nInput: s = \"06\"\nOutput: 0\nExplanation:\n\"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). In this case, the string is not a valid encoding, so return 0.\nConstraints:\n\t1 <= s.length <= 100\n\ts contains only digits and may contain leading zero(s).",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/decode-ways/",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar numDecodings = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int numDecodings(String s) {\n        \n    }\n}",
        "difficulty": "ung\u00fcltig"
    },
    {
        "excercise": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.\nIn one step, you can delete exactly one character in either string.\nExample 1:\nInput: word1 = \"sea\", word2 = \"eat\"\nOutput: 2\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".\nExample 2:\nInput: word1 = \"leetcode\", word2 = \"etco\"\nOutput: 4\nConstraints:\n\t1 <= word1.length, word2.length <= 500\n\tword1 and word2 consist of only lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/delete-operation-for-two-strings/",
        "givenPythonCode": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nvar minDistance = function(word1, word2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int minDistance(String word1, String word2) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\tAll letters in this word are capitals, like \"USA\".\n\tAll letters in this word are not capitals, like \"leetcode\".\n\tOnly the first letter in this word is capital, like \"Google\".\nGiven a string word, return true if the usage of capitals in it is right.\nExample 1:\nInput: word = \"USA\"\nOutput: true\nExample 2:\nInput: word = \"FlaG\"\nOutput: false\nConstraints:\n\t1 <= word.length <= 100\n\tword consists of lowercase and uppercase English letters.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/detect-capital/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} word\n * @return {boolean}\n */\nvar detectCapitalUse = function(word) {\n    \n};",
        "givenJsCode": "class Solution:\n    def detectCapitalUse(self, word: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean detectCapitalUse(String word) {\n        \n    }\n}"
    },
    {
        "excercise": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\nThe test cases are generated so that the answer fits on a 32-bit signed integer.\nExample 1:\nInput: s = \"rabbbit\", t = \"rabbit\"\nOutput: 3\nExplanation:\nAs shown below, there are 3 ways you can generate \"rabbit\" from s.\nrabbbit\nrabbbit\nrabbbit\nExample 2:\nInput: s = \"babgbag\", t = \"bag\"\nOutput: 5\nExplanation:\nAs shown below, there are 5 ways you can generate \"bag\" from s.\nbabgbag\nbabgbag\nbabgbag\nbabgbag\nbabgbag\nConstraints:\n\t1 <= s.length, t.length <= 1000\n\ts and t consist of English letters.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/distinct-subsequences/",
        "givenPythonCode": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar numDistinct = function(s, t) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int numDistinct(String s, String t) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u00e2\u02c6\u20192^31, 2^31 \u00e2\u02c6\u2019 1]. For this problem, if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1, and if the quotient is strictly less than -2^31, then return -2^31.\nExample 1:\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\nExample 2:\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\nConstraints:\n\t-2^31 <= dividend, divisor <= 2^31 - 1\n\tdivisor != 0",
        "topics": [
            "Math",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/divide-two-integers/",
        "givenPythonCode": "/**\n * @param {number} dividend\n * @param {number} divisor\n * @return {number}\n */\nvar divide = function(dividend, divisor) {\n    \n};",
        "givenJsCode": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int divide(int dividend, int divisor) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\tInsert a character\n\tDelete a character\n\tReplace a character\nExample 1:\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\nExample 2:\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\nConstraints:\n\t0 <= word1.length, word2.length <= 500\n\tword1 and word2 consist of lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/edit-distance/",
        "givenPythonCode": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nvar minDistance = function(word1, word2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int minDistance(String word1, String word2) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:\n\tThe valid operators are '+', '-', '*', and '/'.\n\tEach operand may be an integer or another expression.\n\tThe division between two integers always truncates toward zero.\n\tThere will not be any division by zero.\n\tThe input represents a valid arithmetic expression in a reverse polish notation.\n\tThe answer and all the intermediate calculations can be represented in a 32-bit integer.\nExample 1:\nInput: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\nExample 2:\nInput: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\nExample 3:\nInput: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\nOutput: 22\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\nConstraints:\n\t1 <= tokens.length <= 10^4\n\ttokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200].",
        "topics": [
            "Array",
            "Math",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/evaluate-reverse-polish-notation/",
        "givenPythonCode": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {string[]} tokens\n * @return {number}\n */\nvar evalRPN = function(tokens) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int evalRPN(String[] tokens) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\nFor example:\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\nExample 1:\nInput: columnTitle = \"A\"\nOutput: 1\nExample 2:\nInput: columnTitle = \"AB\"\nOutput: 28\nExample 3:\nInput: columnTitle = \"ZY\"\nOutput: 701\nConstraints:\n\t1 <= columnTitle.length <= 7\n\tcolumnTitle consists only of uppercase English letters.\n\tcolumnTitle is in the range [\"A\", \"FXSHRXW\"].",
        "topics": [
            "Math",
            "String"
        ],
        "url": "https://leetcode.com/problems/excel-sheet-column-number/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} columnTitle\n * @return {number}\n */\nvar titleToNumber = function(columnTitle) {\n    \n};",
        "givenJsCode": "class Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int titleToNumber(String columnTitle) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.\nFor example:\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\nExample 1:\nInput: columnNumber = 1\nOutput: \"A\"\nExample 2:\nInput: columnNumber = 28\nOutput: \"AB\"\nExample 3:\nInput: columnNumber = 701\nOutput: \"ZY\"\nConstraints:\n\t1 <= columnNumber <= 2^31 - 1",
        "topics": [
            "Math",
            "String"
        ],
        "url": "https://leetcode.com/problems/excel-sheet-column-title/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        ",
        "givenJsCode": "/**\n * @param {number} columnNumber\n * @return {string}\n */\nvar convertToTitle = function(columnNumber) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public String convertToTitle(int columnNumber) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value.\nNote that operands in the returned expressions should not contain leading zeros.\nExample 1:\nInput: num = \"123\", target = 6\nOutput: [\"1*2*3\",\"1+2+3\"]\nExplanation: Both \"1*2*3\" and \"1+2+3\" evaluate to 6.\nExample 2:\nInput: num = \"232\", target = 8\nOutput: [\"2*3+2\",\"2+3*2\"]\nExplanation: Both \"2*3+2\" and \"2+3*2\" evaluate to 8.\nExample 3:\nInput: num = \"3456237490\", target = 9191\nOutput: []\nExplanation: There are no expressions that can be created from \"3456237490\" to evaluate to 9191.\nConstraints:\n\t1 <= num.length <= 10\n\tnum consists of only digits.\n\t-2^31 <= target <= 2^31 - 1",
        "topics": [
            "Math",
            "String",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/expression-add-operators/",
        "givenPythonCode": "class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        ",
        "givenJsCode": "class Solution {\n    public List<String> addOperators(String num, int target) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} num\n * @param {number} target\n * @return {string[]}\n */\nvar addOperators = function(num, target) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\nExample 1:\nInput: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.\nExample 2:\nInput: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.\nExample 3:\nInput: n = 0\nOutput: 0\nConstraints:\n\t0 <= n <= 10^4\nFollow up: Could you write a solution that works in logarithmic time complexity?",
        "topics": [
            "Math"
        ],
        "url": "https://leetcode.com/problems/factorial-trailing-zeroes/",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar trailingZeroes = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int trailingZeroes(int n) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: s = \"cbaebabacd\", p = \"abc\"\nOutput: [0,6]\nExplanation:\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\nExample 2:\nInput: s = \"abab\", p = \"ab\"\nOutput: [0,1,2]\nExplanation:\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\nConstraints:\n\t1 <= s.length, p.length <= 3 * 10^4\n\ts and p consist of lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/find-all-anagrams-in-a-string/",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {string} p\n * @return {number[]}\n */\nvar findAnagrams = function(s, p) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.\nYou must write an algorithm that runs in O(n) time and uses only constant extra space.\nExample 1:\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [2,3]\nExample 2:\nInput: nums = [1,1,2]\nOutput: [1]\nExample 3:\nInput: nums = [1]\nOutput: []\nConstraints:\n\tn == nums.length\n\t1 <= n <= 10^5\n\t1 <= nums[i] <= n\n\tEach element in nums appears once or twice.",
        "topics": [
            "Array",
            "Hash Table"
        ],
        "url": "https://leetcode.com/problems/find-all-duplicates-in-an-array/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar findDuplicates = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.\nExample 1:\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]\nExample 2:\nInput: nums = [1,1]\nOutput: [2]\nConstraints:\n\tn == nums.length\n\t1 <= n <= 10^5\n\t1 <= nums[i] <= n\nFollow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.",
        "topics": [
            "Array",
            "Hash Table"
        ],
        "url": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar findDisappearedNumbers = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order.\nA group of duplicate files consists of at least two files that have the same content.\nA single directory info string in the input list has the following format:\n\t\"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"\nIt means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory \"root/d1/d2/.../dm\". Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.\nThe output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:\n\t\"directory_path/file_name.txt\"\nExample 1:\nInput: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]\nOutput: [[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\nExample 2:\nInput: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]\nOutput: [[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\nConstraints:\n\t1 <= paths.length <= 2 * 10^4\n\t1 <= paths[i].length <= 3000\n\t1 <= sum(paths[i].length) <= 5 * 10^5\n\tpaths[i] consist of English letters, digits, '/', '.', '(', ')', and ' '.\n\tYou may assume no files or directories share the same name in the same directory.\n\tYou may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info.\nFollow up:\n\tImagine you are given a real file system, how will you search files? DFS or BFS?\n\tIf the file content is very large (GB level), how will you modify your solution?\n\tIf you can only read the file by 1kb each time, how will you modify your solution?\n\tWhat is the time complexity of your modified solution? What is the most time-consuming part and memory-consuming part of it? How to optimize?\n\tHow to make sure the duplicated files you find are not false positive?",
        "topics": [
            "Array",
            "Hash Table",
            "String"
        ],
        "url": "https://leetcode.com/problems/find-duplicate-file-in-system/",
        "givenPythonCode": "/**\n * @param {string[]} paths\n * @return {string[][]}\n */\nvar findDuplicate = function(paths) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findDuplicate(self, paths: List[str]) -> List[List[str]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<String>> findDuplicate(String[] paths) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\nConstraints:\n\t0 <= nums.length <= 10^5\n\t-10^9 <= nums[i] <= 10^9\n\tnums is a non-decreasing array.\n\t-10^9 <= target <= 10^9",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/",
        "givenPythonCode": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar searchRange = function(nums, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\nExample 1:\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]]\nExplanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\nExample 2:\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [[1,1],[1,1]]\nExplanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\nConstraints:\n\t1 <= nums1.length, nums2.length <= 10^5\n\t-10^9 <= nums1[i], nums2[i] <= 10^9\n\tnums1 and nums2 both are sorted in non-decreasing order.\n\t1 <= k <= 10^4\n\tk <= nums1.length * nums2.length",
        "topics": [
            "Array",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/find-k-pairs-with-smallest-sums/",
        "givenPythonCode": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number[][]}\n */\nvar kSmallestPairs = function(nums1, nums2, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "The distance of a pair of integers a and b is defined as the absolute difference between a and b.\nGiven an integer array nums and an integer k, return the k^th smallest distance among all the pairs nums[i] and nums[j] where 0 <= i < j < nums.length.\nExample 1:\nInput: nums = [1,3,1], k = 1\nOutput: 0\nExplanation: Here are all the pairs:\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\nThen the 1^st smallest distance pair is (1,1), and its distance is 0.\nExample 2:\nInput: nums = [1,1,1], k = 2\nOutput: 0\nExample 3:\nInput: nums = [1,6,1], k = 3\nOutput: 5\nConstraints:\n\tn == nums.length\n\t2 <= n <= 10^4\n\t0 <= nums[i] <= 10^6\n\t1 <= k <= n * (n - 1) / 2",
        "topics": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/find-k-th-smallest-pair-distance/",
        "givenPythonCode": "class Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar smallestDistancePair = function(nums, k) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:\n\t[4,5,6,7,0,1,4] if it was rotated 4 times.\n\t[0,1,4,4,5,6,7] if it was rotated 7 times.\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums that may contain duplicates, return the minimum element of this array.\nYou must decrease the overall operation steps as much as possible.\nExample 1:\nInput: nums = [1,3,5]\nOutput: 1\nExample 2:\nInput: nums = [2,2,2,0,1]\nOutput: 0\nConstraints:\n\tn == nums.length\n\t1 <= n <= 5000\n\t-5000 <= nums[i] <= 5000\n\tnums is sorted and rotated between 1 and n times.\nFollow up: This problem is similar to Find Minimum in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/",
        "givenPythonCode": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int findMin(int[] nums) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function(nums) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\t[4,5,6,7,0,1,2] if it was rotated 4 times.\n\t[0,1,2,4,5,6,7] if it was rotated 7 times.\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\nExample 2:\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\nExample 3:\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times. \nConstraints:\n\tn == nums.length\n\t1 <= n <= 5000\n\t-5000 <= nums[i] <= 5000\n\tAll the integers of nums are unique.\n\tnums is sorted and rotated between 1 and n times.",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findMin(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u00e2\u02c6\u017e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\nExample 2:\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\nConstraints:\n\t1 <= nums.length <= 1000\n\t-2^31 <= nums[i] <= 2^31 - 1\n\tnums[i] != nums[i + 1] for all valid i.",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/find-peak-element/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findPeakElement = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findPeakElement(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\nThe right interval for an interval i is an interval j such that startj >= endi and startj is minimized. Note that i may equal j.\nReturn an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.\nExample 1:\nInput: intervals = [[1,2]]\nOutput: [-1]\nExplanation: There is only one interval in the collection, so it outputs -1.\nExample 2:\nInput: intervals = [[3,4],[2,3],[1,2]]\nOutput: [-1,0,1]\nExplanation: There is no right interval for [3,4].\nThe right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is >= end1 = 3.\nThe right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is >= end2 = 2.\nExample 3:\nInput: intervals = [[1,4],[2,3],[3,4]]\nOutput: [-1,2,-1]\nExplanation: There is no right interval for [1,4] and [3,4].\nThe right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is >= end1 = 3.\nConstraints:\n\t1 <= intervals.length <= 2 * 10^4\n\tintervals[i].length == 2\n\t-10^6 <= starti <= endi <= 10^6\n\tThe start point of each interval is unique.",
        "topics": [
            "Array",
            "Binary Search",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/find-right-interval/",
        "givenPythonCode": "/**\n * @param {number[][]} intervals\n * @return {number[]}\n */\nvar findRightInterval = function(intervals) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] findRightInterval(int[][] intervals) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given two strings s and t.\nString t is generated by random shuffling string s and then add one more letter at a random position.\nReturn the letter that was added to t.\nExample 1:\nInput: s = \"abcd\", t = \"abcde\"\nOutput: \"e\"\nExplanation: 'e' is the letter that was added.\nExample 2:\nInput: s = \"\", t = \"y\"\nOutput: \"y\"\nConstraints:\n\t0 <= s.length <= 1000\n\tt.length == s.length + 1\n\ts and t consist of lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/find-the-difference/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {character}\n */\nvar findTheDifference = function(s, t) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public char findTheDifference(String s, String t) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this repeated number.\nYou must solve the problem without modifying the array nums and uses only constant extra space.\nExample 1:\nInput: nums = [1,3,4,2,2]\nOutput: 2\nExample 2:\nInput: nums = [3,1,3,4,2]\nOutput: 3\nExample 3:\nInput: nums = [3,3,3,3,3]\nOutput: 3\nConstraints:\n\t1 <= n <= 10^5\n\tnums.length == n + 1\n\t1 <= nums[i] <= n\n\tAll the integers in nums appear only once except for precisely one integer which appears two or more times.\nFollow up:\n\tHow can we prove that at least one duplicate number must exist in nums?\n\tCan you solve the problem in linear runtime complexity?",
        "topics": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/find-the-duplicate-number/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDuplicate = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findDuplicate(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\nExample 1:\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\nExample 2:\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\nExample 3:\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.\nConstraints:\n\t1 <= nums.length <= 10^5\n\t-2^31 <= nums[i] <= 2^31 - 1",
        "topics": [
            "Array",
            "Hash Table"
        ],
        "url": "https://leetcode.com/problems/first-missing-positive/",
        "givenPythonCode": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar firstMissingPositive = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n, return a string array answer (1-indexed) where:\n\tanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\n\tanswer[i] == \"Fizz\" if i is divisible by 3.\n\tanswer[i] == \"Buzz\" if i is divisible by 5.\n\tanswer[i] == i (as a string) if none of the above conditions are true.\nExample 1:\nInput: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]\nExample 2:\nInput: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\nExample 3:\nInput: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\nConstraints:\n\t1 <= n <= 10^4",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/fizz-buzz/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {string[]}\n */\nvar fizzBuzz = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<String> fizzBuzz(int n) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format.\nThe final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1.\nExample 1:\nInput: expression = \"-1/2+1/2\"\nOutput: \"0/1\"\nExample 2:\nInput: expression = \"-1/2+1/2+1/3\"\nOutput: \"1/3\"\nExample 3:\nInput: expression = \"1/3-1/2\"\nOutput: \"-1/6\"\nConstraints:\n\tThe input string only contains '0' to '9', '/', '+' and '-'. So does the output.\n\tEach fraction (input and output) has the format \u00c2\u00b1numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted.\n\tThe input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1, 10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.\n\tThe number of given fractions will be in the range [1, 10].\n\tThe numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/fraction-addition-and-subtraction/",
        "givenPythonCode": "/**\n * @param {string} expression\n * @return {string}\n */\nvar fractionAddition = function(expression) {\n    \n};",
        "givenJsCode": "class Solution:\n    def fractionAddition(self, expression: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String fractionAddition(String expression) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, return any of them.\nIt is guaranteed that the length of the answer string is less than 10^4 for all the given inputs.\nExample 1:\nInput: numerator = 1, denominator = 2\nOutput: \"0.5\"\nExample 2:\nInput: numerator = 2, denominator = 1\nOutput: \"2\"\nExample 3:\nInput: numerator = 4, denominator = 333\nOutput: \"0.(012)\"\nConstraints:\n\t-2^31 <= numerator, denominator <= 2^31 - 1\n\tdenominator != 0",
        "topics": [
            "Hash Table",
            "Math",
            "String"
        ],
        "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/",
        "givenPythonCode": "/**\n * @param {number} numerator\n * @param {number} denominator\n * @return {string}\n */\nvar fractionToDecimal = function(numerator, denominator) {\n    \n};",
        "givenJsCode": "class Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\nGiven a list of stones positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\nIf the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\nExample 1:\nInput: stones = [0,1,3,5,6,8,12,17]\nOutput: true\nExplanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\nExample 2:\nInput: stones = [0,1,2,3,4,8,9,11]\nOutput: false\nExplanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\nConstraints:\n\t2 <= stones.length <= 2000\n\t0 <= stones[i] <= 2^31 - 1\n\tstones[0] == 0\n\tstones is sorted in a strictly increasing order.",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/frog-jump/",
        "givenPythonCode": "class Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        ",
        "givenJsCode": "class Solution {\n    public boolean canCross(int[] stones) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} stones\n * @return {boolean}\n */\nvar canCross = function(stones) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "There are n gas stations along a circular route, where the amount of gas at the i^th station is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the i^th station to its next (i + 1)^th station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique\nExample 1:\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\nExample 2:\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\nConstraints:\n\tn == gas.length == cost.length\n\t1 <= n <= 10^5\n\t0 <= gas[i], cost[i] <= 10^4",
        "topics": [
            "Array",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/gas-station/",
        "givenPythonCode": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} gas\n * @param {number[]} cost\n * @return {number}\n */\nvar canCompleteCircuit = function(gas, cost) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "An n-bit gray code sequence is a sequence of 2^n integers where:\n\tEvery integer is in the inclusive range [0, 2^n - 1],\n\tThe first integer is 0,\n\tAn integer appears no more than once in the sequence,\n\tThe binary representation of every pair of adjacent integers differs by exactly one bit, and\n\tThe binary representation of the first and last integers differs by exactly one bit.\nGiven an integer n, return any valid n-bit gray code sequence.\nExample 1:\nInput: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit\nExample 2:\nInput: n = 1\nOutput: [0,1]\nConstraints:\n\t1 <= n <= 16",
        "topics": [
            "Math",
            "Backtracking",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/gray-code/",
        "givenPythonCode": "class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        ",
        "givenJsCode": "/**\n * @param {number} n\n * @return {number[]}\n */\nvar grayCode = function(n) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public List<Integer> grayCode(int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\nExample 2:\nInput: strs = [\"\"]\nOutput: [[\"\"]]\nExample 3:\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\nConstraints:\n\t1 <= strs.length <= 10^4\n\t0 <= strs[i].length <= 100\n\tstrs[i] consists of lowercase English letters.",
        "topics": [
            "Array",
            "Hash Table",
            "String",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/group-anagrams/",
        "givenPythonCode": "/**\n * @param {string[]} strs\n * @return {string[][]}\n */\nvar groupAnagrams = function(strs) {\n    \n};",
        "givenJsCode": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their i^th paper and citations is sorted in ascending order, return the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\nYou must write an algorithm that runs in logarithmic time.\nExample 1:\nInput: citations = [0,1,3,5,6]\nOutput: 3\nExplanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\nExample 2:\nInput: citations = [1,2,100]\nOutput: 2\nConstraints:\n\tn == citations.length\n\t1 <= n <= 10^5\n\t0 <= citations[i] <= 1000\n\tcitations is sorted in ascending order.",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/h-index-ii/",
        "givenPythonCode": "/**\n * @param {number[]} citations\n * @return {number}\n */\nvar hIndex = function(citations) {\n    \n};",
        "givenJsCode": "class Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int hIndex(int[] citations) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, return the Hamming distance between them.\nExample 1:\nInput: x = 1, y = 4\nOutput: 2\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       \u00e2\u2020\u2018   \u00e2\u2020\u2018\nThe above arrows point to positions where the corresponding bits are different.\nExample 2:\nInput: x = 3, y = 1\nOutput: 1\nConstraints:\n\t0 <= x, y <= 2^31 - 1",
        "topics": [
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/hamming-distance/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nvar hammingDistance = function(x, y) {\n    \n};",
        "givenJsCode": "class Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int hammingDistance(int x, int y) {\n        \n    }\n}"
    },
    {
        "excercise": "Write an algorithm to determine if a number n is happy.\nA happy number is a number defined by the following process:\n\tStarting with any positive integer, replace the number by the sum of the squares of its digits.\n\tRepeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n\tThose numbers for which this process ends in 1 are happy.\nReturn true if n is a happy number, and false if not.\nExample 1:\nInput: n = 19\nOutput: true\nExplanation:\n1^2 + 9^2 = 82\n8^2 + 2^2 = 68\n6^2 + 8^2 = 100\n1^2 + 0^2 + 0^2 = 1\nExample 2:\nInput: n = 2\nOutput: false\nConstraints:\n\t1 <= n <= 2^31 - 1",
        "topics": [
            "Hash Table",
            "Math",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/happy-number/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {boolean}\n */\nvar isHappy = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isHappy(int n) {\n        \n    }\n}"
    },
    {
        "excercise": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\nInput: nums = [1,2,3]\nOutput: 3\nConstraints:\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 1000",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/house-robber-ii/",
        "givenPythonCode": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int rob(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\nConstraints:\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 400",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/house-robber/",
        "givenPythonCode": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int rob(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.\nExample 1:\nInput: nums = [1,2,3,4,5]\nOutput: true\nExplanation: Any triplet where i < j < k is valid.\nExample 2:\nInput: nums = [5,4,3,2,1]\nOutput: false\nExplanation: No triplet exists.\nExample 3:\nInput: nums = [2,1,5,0,4,6]\nOutput: true\nExplanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.\nConstraints:\n\t1 <= nums.length <= 5 * 10^5\n\t-2^31 <= nums[i] <= 2^31 - 1\nFollow up: Could you implement a solution that runs in O(n) time complexity and O(1) space complexity?",
        "topics": [
            "Array",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/increasing-triplet-subsequence/",
        "givenPythonCode": "class Solution:\n    def increasingTriplet(self, nums: List[int]) -> bool:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar increasingTriplet = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public boolean increasingTriplet(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the i^th interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nNote that you don't need to modify intervals in-place. You can make a new array and return it.\nExample 1:\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\nExample 2:\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\nConstraints:\n\t0 <= intervals.length <= 10^4\n\tintervals[i].length == 2\n\t0 <= starti <= endi <= 10^5\n\tintervals is sorted by starti in ascending order.\n\tnewInterval.length == 2\n\t0 <= start <= end <= 10^5",
        "topics": [
            "Array"
        ],
        "url": "https://leetcode.com/problems/insert-interval/",
        "givenPythonCode": "/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nvar insert = function(intervals, newInterval) {\n    \n};",
        "givenJsCode": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.\nReturn the maximum product you can get.\nExample 1:\nInput: n = 2\nOutput: 1\nExplanation: 2 = 1 + 1, 1 \u00c3\u2014 1 = 1.\nExample 2:\nInput: n = 10\nOutput: 36\nExplanation: 10 = 3 + 3 + 4, 3 \u00c3\u2014 3 \u00c3\u2014 4 = 36.\nConstraints:\n\t2 <= n <= 58",
        "topics": [
            "Math",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/integer-break/",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar integerBreak = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def integerBreak(self, n: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int integerBreak(int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.\nExample 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2,2]\nExample 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [4,9]\nExplanation: [9,4] is also accepted.\nConstraints:\n\t1 <= nums1.length, nums2.length <= 1000\n\t0 <= nums1[i], nums2[i] <= 1000\nFollow up:\n\tWhat if the given array is already sorted? How would you optimize your algorithm?\n\tWhat if nums1's size is small compared to nums2's size? Which algorithm is better?\n\tWhat if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?",
        "topics": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/intersection-of-two-arrays-ii/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersect = function(nums1, nums2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        \n    }\n}"
    },
    {
        "excercise": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\nExample 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]\nExample 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4]\nExplanation: [4,9] is also accepted.\nConstraints:\n\t1 <= nums1.length, nums2.length <= 1000\n\t0 <= nums1[i], nums2[i] <= 1000",
        "topics": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/intersection-of-two-arrays/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersection = function(nums1, nums2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        \n    }\n}"
    },
    {
        "excercise": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\nYou are given n projects where the i^th project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\nThe answer is guaranteed to fit in a 32-bit signed integer.\nExample 1:\nInput: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\nOutput: 4\nExplanation: Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\nExample 2:\nInput: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\nOutput: 6\nConstraints:\n\t1 <= k <= 10^5\n\t0 <= w <= 10^9\n\tn == profits.length\n\tn == capital.length\n\t1 <= n <= 10^5\n\t0 <= profits[i] <= 10^4\n\t0 <= capital[i] <= 10^9",
        "topics": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/ipo/",
        "givenPythonCode": "class Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} k\n * @param {number} w\n * @param {number[]} profits\n * @param {number[]} capital\n * @return {number}\n */\nvar findMaximizedCapital = function(k, w, profits, capital) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\nExample 1:\nInput: s = \"abc\", t = \"ahbgdc\"\nOutput: true\nExample 2:\nInput: s = \"axc\", t = \"ahbgdc\"\nOutput: false\nConstraints:\n\t0 <= s.length <= 100\n\t0 <= t.length <= 10^4\n\ts and t consist only of lowercase English letters.\nFollow up: Suppose there are lots of incoming s, say s1, s2, ..., sk where k >= 10^9, and you want to check one by one to see if t has its subsequence. In this scenario, how would you change your code?",
        "topics": [
            "Two Pointers",
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/is-subsequence/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isSubsequence = function(s, t) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        \n    }\n}"
    },
    {
        "excercise": "Given two strings s and t, determine if they are isomorphic.\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\nExample 1:\nInput: s = \"egg\", t = \"add\"\nOutput: true\nExample 2:\nInput: s = \"foo\", t = \"bar\"\nOutput: false\nExample 3:\nInput: s = \"paper\", t = \"title\"\nOutput: true\nConstraints:\n\t1 <= s.length <= 5 * 10^4\n\tt.length == s.length\n\ts and t consist of any valid ascii character.",
        "topics": [
            "Hash Table",
            "String"
        ],
        "url": "https://leetcode.com/problems/isomorphic-strings/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isIsomorphic = function(s, t) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        \n    }\n}"
    },
    {
        "excercise": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n\t0 <= j <= nums[i] and\n\ti + j < n\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\nExample 1:\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\nExample 2:\nInput: nums = [2,3,0,1,4]\nOutput: 2\nConstraints:\n\t1 <= nums.length <= 10^4\n\t0 <= nums[i] <= 1000\n\tIt's guaranteed that you can reach nums[n - 1].",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/jump-game-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int jump(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1:\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\nExample 2:\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\nConstraints:\n\t1 <= nums.length <= 10^4\n\t0 <= nums[i] <= 10^5",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/jump-game/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean canJump(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\n\t0 <= i, j < nums.length\n\ti != j\n\t|nums[i] - nums[j]| == k\nNotice that |val| denotes the absolute value of val.\nExample 1:\nInput: nums = [3,1,4,1,5], k = 2\nOutput: 2\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).\nAlthough we have two 1s in the input, we should only return the number of unique pairs.\nExample 2:\nInput: nums = [1,2,3,4,5], k = 1\nOutput: 4\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\nExample 3:\nInput: nums = [1,3,1,5,4], k = 0\nOutput: 1\nExplanation: There is one 0-diff pair in the array, (1, 1).\nConstraints:\n\t1 <= nums.length <= 10^4\n\t-10^7 <= nums[i] <= 10^7\n\t0 <= k <= 10^7",
        "topics": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/k-diff-pairs-in-an-array/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findPairs = function(nums, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findPairs(self, nums: List[int], k: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findPairs(int[] nums, int k) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.length and nums[i] > nums[j].\nGiven two integers n and k, return the number of different arrays consisting of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 10^9 + 7.\nExample 1:\nInput: n = 3, k = 0\nOutput: 1\nExplanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs.\nExample 2:\nInput: n = 3, k = 1\nOutput: 2\nExplanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.\nConstraints:\n\t1 <= n <= 1000\n\t0 <= k <= 1000",
        "topics": [
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/k-inverse-pairs-array/",
        "givenPythonCode": "class Solution:\n    def kInversePairs(self, n: int, k: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int kInversePairs(int n, int k) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar kInversePairs = function(n, k) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:\n\tanswer[i] % answer[j] == 0, or\n\tanswer[j] % answer[i] == 0\nIf there are multiple solutions, return any of them.\nExample 1:\nInput: nums = [1,2,3]\nOutput: [1,2]\nExplanation: [1,3] is also accepted.\nExample 2:\nInput: nums = [1,2,4,8]\nOutput: [1,2,4,8]\nConstraints:\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 2 * 10^9\n\tAll the integers in nums are unique.",
        "topics": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/largest-divisible-subset/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar largestDivisibleSubset = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<Integer> largestDivisibleSubset(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.\nSince the result may be very large, so you need to return a string instead of an integer.\nExample 1:\nInput: nums = [10,2]\nOutput: \"210\"\nExample 2:\nInput: nums = [3,30,34,5,9]\nOutput: \"9534330\"\nConstraints:\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 10^9",
        "topics": [
            "Array",
            "String",
            "Greedy",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/largest-number/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {string}\n */\nvar largestNumber = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String largestNumber(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digits integers. Since the answer can be very large, return it modulo 1337.\nExample 1:\nInput: n = 2\nOutput: 987\nExplanation: 99 x 91 = 9009, 9009 % 1337 = 987\nExample 2:\nInput: n = 1\nOutput: 9\nConstraints:\n\t1 <= n <= 8",
        "topics": [
            "Math",
            "Enumeration"
        ],
        "url": "https://leetcode.com/problems/largest-palindrome-product/",
        "givenPythonCode": "class Solution:\n    def largestPalindrome(self, n: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int largestPalindrome(int n) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar largestPalindrome = function(n) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.\nExample 1:\nInput: s = \"Hello World\"\nOutput: 5\nExplanation: The last word is \"World\" with length 5.\nExample 2:\nInput: s = \"   fly me   to   the moon  \"\nOutput: 4\nExplanation: The last word is \"moon\" with length 4.\nExample 3:\nInput: s = \"luffy is still joyboy\"\nOutput: 6\nExplanation: The last word is \"joyboy\" with length 6.\nConstraints:\n\t1 <= s.length <= 10^4\n\ts consists of only English letters and spaces ' '.\n\tThere will be at least one word in s.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/length-of-last-word/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLastWord = function(s) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int lengthOfLastWord(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.\nWe want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.\nReturn the reformatted license key.\nExample 1:\nInput: s = \"5F3Z-2e-9-w\", k = 4\nOutput: \"5F3Z-2E9W\"\nExplanation: The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\nExample 2:\nInput: s = \"2-5g-3-J\", k = 2\nOutput: \"2-5G-3J\"\nExplanation: The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\nConstraints:\n\t1 <= s.length <= 10^5\n\ts consists of English letters, digits, and dashes '-'.\n\t1 <= k <= 10^4",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/license-key-formatting/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar licenseKeyFormatting = function(s, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String licenseKeyFormatting(String s, int k) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums, return the length of the longest strictly increasing subsequence.\nExample 1:\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\nExample 2:\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\nExample 3:\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\nConstraints:\n\t1 <= nums.length <= 2500\n\t-10^4 <= nums[i] <= 10^4\nFollow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?",
        "topics": [
            "Array",
            "Binary Search",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/longest-increasing-subsequence/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar lengthOfLIS = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.\nLetters are case sensitive, for example, \"Aa\" is not considered a palindrome.\nExample 1:\nInput: s = \"abccccdd\"\nOutput: 7\nExplanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7.\nExample 2:\nInput: s = \"a\"\nOutput: 1\nExplanation: The longest palindrome that can be built is \"a\", whose length is 1.\nConstraints:\n\t1 <= s.length <= 2000\n\ts consists of lowercase and/or uppercase English letters only.",
        "topics": [
            "Hash Table",
            "String",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/longest-palindrome/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def longestPalindrome(self, s: str) -> int:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestPalindrome = function(s) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int longestPalindrome(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string s, find the longest palindromic subsequence's length in s.\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\nInput: s = \"bbbab\"\nOutput: 4\nExplanation: One possible longest palindromic subsequence is \"bbbb\".\nExample 2:\nInput: s = \"cbbd\"\nOutput: 2\nExplanation: One possible longest palindromic subsequence is \"bb\".\nConstraints:\n\t1 <= s.length <= 1000\n\ts consists only of lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/longest-palindromic-subsequence/",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestPalindromeSubseq = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int longestPalindromeSubseq(String s) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s, return the longest palindromic substring in s.\nExample 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\nExample 2:\nInput: s = \"cbbd\"\nOutput: \"bb\"\nConstraints:\n\t1 <= s.length <= 1000\n\ts consist of only digits and English letters.",
        "topics": [
            "Two Pointers",
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/longest-palindromic-substring/",
        "givenPythonCode": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public String longestPalindrome(String s) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\nExample 1:\nInput: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.\nExample 2:\nInput: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.\nConstraints:\n\t1 <= s.length <= 10^5\n\ts consists of only uppercase English letters.\n\t0 <= k <= s.length",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/longest-repeating-character-replacement/",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar characterReplacement = function(s, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int characterReplacement(String s, int k) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s, find the length of the longest substring without repeating characters.\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\nExample 3:\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\nConstraints:\n\t0 <= s.length <= 5 * 10^4\n\ts consists of English letters, digits, symbols and spaces.",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
        "givenPythonCode": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If no such uncommon subsequence exists, return -1.\nAn uncommon subsequence between two strings is a string that is a subsequence of exactly one of them.\nExample 1:\nInput: a = \"aba\", b = \"cdc\"\nOutput: 3\nExplanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\".\nNote that \"cdc\" is also a longest uncommon subsequence.\nExample 2:\nInput: a = \"aaa\", b = \"bbb\"\nOutput: 3\nExplanation: The longest uncommon subsequences are \"aaa\" and \"bbb\".\nExample 3:\nInput: a = \"aaa\", b = \"aaa\"\nOutput: -1\nExplanation: Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a. So the answer would be -1.\nConstraints:\n\t1 <= a.length, b.length <= 100\n\ta and b consist of lower-case English letters.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/longest-uncommon-subsequence-i/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        ",
        "givenJsCode": "/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nvar findLUSlength = function(a, b) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int findLUSlength(String a, String b) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1.\nAn uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others.\nA subsequence of a string s is a string that can be obtained after deleting any number of characters from s.\n\tFor example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string).\nExample 1:\nInput: strs = [\"aba\",\"cdc\",\"eae\"]\nOutput: 3\nExample 2:\nInput: strs = [\"aaa\",\"aaa\",\"aa\"]\nOutput: -1\nConstraints:\n\t2 <= strs.length <= 50\n\t1 <= strs[i].length <= 10\n\tstrs[i] consists of lowercase English letters.",
        "topics": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "String",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/longest-uncommon-subsequence-ii/",
        "givenPythonCode": "/**\n * @param {string[]} strs\n * @return {number}\n */\nvar findLUSlength = function(strs) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findLUSlength(self, strs: List[str]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findLUSlength(String[] strs) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\nExample 1:\nInput: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".\nExample 2:\nInput: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".\nExample 3:\nInput: s = \"\"\nOutput: 0\nConstraints:\n\t0 <= s.length <= 3 * 10^4\n\ts[i] is '(', or ')'.",
        "topics": [
            "String",
            "Dynamic Programming",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/longest-valid-parentheses/",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestValidParentheses = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int longestValidParentheses(String s) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\nExample 1:\nInput: s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"]\nOutput: \"apple\"\nExample 2:\nInput: s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"]\nOutput: \"a\"\nConstraints:\n\t1 <= s.length <= 1000\n\t1 <= dictionary.length <= 1000\n\t1 <= dictionary[i].length <= 1000\n\ts and dictionary[i] consist of lowercase English letters.",
        "topics": [
            "Array",
            "Two Pointers",
            "String",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {string[]} dictionary\n * @return {string}\n */\nvar findLongestWord = function(s, dictionary) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findLongestWord(self, s: str, dictionary: List[str]) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String findLongestWord(String s, List<String> dictionary) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an integer array of size n, find all elements that appear more than \u00e2\u0152\u0160 n/3 \u00e2\u0152\u2039 times.\nExample 1:\nInput: nums = [3,2,3]\nOutput: [3]\nExample 2:\nInput: nums = [1]\nOutput: [1]\nExample 3:\nInput: nums = [1,2]\nOutput: [1,2]\nConstraints:\n\t1 <= nums.length <= 5 * 10^4\n\t-10^9 <= nums[i] <= 10^9\nFollow up: Could you solve the problem in linear time and in O(1) space?",
        "topics": [
            "Array",
            "Hash Table",
            "Sorting",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/majority-element-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar majorityElement = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a binary array nums, return the maximum number of consecutive 1's in the array.\nExample 1:\nInput: nums = [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\nExample 2:\nInput: nums = [1,0,1,1,0,1]\nOutput: 2\nConstraints:\n\t1 <= nums.length <= 10^5\n\tnums[i] is either 0 or 1.",
        "topics": [
            "Array"
        ],
        "url": "https://leetcode.com/problems/max-consecutive-ones/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxConsecutiveOnes = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.\nExample 1:\nInput: words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]\nOutput: 16\nExplanation: The two words can be \"abcw\", \"xtfn\".\nExample 2:\nInput: words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]\nOutput: 4\nExplanation: The two words can be \"ab\", \"cd\".\nExample 3:\nInput: words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\nOutput: 0\nExplanation: No such pair of words.\nConstraints:\n\t2 <= words.length <= 1000\n\t1 <= words[i].length <= 1000\n\twords[i] consists only of lowercase English letters.",
        "topics": [
            "Array",
            "String",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/maximum-product-of-word-lengths/",
        "givenPythonCode": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar maxProduct = function(words) {\n    \n};",
        "givenJsCode": "class Solution:\n    def maxProduct(self, words: List[str]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int maxProduct(String[] words) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, find a subarray that has the largest product, and return the product.\nThe test cases are generated so that the answer will fit in a 32-bit integer.\nExample 1:\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.\nExample 2:\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.\nConstraints:\n\t1 <= nums.length <= 2 * 10^4\n\t-10 <= nums[i] <= 10\n\tThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/maximum-product-subarray/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxProduct = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int maxProduct(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with maximum sum and return them.\nReturn the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.\nExample 1:\nInput: nums = [1,2,1,2,6,7,5,1], k = 2\nOutput: [0,3,5]\nExplanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\nWe could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.\nExample 2:\nInput: nums = [1,2,1,2,1,2,1,2,1], k = 2\nOutput: [0,2,4]\nConstraints:\n\t1 <= nums.length <= 2 * 10^4\n\t1 <= nums[i] < 2^16\n\t1 <= k <= floor(nums.length / 3)",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/",
        "givenPythonCode": "class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        ",
        "givenJsCode": "class Solution {\n    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSumOfThreeSubarrays = function(nums, k) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\nExample 1:\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\nExample 2:\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\nConstraints:\n\t1 <= intervals.length <= 10^4\n\tintervals[i].length == 2\n\t0 <= starti <= endi <= 10^4",
        "topics": [
            "Array",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/merge-intervals/",
        "givenPythonCode": "/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nvar merge = function(intervals) {\n    \n};",
        "givenJsCode": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\nExample 2:\nInput: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].\nExample 3:\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\nConstraints:\n\tnums1.length == m + n\n\tnums2.length == n\n\t0 <= m, n <= 200\n\t1 <= m + n <= 200\n\t-10^9 <= nums1[i], nums2[j] <= 10^9\nFollow up: Can you come up with an algorithm that runs in O(m + n) time?",
        "topics": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/merge-sorted-array/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function(nums1, m, nums2, n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        ",
        "givenJavaCode": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        \n    }\n}"
    },
    {
        "excercise": "There are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the i^th worker and wage[i] is the minimum wage expectation for the i^th worker.\nWe want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:\n\tEvery worker in the paid group must be paid at least their minimum wage expectation.\n\tIn the group, each worker's pay must be directly proportional to their quality. This means if a worker\u00e2\u20ac\u2122s quality is double that of another worker in the group, then they must be paid twice as much as the other worker.\nGiven the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10^-5 of the actual answer will be accepted.\nExample 1:\nInput: quality = [10,20,5], wage = [70,50,30], k = 2\nOutput: 105.00000\nExplanation: We pay 70 to 0^th worker and 35 to 2^nd worker.\nExample 2:\nInput: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\nOutput: 30.66667\nExplanation: We pay 4 to 0^th worker, 13.33333 to 2^nd and 3^rd workers separately.\nConstraints:\n\tn == quality.length == wage.length\n\t1 <= k <= n <= 10^4\n\t1 <= quality[i], wage[i] <= 10^4",
        "topics": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/minimum-cost-to-hire-k-workers/",
        "givenPythonCode": "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        ",
        "givenJsCode": "class Solution {\n    public double mincostToHireWorkers(int[] quality, int[] wage, int k) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} quality\n * @param {number[]} wage\n * @param {number} k\n * @return {number}\n */\nvar mincostToHireWorkers = function(quality, wage, k) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.\nSuppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.\n\tFor example, \"AACCGGTT\" --> \"AACCGGTA\" is one mutation.\nThere is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\nGiven the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.\nNote that the starting point is assumed to be valid, so it might not be included in the bank.\nExample 1:\nInput: startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\nOutput: 1\nExample 2:\nInput: startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\nOutput: 2\nConstraints:\n\t0 <= bank.length <= 10\n\tstartGene.length == endGene.length == bank[i].length == 8\n\tstartGene, endGene, and bank[i] consist of only the characters ['A', 'C', 'G', 'T'].",
        "topics": [
            "Hash Table",
            "String",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/minimum-genetic-mutation/",
        "givenPythonCode": "/**\n * @param {string} startGene\n * @param {string} endGene\n * @param {string[]} bank\n * @return {number}\n */\nvar minMutation = function(startGene, endGene, bank) {\n    \n};",
        "givenJsCode": "class Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int minMutation(String startGene, String endGene, String[] bank) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\nIn one move, you can increment or decrement an element of the array by 1.\nTest cases are designed so that the answer will fit in a 32-bit integer.\nExample 1:\nInput: nums = [1,2,3]\nOutput: 2\nExplanation:\nOnly two moves are needed (remember each move increments or decrements one element):\n[1,2,3]  =>  [2,2,3]  =>  [2,2,2]\nExample 2:\nInput: nums = [1,10,2,9]\nOutput: 16\nConstraints:\n\tn == nums.length\n\t1 <= nums.length <= 10^5\n\t-10^9 <= nums[i] <= 10^9",
        "topics": [
            "Array",
            "Math",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/",
        "givenPythonCode": "class Solution:\n    def minMoves2(self, nums: List[int]) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minMoves2 = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int minMoves2(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\nIn one move, you can increment n - 1 elements of the array by 1.\nExample 1:\nInput: nums = [1,2,3]\nOutput: 3\nExplanation: Only three moves are needed (remember each move increments two elements):\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]\nExample 2:\nInput: nums = [1,1,1]\nOutput: 0\nConstraints:\n\tn == nums.length\n\t1 <= nums.length <= 10^5\n\t-10^9 <= nums[i] <= 10^9\n\tThe answer is guaranteed to fit in a 32-bit integer.",
        "topics": [
            "Array",
            "Math"
        ],
        "url": "https://leetcode.com/problems/minimum-moves-to-equal-array-elements/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minMoves = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def minMoves(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int minMoves(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\nExample 1:\nInput: points = [[10,16],[2,8],[1,6],[7,12]]\nOutput: 2\nExplanation: The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].\n- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].\nExample 2:\nInput: points = [[1,2],[3,4],[5,6],[7,8]]\nOutput: 4\nExplanation: One arrow needs to be shot for each balloon for a total of 4 arrows.\nExample 3:\nInput: points = [[1,2],[2,3],[3,4],[4,5]]\nOutput: 2\nExplanation: The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].\n- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].\nConstraints:\n\t1 <= points.length <= 10^5\n\tpoints[i].length == 2\n\t-2^31 <= xstart < xend <= 2^31 - 1",
        "topics": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/",
        "givenPythonCode": "/**\n * @param {number[][]} points\n * @return {number}\n */\nvar findMinArrowShots = function(points) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findMinArrowShots(int[][] points) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A car travels from a starting position to a destination which is target miles east of the starting position.\nThere are gas stations along the way. The gas stations are represented as an array stations where stations[i] = [positioni, fueli] indicates that the i^th gas station is positioni miles east of the starting position and has fueli liters of gas.\nThe car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\nReturn the minimum number of refueling stops the car must make in order to reach its destination. If it cannot reach the destination, return -1.\nNote that if the car reaches a gas station with 0 fuel left, the car can still refuel there. If the car reaches the destination with 0 fuel left, it is still considered to have arrived.\nExample 1:\nInput: target = 1, startFuel = 1, stations = []\nOutput: 0\nExplanation: We can reach the target without refueling.\nExample 2:\nInput: target = 100, startFuel = 1, stations = [[10,100]]\nOutput: -1\nExplanation: We can not reach the target (or even the first gas station).\nExample 3:\nInput: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]\nOutput: 2\nExplanation: We start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2.\nConstraints:\n\t1 <= target, startFuel <= 10^9\n\t0 <= stations.length <= 500\n\t1 <= positioni < positioni+1 < target\n\t1 <= fueli < 10^9",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Greedy",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/minimum-number-of-refueling-stops/",
        "givenPythonCode": "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} target\n * @param {number} startFuel\n * @param {number[][]} stations\n * @return {number}\n */\nvar minRefuelStops = function(target, startFuel, stations) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\nExample 1:\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\nExample 2:\nInput: target = 4, nums = [1,4,4]\nOutput: 1\nExample 3:\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\nConstraints:\n\t1 <= target <= 10^9\n\t1 <= nums.length <= 10^5\n\t1 <= nums[i] <= 10^4\nFollow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).",
        "topics": [
            "Array",
            "Binary Search",
            "Sliding Window",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/minimum-size-subarray-sum/",
        "givenPythonCode": "/**\n * @param {number} target\n * @param {number[]} nums\n * @return {number}\n */\nvar minSubArrayLen = function(target, nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference between any two time-points in the list.\nExample 1:\nInput: timePoints = [\"23:59\",\"00:00\"]\nOutput: 1\nExample 2:\nInput: timePoints = [\"00:00\",\"23:59\",\"00:00\"]\nOutput: 0\nConstraints:\n\t2 <= timePoints.length <= 2 * 10^4\n\ttimePoints[i] is in the format \"HH:MM\".",
        "topics": [
            "Array",
            "Math",
            "String",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/minimum-time-difference/",
        "givenPythonCode": "/**\n * @param {string[]} timePoints\n * @return {number}\n */\nvar findMinDifference = function(timePoints) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findMinDifference(self, timePoints: List[str]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findMinDifference(List<String> timePoints) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\nThe testcases will be generated such that the answer is unique.\nExample 1:\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\nExample 2:\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\nExample 3:\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\nConstraints:\n\tm == s.length\n\tn == t.length\n\t1 <= m, n <= 10^5\n\ts and t consist of uppercase and lowercase English letters.\nFollow up: Could you find an algorithm that runs in O(m + n) time?",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/minimum-window-substring/",
        "givenPythonCode": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        ",
        "givenJsCode": "class Solution {\n    public String minWindow(String s, String t) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\nExample 1:\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\nExample 2:\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\nExample 3:\nInput: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8\nExplanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\nConstraints:\n\tn == nums.length\n\t1 <= n <= 10^4\n\t0 <= nums[i] <= n\n\tAll the numbers of nums are unique.\nFollow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?",
        "topics": [
            "Array",
            "Hash Table",
            "Math",
            "Binary Search",
            "Bit Manipulation",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/missing-number/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar missingNumber = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int missingNumber(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\nExample 1:\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\nExample 2:\nInput: nums = [0]\nOutput: [0]\nConstraints:\n\t1 <= nums.length <= 10^4\n\t-2^31 <= nums[i] <= 2^31 - 1\nFollow up: Could you minimize the total number of operations done?",
        "topics": [
            "Array",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/move-zeroes/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "givenJavaCode": "class Solution {\n    public void moveZeroes(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\nExample 1:\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\nExample 2:\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\nConstraints:\n\t1 <= num1.length, num2.length <= 200\n\tnum1 and num2 consist of digits only.\n\tBoth num1 and num2 do not contain any leading zero, except the number 0 itself.",
        "topics": [
            "Math",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/multiply-strings/",
        "givenPythonCode": "/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar multiply = function(num1, num2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String multiply(String num1, String num2) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a positive integer n, find the smallest integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive integer exists, return -1.\nNote that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return -1.\nExample 1:\nInput: n = 12\nOutput: 21\nExample 2:\nInput: n = 21\nOutput: -1\nConstraints:\n\t1 <= n <= 2^31 - 1",
        "topics": [
            "Math",
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/next-greater-element-iii/",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar nextGreaterElement = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int nextGreaterElement(int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\tFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\tFor example, the next permutation of arr = [1,2,3] is [1,3,2].\n\tSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\n\tWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.\nExample 1:\nInput: nums = [1,2,3]\nOutput: [1,3,2]\nExample 2:\nInput: nums = [3,2,1]\nOutput: [1,2,3]\nExample 3:\nInput: nums = [1,1,5]\nOutput: [1,5,1]\nConstraints:\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 100",
        "topics": [
            "Array",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/next-permutation/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar nextPermutation = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "givenJavaCode": "class Solution {\n    public void nextPermutation(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.\nExample 1:\nInput: nums = [4,6,7,7]\nOutput: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\nExample 2:\nInput: nums = [4,4,3,2,1]\nOutput: [[4,4]]\nConstraints:\n\t1 <= nums.length <= 15\n\t-100 <= nums[i] <= 100",
        "topics": [
            "Array",
            "Hash Table",
            "Backtracking",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/non-decreasing-subsequences/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar findSubsequences = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a positive integer n, return the number of the integers in the range [0, n] whose binary representations do not contain consecutive ones.\nExample 1:\nInput: n = 5\nOutput: 5\nExplanation:\nHere are the non-negative integers <= 5 with their corresponding binary representations:\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \nExample 2:\nInput: n = 1\nOutput: 2\nExample 3:\nInput: n = 2\nOutput: 3\nConstraints:\n\t1 <= n <= 10^9",
        "topics": [
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/",
        "givenPythonCode": "class Solution:\n    def findIntegers(self, n: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int findIntegers(int n) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar findIntegers = function(n) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "A positive integer is magical if it is divisible by either a or b.\nGiven the three integers n, a, and b, return the n^th magical number. Since the answer may be very large, return it modulo 10^9 + 7.\nExample 1:\nInput: n = 1, a = 2, b = 3\nOutput: 2\nExample 2:\nInput: n = 4, a = 2, b = 3\nOutput: 6\nConstraints:\n\t1 <= n <= 10^9\n\t2 <= a, b <= 4 * 10^4",
        "topics": [
            "Math",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/nth-magical-number/",
        "givenPythonCode": "class Solution:\n    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int nthMagicalNumber(int n, int a, int b) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} n\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nvar nthMagicalNumber = function(n, a, b) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\tFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\nGiven an integer num, return its complement.\nExample 1:\nInput: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\nExample 2:\nInput: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\nConstraints:\n\t1 <= num < 2^31\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "topics": [
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/number-complement/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} num\n * @return {number}\n */\nvar findComplement = function(num) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findComplement(self, num: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findComplement(int num) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string formula representing a chemical formula, return the count of each atom.\nThe atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\nOne or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.\n\tFor example, \"H2O\" and \"H2O2\" are possible, but \"H1O2\" is impossible.\nTwo formulas are concatenated together to produce another formula.\n\tFor example, \"H2O2He3Mg4\" is also a formula.\nA formula placed in parentheses, and a count (optionally added) is also a formula.\n\tFor example, \"(H2O2)\" and \"(H2O2)3\" are formulas.\nReturn the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\nThe test cases are generated so that all the values in the output fit in a 32-bit integer.\nExample 1:\nInput: formula = \"H2O\"\nOutput: \"H2O\"\nExplanation: The count of elements are {'H': 2, 'O': 1}.\nExample 2:\nInput: formula = \"Mg(OH)2\"\nOutput: \"H2MgO2\"\nExplanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\nExample 3:\nInput: formula = \"K4(ON(SO3)2)2\"\nOutput: \"K4N2O14S4\"\nExplanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.\nConstraints:\n\t1 <= formula.length <= 1000\n\tformula consists of English letters, digits, '(', and ')'.\n\tformula is always valid.",
        "topics": [
            "Hash Table",
            "String",
            "Stack",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/number-of-atoms/",
        "givenPythonCode": "class Solution:\n    def countOfAtoms(self, formula: str) -> str:\n        ",
        "givenJsCode": "/**\n * @param {string} formula\n * @return {string}\n */\nvar countOfAtoms = function(formula) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public String countOfAtoms(String formula) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a string s, return the number of segments in the string.\nA segment is defined to be a contiguous sequence of non-space characters.\nExample 1:\nInput: s = \"Hello, my name is John\"\nOutput: 5\nExplanation: The five segments are [\"Hello,\", \"my\", \"name\", \"is\", \"John\"]\nExample 2:\nInput: s = \"Hello\"\nOutput: 1\nConstraints:\n\t0 <= s.length <= 300\n\ts consists of lowercase and uppercase English letters, digits, or one of the following characters \"!@#$%^&*()_+-=',.:\".\n\tThe only space character in s is ' '.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/number-of-segments-in-a-string/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar countSegments = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def countSegments(self, s: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int countSegments(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "You are given an array of binary strings strs and two integers m and n.\nReturn the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.\nA set x is a subset of a set y if all elements of x are also elements of y.\nExample 1:\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\nOutput: 4\nExplanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\nOther valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}.\n{\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\nExample 2:\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\nOutput: 2\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\nConstraints:\n\t1 <= strs.length <= 600\n\t1 <= strs[i].length <= 100\n\tstrs[i] consists only of digits '0' and '1'.\n\t1 <= m, n <= 100",
        "topics": [
            "Array",
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/ones-and-zeroes/",
        "givenPythonCode": "/**\n * @param {string[]} strs\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar findMaxForm = function(strs, m, n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given an integer array nums. The adjacent integers in nums will perform the float division.\n\tFor example, for nums = [2,3,4], we will evaluate the expression \"2/3/4\".\nHowever, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.\nReturn the corresponding expression that has the maximum value in string format.\nNote: your expression should not contain redundant parenthesis.\nExample 1:\nInput: nums = [1000,100,10,2]\nOutput: \"1000/(100/10/2)\"\nExplanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200\nHowever, the bold parenthesis in \"1000/((100/10)/2)\" are redundant since they do not influence the operation priority.\nSo you should return \"1000/(100/10/2)\".\nOther cases:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\nExample 2:\nInput: nums = [2,3,4]\nOutput: \"2/(3/4)\"\nExplanation: (2/(3/4)) = 8/3 = 2.667\nIt can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667\nConstraints:\n\t1 <= nums.length <= 10\n\t2 <= nums[i] <= 1000\n\tThere is only one optimal division for the given input.",
        "topics": [
            "Array",
            "Math",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/optimal-division/",
        "givenPythonCode": "class Solution:\n    def optimalDivision(self, nums: List[int]) -> str:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {string}\n */\nvar optimalDivision = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public String optimalDivision(int[] nums) {\n        \n    }\n}",
        "difficulty": "LeetCode Logo\r\n-\r\n\r\navatar\r\nPremium\r\nDebugging...\r\nDebugging...\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nRun\r\nDescription\r\nEditorial\r\nEditorial\r\nSolutions\r\nSolutions\r\nSubmissions\r\nSubmissions\r\n\r\n\r\nCode\r\nTestcase\r\nTest Result\r\nTest Result\r\n474. Ones and Zeroes\r\nMedium\r\nYou are given an array of binary strings strs and two integers m and n.\r\n\r\nReturn the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.\r\n\r\nA set x is a subset of a set y if all elements of x are also elements of y.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\r\nOutput: 4\r\nExplanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\r\nOther valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}.\r\n{\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\r\nExample 2:\r\n\r\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\r\nOutput: 2\r\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\r\n \r\n\r\nConstraints:\r\n\r\n1 <= strs.length <= 600\r\n1 <= strs[i].length <= 100\r\nstrs[i] consists only of digits '0' and '1'.\r\n1 <= m, n <= 100\r\nSeen this question in a real interview before?\r\n1/5\r\nYes\r\nNo\r\nAccepted\r\n0\r\nSubmissions\r\n0\r\nAcceptance Rate\r\n0%\r\nDiscussion (0)\r\nCopyright \u00a9\ufe0f 2024 LeetCode All rights reserved\r\n\r\n5.4K\r\n\r\n\r\n\r\n\r\nCase 1\r\nCase 2\r\n\r\nstrs =\r\n[\"10\",\"0001\",\"111001\",\"1\",\"0\"]\r\nm =\r\n5\r\nn =\r\n3\r\n"
    },
    {
        "excercise": "Given an integer x, return true if x is a palindrome, and false otherwise.\nExample 1:\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\nExample 2:\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\nExample 3:\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\nConstraints:\n\t-2^31 <= x <= 2^31 - 1\nFollow up: Could you solve it without converting the integer to a string?",
        "topics": [
            "Math"
        ],
        "url": "https://leetcode.com/problems/palindrome-number/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function(x) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isPalindrome(int x) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string s, partition s such that every substring of the partition is a palindrome.\nReturn the minimum cuts needed for a palindrome partitioning of s.\nExample 1:\nInput: s = \"aab\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\nExample 2:\nInput: s = \"a\"\nOutput: 0\nExample 3:\nInput: s = \"ab\"\nOutput: 1\nConstraints:\n\t1 <= s.length <= 2000\n\ts consists of lowercase English letters only.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/palindrome-partitioning-ii/",
        "givenPythonCode": "class Solution:\n    def minCut(self, s: str) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int minCut(String s) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar minCut = function(s) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\nExample 1:\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nExample 2:\nInput: s = \"a\"\nOutput: [[\"a\"]]\nConstraints:\n\t1 <= s.length <= 16\n\ts contains only lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/palindrome-partitioning/",
        "givenPythonCode": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @return {string[][]}\n */\nvar partition = function(s) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public List<List<String>> partition(String s) {\n        \n    }\n}",
        "difficulty": "ung\u00fcltig"
    },
    {
        "excercise": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.\nExample 1:\nInput: nums = [1,5,11,5]\nOutput: true\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\nExample 2:\nInput: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot be partitioned into equal sum subsets.\nConstraints:\n\t1 <= nums.length <= 200\n\t1 <= nums[i] <= 100",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/partition-equal-subset-sum/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canPartition = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean canPartition(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.\nReturn the minimum number of patches required.\nExample 1:\nInput: nums = [1,3], n = 6\nOutput: 1\nExplanation:\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\nSo we only need 1 patch.\nExample 2:\nInput: nums = [1,5,10], n = 20\nOutput: 2\nExplanation: The two patches can be [2, 4].\nExample 3:\nInput: nums = [1,2,2], n = 5\nOutput: 0\nConstraints:\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 10^4\n\tnums is sorted in ascending order.\n\t1 <= n <= 2^31 - 1",
        "topics": [
            "Array",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/patching-array/",
        "givenPythonCode": "class Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int minPatches(int[] nums, int n) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @param {number} n\n * @return {number}\n */\nvar minPatches = function(nums, n) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly.\nGiven an integer n, return true if n is a perfect number, otherwise return false.\nExample 1:\nInput: num = 28\nOutput: true\nExplanation: 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28.\nExample 2:\nInput: num = 7\nOutput: false\nConstraints:\n\t1 <= num <= 10^8",
        "topics": [
            "Math"
        ],
        "url": "https://leetcode.com/problems/perfect-number/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} num\n * @return {boolean}\n */\nvar checkPerfectNumber = function(num) {\n    \n};",
        "givenJsCode": "class Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean checkPerfectNumber(int num) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\nExample 1:\nInput: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.\nExample 2:\nInput: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.\nConstraints:\n\t1 <= n <= 10^4",
        "topics": [
            "Math",
            "Dynamic Programming",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/perfect-squares/",
        "givenPythonCode": "class Solution:\n    def numSquares(self, n: int) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar numSquares = function(n) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int numSquares(int n) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\nIn other words, return true if one of s1's permutations is the substring of s2.\nExample 1:\nInput: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: true\nExplanation: s2 contains one permutation of s1 (\"ba\").\nExample 2:\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: false\nConstraints:\n\t1 <= s1.length, s2.length <= 10^4\n\ts1 and s2 consist of lowercase English letters.",
        "topics": [
            "Hash Table",
            "Two Pointers",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/permutation-in-string/",
        "givenPythonCode": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar checkInclusion = function(s1, s2) {\n    \n};",
        "givenJsCode": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\nExample 1:\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\nExample 2:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nConstraints:\n\t1 <= nums.length <= 8\n\t-10 <= nums[i] <= 10",
        "topics": [
            "Array",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/permutations-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permuteUnique = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nExample 2:\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\nExample 3:\nInput: nums = [1]\nOutput: [[1]]\nConstraints:\n\t1 <= nums.length <= 6\n\t-10 <= nums[i] <= 10\n\tAll the integers of nums are unique.",
        "topics": [
            "Array",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/permutations/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given a large integer represented as an integer array digits, where each digits[i] is the i^th digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\nExample 1:\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\nExample 2:\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\nExample 3:\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\nConstraints:\n\t1 <= digits.length <= 100\n\t0 <= digits[i] <= 9\n\tdigits does not contain any leading 0's.",
        "topics": [
            "Array",
            "Math"
        ],
        "url": "https://leetcode.com/problems/plus-one/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} digits\n * @return {number[]}\n */\nvar plusOne = function(digits) {\n    \n};",
        "givenJsCode": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] plusOne(int[] digits) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\nExample 2:\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\nConstraints:\n\t2 <= nums.length <= 10^5\n\t-30 <= nums[i] <= 30\n\tThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nFollow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)",
        "topics": [
            "Array",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/product-of-array-except-self/",
        "givenPythonCode": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function(nums) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\nEach letter in magazine can only be used once in ransomNote.\nExample 1:\nInput: ransomNote = \"a\", magazine = \"b\"\nOutput: false\nExample 2:\nInput: ransomNote = \"aa\", magazine = \"ab\"\nOutput: false\nExample 3:\nInput: ransomNote = \"aa\", magazine = \"aab\"\nOutput: true\nConstraints:\n\t1 <= ransomNote.length, magazine.length <= 10^5\n\transomNote and magazine consist of lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "url": "https://leetcode.com/problems/ransom-note/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} ransomNote\n * @param {string} magazine\n * @return {boolean}\n */\nvar canConstruct = function(ransomNote, magazine) {\n    \n};",
        "givenJsCode": "class Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        \n    }\n}"
    },
    {
        "excercise": "Given four integers sx, sy, tx, and ty, return true if it is possible to convert the point (sx, sy) to the point (tx, ty) through some operations, or false otherwise.\nThe allowed operation on some point (x, y) is to convert it to either (x, x + y) or (x + y, y).\nExample 1:\nInput: sx = 1, sy = 1, tx = 3, ty = 5\nOutput: true\nExplanation:\nOne series of moves that transforms the starting point to the target is:\n(1, 1) -> (1, 2)\n(1, 2) -> (3, 2)\n(3, 2) -> (3, 5)\nExample 2:\nInput: sx = 1, sy = 1, tx = 2, ty = 2\nOutput: false\nExample 3:\nInput: sx = 1, sy = 1, tx = 1, ty = 1\nOutput: true\nConstraints:\n\t1 <= sx, sy, tx, ty <= 10^9",
        "topics": [
            "Math"
        ],
        "url": "https://leetcode.com/problems/reaching-points/",
        "givenPythonCode": "class Solution:\n    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:\n        ",
        "givenJsCode": "class Solution {\n    public boolean reachingPoints(int sx, int sy, int tx, int ty) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} sx\n * @param {number} sy\n * @param {number} tx\n * @param {number} ty\n * @return {boolean}\n */\nvar reachingPoints = function(sx, sy, tx, ty) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.\nExample 1:\nInput: s = \"owoztneoer\"\nOutput: \"012\"\nExample 2:\nInput: s = \"fviefuro\"\nOutput: \"45\"\nConstraints:\n\t1 <= s.length <= 10^5\n\ts[i] is one of the characters [\"e\",\"g\",\"f\",\"i\",\"h\",\"o\",\"n\",\"s\",\"r\",\"u\",\"t\",\"w\",\"v\",\"x\",\"z\"].\n\ts is guaranteed to be valid.",
        "topics": [
            "Hash Table",
            "Math",
            "String"
        ],
        "url": "https://leetcode.com/problems/reconstruct-original-digits-from-english/",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {string}\n */\nvar originalDigits = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def originalDigits(self, s: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String originalDigits(String s) {\n        \n    }\n}",
        "difficulty": "ung\u00fcltig"
    },
    {
        "excercise": "You are given an integer array score of size n, where score[i] is the score of the i^th athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1^st place athlete has the highest score, the 2^nd place athlete has the 2^nd highest score, and so on. The placement of each athlete determines their rank:\n\tThe 1^st place athlete's rank is \"Gold Medal\".\n\tThe 2^nd place athlete's rank is \"Silver Medal\".\n\tThe 3^rd place athlete's rank is \"Bronze Medal\".\n\tFor the 4^th place to the n^th place athlete, their rank is their placement number (i.e., the x^th place athlete's rank is \"x\").\nReturn an array answer of size n where answer[i] is the rank of the i^th athlete.\nExample 1:\nInput: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1^st, 2^nd, 3^rd, 4^th, 5^th].\nExample 2:\nInput: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1^st, 5^th, 3^rd, 2^nd, 4^th].\nConstraints:\n\tn == score.length\n\t1 <= n <= 10^4\n\t0 <= score[i] <= 10^6\n\tAll the values in score are unique.",
        "topics": [
            "Array",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/relative-ranks/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def findRelativeRanks(self, score: List[int]) -> List[str]:\n        ",
        "givenJsCode": "/**\n * @param {number[]} score\n * @return {string[]}\n */\nvar findRelativeRanks = function(score) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nConstraints:\n\t1 <= nums.length <= 3 * 10^4\n\t-10^4 <= nums[i] <= 10^4\n\tnums is sorted in non-decreasing order.",
        "topics": [
            "Array",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\tChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\n\tReturn k.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nConstraints:\n\t1 <= nums.length <= 3 * 10^4\n\t-100 <= nums[i] <= 100\n\tnums is sorted in non-decreasing order.",
        "topics": [
            "Array",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\n\tChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\n\tReturn k.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\nint k = removeElement(nums, val); // Calls your implementation\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nConstraints:\n\t0 <= nums.length <= 100\n\t0 <= nums[i] <= 50\n\t0 <= val <= 100",
        "topics": [
            "Array",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/remove-element/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function(nums, val) {\n    \n};",
        "givenJsCode": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\nReturn a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.\nExample 1:\nInput: s = \"()())()\"\nOutput: [\"(())()\",\"()()()\"]\nExample 2:\nInput: s = \"(a)())()\"\nOutput: [\"(a())()\",\"(a)()()\"]\nExample 3:\nInput: s = \")(\"\nOutput: [\"\"]\nConstraints:\n\t1 <= s.length <= 25\n\ts consists of lowercase English letters and parentheses '(' and ')'.\n\tThere will be at most 20 parentheses in s.",
        "topics": [
            "String",
            "Backtracking",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/remove-invalid-parentheses/",
        "givenPythonCode": "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        ",
        "givenJsCode": "class Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar removeInvalidParentheses = function(s) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\tFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\nExample 1:\nInput: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]\nExample 2:\nInput: s = \"0000\"\nOutput: [\"0.0.0.0\"]\nExample 3:\nInput: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\nConstraints:\n\t1 <= s.length <= 20\n\ts consists of digits only.",
        "topics": [
            "String",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/restore-ip-addresses/",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<String> restoreIpAddresses(String s) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\nExample 1:\nInput: x = 123\nOutput: 321\nExample 2:\nInput: x = -123\nOutput: -321\nExample 3:\nInput: x = 120\nOutput: 21\nConstraints:\n\t-2^31 <= x <= 2^31 - 1",
        "topics": [
            "Math"
        ],
        "url": "https://leetcode.com/problems/reverse-integer/",
        "givenPythonCode": "/**\n * @param {number} x\n * @return {number}\n */\nvar reverse = function(x) {\n    \n};",
        "givenJsCode": "class Solution:\n    def reverse(self, x: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int reverse(int x) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.\nIf there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.\nExample 1:\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\nExample 2:\nInput: s = \"abcd\", k = 2\nOutput: \"bacd\"\nConstraints:\n\t1 <= s.length <= 10^4\n\ts consists of only lowercase English letters.\n\t1 <= k <= 10^4",
        "topics": [
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/reverse-string-ii/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar reverseStr = function(s, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def reverseStr(self, s: str, k: int) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String reverseStr(String s, int k) {\n        \n    }\n}"
    },
    {
        "excercise": "Write a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\nExample 2:\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\nConstraints:\n\t1 <= s.length <= 10^5\n\ts[i] is a printable ascii character.",
        "topics": [
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/reverse-string/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n */\nvar reverseString = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        ",
        "givenJavaCode": "class Solution {\n    public void reverseString(char[] s) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\nExample 1:\nInput: s = \"hello\"\nOutput: \"holle\"\nExample 2:\nInput: s = \"leetcode\"\nOutput: \"leotcede\"\nConstraints:\n\t1 <= s.length <= 3 * 10^5\n\ts consist of printable ASCII characters.",
        "topics": [
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/reverse-vowels-of-a-string/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {string}\n */\nvar reverseVowels = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def reverseVowels(self, s: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String reverseVowels(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\nExample 1:\nInput: s = \"the sky is blue\"\nOutput: \"blue is sky the\"\nExample 2:\nInput: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\nExample 3:\nInput: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\nConstraints:\n\t1 <= s.length <= 10^4\n\ts contains English letters (upper-case and lower-case), digits, and spaces ' '.\n\tThere is at least one word in s.\nFollow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?",
        "topics": [
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/reverse-words-in-a-string/",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String reverseWords(String s) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\tI can be placed before V (5) and X (10) to make 4 and 9. \n\tX can be placed before L (50) and C (100) to make 40 and 90. \n\tC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\nExample 1:\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\nExample 2:\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 3:\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\nConstraints:\n\t1 <= s.length <= 15\n\ts contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\n\tIt is guaranteed that s is a valid roman numeral in the range [1, 3999].",
        "topics": [
            "Hash Table",
            "Math",
            "String"
        ],
        "url": "https://leetcode.com/problems/roman-to-integer/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int romanToInt(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\nExample 1:\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\nExample 2:\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\nConstraints:\n\t1 <= nums.length <= 10^5\n\t-2^31 <= nums[i] <= 2^31 - 1\n\t0 <= k <= 10^5\nFollow up:\n\tTry to come up with as many solutions as you can. There are at least three different ways to solve this problem.\n\tCould you do it in-place with O(1) extra space?",
        "topics": [
            "Array",
            "Math",
            "Two Pointers"
        ],
        "url": "https://leetcode.com/problems/rotate-array/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar rotate = function(nums, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "givenJavaCode": "class Solution {\n    public void rotate(int[] nums, int k) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\nReturn the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\nNote: You cannot rotate an envelope.\nExample 1:\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\nExample 2:\nInput: envelopes = [[1,1],[1,1],[1,1]]\nOutput: 1\nConstraints:\n\t1 <= envelopes.length <= 10^5\n\tenvelopes[i].length == 2\n\t1 <= wi, hi <= 10^5",
        "topics": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/russian-doll-envelopes/",
        "givenPythonCode": "class Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int maxEnvelopes(int[][] envelopes) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[][]} envelopes\n * @return {number}\n */\nvar maxEnvelopes = function(envelopes) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "We can scramble a string s to get a string t using the following algorithm:\n\tIf the length of the string is 1, stop.\n\tIf the length of the string is > 1, do the following:\n\t\tSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\n\t\tRandomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\n\t\tApply step 1 recursively on each of the two substrings x and y.\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\nExample 1:\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\nExample 2:\nInput: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false\nExample 3:\nInput: s1 = \"a\", s2 = \"a\"\nOutput: true\nConstraints:\n\ts1.length == s2.length\n\t1 <= s1.length <= 30\n\ts1 and s2 consist of lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/scramble-string/",
        "givenPythonCode": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        ",
        "givenJsCode": "class Solution {\n    public boolean isScramble(String s1, String s2) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar isScramble = function(s1, s2) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\nYou must decrease the overall operation steps as much as possible.\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\nExample 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\nConstraints:\n\t1 <= nums.length <= 5000\n\t-10^4 <= nums[i] <= 10^4\n\tnums is guaranteed to be rotated at some pivot.\n\t-10^4 <= target <= 10^4\nFollow up: This problem is similar to Search in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {boolean}\n */\nvar search = function(nums, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean search(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\nInput: nums = [1], target = 0\nOutput: -1\nConstraints:\n\t1 <= nums.length <= 5000\n\t-10^4 <= nums[i] <= 10^4\n\tAll values of nums are unique.\n\tnums is an ascending array that is possibly rotated.\n\t-10^4 <= target <= 10^4",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
        "givenPythonCode": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\nExample 2:\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\nExample 3:\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\nConstraints:\n\t1 <= nums.length <= 10^4\n\t-10^4 <= nums[i] <= 10^4\n\tnums contains distinct values sorted in ascending order.\n\t-10^4 <= target <= 10^4",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/search-insert-position/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an absolute path for a Unix-style file system, which begins with a slash '/', transform this path into its simplified canonical path.\nIn Unix-style file system context, a single period '.' signifies the current directory, a double period \"..\" denotes moving up one directory level, and multiple slashes such as \"//\" are interpreted as a single slash. In this problem, treat sequences of periods not covered by the previous rules (like \"...\") as valid names for files or directories.\nThe simplified canonical path should adhere to the following rules:\n\tIt must start with a single slash '/'.\n\tDirectories within the path should be separated by only one slash '/'.\n\tIt should not end with a slash '/', unless it's the root directory.\n\tIt should exclude any single or double periods used to denote current or parent directories.\nReturn the new path.\nExample 1:\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation:\nThe trailing slash should be removed.\nExample 2:\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation:\nMultiple consecutive slashes are replaced by a single one.\nExample 3:\nInput: path = \"/home/user/Documents/../Pictures\"\nOutput: \"/home/user/Pictures\"\nExplanation:\nA double period \"..\" refers to the directory up a level.\nExample 4:\nInput: path = \"/../\"\nOutput: \"/\"\nExplanation:\nGoing one level up from the root directory is not possible.\nExample 5:\nInput: path = \"/.../a/../b/c/../d/./\"\nOutput: \"/.../b/d\"\nExplanation:\n\"...\" is a valid name for a directory in this problem.\nConstraints:\n\t1 <= path.length <= 3000\n\tpath consists of English letters, digits, period '.', slash '/' or '_'.\n\tpath is a valid absolute Unix path.",
        "topics": [
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/simplify-path/",
        "givenPythonCode": "/**\n * @param {string} path\n * @return {string}\n */\nvar simplifyPath = function(path) {\n    \n};",
        "givenJsCode": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String simplifyPath(String path) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\nReturn the single element that appears only once.\nYour solution must run in O(log n) time and O(1) space.\nExample 1:\nInput: nums = [1,1,2,3,3,4,4,8,8]\nOutput: 2\nExample 2:\nInput: nums = [3,3,7,7,10,11,11]\nOutput: 10\nConstraints:\n\t1 <= nums.length <= 10^5\n\t0 <= nums[i] <= 10^5",
        "topics": [
            "Array",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/single-element-in-a-sorted-array/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNonDuplicate = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nExample 1:\nInput: nums = [2,2,3,2]\nOutput: 3\nExample 2:\nInput: nums = [0,1,0,1,0,1,99]\nOutput: 99\nConstraints:\n\t1 <= nums.length <= 3 * 10^4\n\t-2^31 <= nums[i] <= 2^31 - 1\n\tEach element in nums appears exactly three times except for one element which appears once.",
        "topics": [
            "Array",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/single-number-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int singleNumber(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.\nYou must write an algorithm that runs in linear runtime complexity and uses only constant extra space.\nExample 1:\nInput: nums = [1,2,1,3,2,5]\nOutput: [3,5]\nExplanation:  [5, 3] is also a valid answer.\nExample 2:\nInput: nums = [-1,0]\nOutput: [-1,0]\nExample 3:\nInput: nums = [0,1]\nOutput: [1,0]\nConstraints:\n\t2 <= nums.length <= 3 * 10^4\n\t-2^31 <= nums[i] <= 2^31 - 1\n\tEach integer in nums will appear twice, only two integers will appear once.",
        "topics": [
            "Array",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/single-number-iii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar singleNumber = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] singleNumber(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\tFor examples, if arr = [2,3,4], the median is 3.\n\tFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10^-5 of the actual value will be accepted.\nExample 1:\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6\nExample 2:\nInput: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]\nConstraints:\n\t1 <= k <= nums.length <= 10^5\n\t-2^31 <= nums[i] <= 2^31 - 1",
        "topics": [
            "Array",
            "Hash Table",
            "Sliding Window",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/sliding-window-median/",
        "givenPythonCode": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        ",
        "givenJsCode": "class Solution {\n    public double[] medianSlidingWindow(int[] nums, int k) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar medianSlidingWindow = function(nums, k) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer n represented as a string, return the smallest good base of n.\nWe call k >= 2 a good base of n, if all digits of n base k are 1's.\nExample 1:\nInput: n = \"13\"\nOutput: \"3\"\nExplanation: 13 base 3 is 111.\nExample 2:\nInput: n = \"4681\"\nOutput: \"8\"\nExplanation: 4681 base 8 is 11111.\nExample 3:\nInput: n = \"1000000000000000000\"\nOutput: \"999999999999999999\"\nExplanation: 1000000000000000000 base 999999999999999999 is 11.\nConstraints:\n\tn is an integer in the range [3, 10^18].\n\tn does not contain any leading zeros.",
        "topics": [
            "Math",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/smallest-good-base/",
        "givenPythonCode": "class Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        ",
        "givenJsCode": "class Solution {\n    public String smallestGoodBase(String n) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} n\n * @return {string}\n */\nvar smallestGoodBase = function(n) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.\nWe define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.\nExample 1:\nInput: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\nOutput: [20,24]\nExplanation: \nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\nList 3: [5, 18, 22, 30], 22 is in range [20,24].\nExample 2:\nInput: nums = [[1,2,3],[1,2,3],[1,2,3]]\nOutput: [1,1]\nConstraints:\n\tnums.length == k\n\t1 <= k <= 3500\n\t1 <= nums[i].length <= 50\n\t-10^5 <= nums[i][j] <= 10^5\n\tnums[i] is sorted in non-decreasing order.",
        "topics": [
            "Array",
            "Hash Table",
            "Greedy",
            "Sliding Window",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/",
        "givenPythonCode": "class Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        ",
        "givenJsCode": "class Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[][]} nums\n * @return {number[]}\n */\nvar smallestRange = function(nums) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.\nExample 1:\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\nExample 2:\nInput: nums = [2,0,1]\nOutput: [0,1,2]\nConstraints:\n\tn == nums.length\n\t1 <= n <= 300\n\tnums[i] is either 0, 1, or 2.\nFollow up: Could you come up with a one-pass algorithm using only constant extra space?",
        "topics": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/sort-colors/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar sortColors = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
        "givenJavaCode": "class Solution {\n    public void sortColors(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.\nReturn the minimized largest sum of the split.\nA subarray is a contiguous part of the array.\nExample 1:\nInput: nums = [7,2,5,10,8], k = 2\nOutput: 18\nExplanation: There are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\nExample 2:\nInput: nums = [1,2,3,4,5], k = 2\nOutput: 9\nExplanation: There are four ways to split nums into two subarrays.\nThe best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\nConstraints:\n\t1 <= nums.length <= 1000\n\t0 <= nums[i] <= 10^6\n\t1 <= k <= min(50, nums.length)",
        "topics": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Greedy",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/split-array-largest-sum/",
        "givenPythonCode": "class Solution:\n    def splitArray(self, nums: List[int], k: int) -> int:\n        ",
        "givenJsCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar splitArray = function(nums, k) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public int splitArray(int[] nums, int k) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou must not use any built-in exponent function or operator.\n\tFor example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\nExample 1:\nInput: x = 4\nOutput: 2\nExplanation: The square root of 4 is 2, so we return 2.\nExample 2:\nInput: x = 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\nConstraints:\n\t0 <= x <= 2^31 - 1",
        "topics": [
            "Math",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/sqrtx/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) {\n    \n};",
        "givenJsCode": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int mySqrt(int x) {\n        \n    }\n}"
    },
    {
        "excercise": "There is a strange printer with the following two special properties:\n\tThe printer can only print a sequence of the same character each time.\n\tAt each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\nGiven a string s, return the minimum number of turns the printer needed to print it.\nExample 1:\nInput: s = \"aaabbb\"\nOutput: 2\nExplanation: Print \"aaa\" first and then print \"bbb\".\nExample 2:\nInput: s = \"aba\"\nOutput: 2\nExplanation: Print \"aaa\" first and then print \"b\" from the second place of the string, which will cover the existing character 'a'.\nConstraints:\n\t1 <= s.length <= 100\n\ts consists of lowercase English letters.",
        "topics": [
            "String",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/strange-printer/",
        "givenPythonCode": "class Solution:\n    def strangePrinter(self, s: str) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int strangePrinter(String s) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s\n * @return {number}\n */\nvar strangePrinter = function(s) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an array of characters chars, compress it using the following algorithm:\nBegin with an empty string s. For each group of consecutive repeating characters in chars:\n\tIf the group's length is 1, append the character to s.\n\tOtherwise, append the character followed by the group's length.\nThe compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.\nAfter you are done modifying the input array, return the new length of the array.\nYou must write an algorithm that uses only constant extra space.\nExample 1:\nInput: chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\nOutput: Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\nExplanation: The groups are \"aa\", \"bb\", and \"ccc\". This compresses to \"a2b2c3\".\nExample 2:\nInput: chars = [\"a\"]\nOutput: Return 1, and the first character of the input array should be: [\"a\"]\nExplanation: The only group is \"a\", which remains uncompressed since it's a single character.\nExample 3:\nInput: chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\nOutput: Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\nExplanation: The groups are \"a\" and \"bbbbbbbbbbbb\". This compresses to \"ab12\".\nConstraints:\n\t1 <= chars.length <= 2000\n\tchars[i] is a lowercase English letter, uppercase English letter, digit, or symbol.",
        "topics": [
            "Two Pointers",
            "String"
        ],
        "url": "https://leetcode.com/problems/string-compression/",
        "givenPythonCode": "/**\n * @param {character[]} chars\n * @return {number}\n */\nvar compress = function(chars) {\n    \n};",
        "givenJsCode": "class Solution:\n    def compress(self, chars: List[str]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int compress(char[] chars) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\t'A': Absent.\n\t'L': Late.\n\t'P': Present.\nThe student is eligible for an attendance award if they meet both of the following criteria:\n\tThe student was absent ('A') for strictly fewer than 2 days total.\n\tThe student was never late ('L') for 3 or more consecutive days.\nReturn true if the student is eligible for an attendance award, or false otherwise.\nExample 1:\nInput: s = \"PPALLP\"\nOutput: true\nExplanation: The student has fewer than 2 absences and was never late 3 or more consecutive days.\nExample 2:\nInput: s = \"PPALLL\"\nOutput: false\nExplanation: The student was late 3 consecutive days in the last 3 days, so is not eligible for the award.\nConstraints:\n\t1 <= s.length <= 1000\n\ts[i] is either 'A', 'L', or 'P'.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/student-attendance-record-i/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar checkRecord = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def checkRecord(self, s: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean checkRecord(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\t'A': Absent.\n\t'L': Late.\n\t'P': Present.\nAny student is eligible for an attendance award if they meet both of the following criteria:\n\tThe student was absent ('A') for strictly fewer than 2 days total.\n\tThe student was never late ('L') for 3 or more consecutive days.\nGiven an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 10^9 + 7.\nExample 1:\nInput: n = 2\nOutput: 8\nExplanation: There are 8 records with length 2 that are eligible for an award:\n\"PP\", \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\"\nOnly \"AA\" is not eligible because there are 2 absences (there need to be fewer than 2).\nExample 2:\nInput: n = 1\nOutput: 3\nExample 3:\nInput: n = 10101\nOutput: 183236316\nConstraints:\n\t1 <= n <= 10^5",
        "topics": [
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/student-attendance-record-ii/",
        "givenPythonCode": "class Solution:\n    def checkRecord(self, n: int) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int checkRecord(int n) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar checkRecord = function(n) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nInput: nums = [1,1,1], k = 2\nOutput: 2\nExample 2:\nInput: nums = [1,2,3], k = 3\nOutput: 2\nConstraints:\n\t1 <= nums.length <= 2 * 10^4\n\t-1000 <= nums[i] <= 1000\n\t-10^7 <= k <= 10^7",
        "topics": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ],
        "url": "https://leetcode.com/problems/subarray-sum-equals-k/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar subarraySum = function(nums, k) {\n    \n};",
        "givenJsCode": "class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int subarraySum(int[] nums, int k) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nInput: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\nExample 2:\nInput: nums = [0]\nOutput: [[],[0]]\nConstraints:\n\t1 <= nums.length <= 10\n\t-10 <= nums[i] <= 10",
        "topics": [
            "Array",
            "Backtracking",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/subsets-ii/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsetsWithDup = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\nExample 2:\nInput: nums = [0]\nOutput: [[],[0]]\nConstraints:\n\t1 <= nums.length <= 10\n\t-10 <= nums[i] <= 10\n\tAll the numbers of nums are unique.",
        "topics": [
            "Array",
            "Backtracking",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/subsets/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.\n\tFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated string because it is not the concatenation of any permutation of words.\nReturn an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.\nExample 1:\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation:\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nExample 2:\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation:\nThere is no concatenated substring.\nExample 3:\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation:\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"].\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"].\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"].\nConstraints:\n\t1 <= s.length <= 10^4\n\t1 <= words.length <= 5000\n\t1 <= words[i].length <= 30\n\ts and words[i] consist of lowercase English letters.",
        "topics": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/",
        "givenPythonCode": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        ",
        "givenJsCode": "/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given two integers a and b, return the sum of the two integers without using the operators + and -.\nExample 1:\nInput: a = 1, b = 2\nOutput: 3\nExample 2:\nInput: a = 2, b = 3\nOutput: 5\nConstraints:\n\t-1000 <= a, b <= 1000",
        "topics": [
            "Math",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/sum-of-two-integers/",
        "givenPythonCode": "/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nvar getSum = function(a, b) {\n    \n};",
        "givenJsCode": "class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int getSum(int a, int b) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given a sorted unique integer array nums.\nA range [a,b] is the set of all integers from a to b (inclusive).\nReturn the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\nEach range [a,b] in the list should be output as:\n\t\"a->b\" if a != b\n\t\"a\" if a == b\nExample 1:\nInput: nums = [0,1,2,4,5,7]\nOutput: [\"0->2\",\"4->5\",\"7\"]\nExplanation: The ranges are:\n[0,2] --> \"0->2\"\n[4,5] --> \"4->5\"\n[7,7] --> \"7\"\nExample 2:\nInput: nums = [0,2,3,4,6,8,9]\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\nExplanation: The ranges are:\n[0,0] --> \"0\"\n[2,4] --> \"2->4\"\n[6,6] --> \"6\"\n[8,9] --> \"8->9\"\nConstraints:\n\t0 <= nums.length <= 20\n\t-2^31 <= nums[i] <= 2^31 - 1\n\tAll the values of nums are unique.\n\tnums is sorted in ascending order.",
        "topics": [
            "Array"
        ],
        "url": "https://leetcode.com/problems/summary-ranges/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {string[]}\n */\nvar summaryRanges = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        ",
        "givenJavaCode": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "A super ugly number is a positive integer whose prime factors are in the array primes.\nGiven an integer n and an array of integers primes, return the n^th super ugly number.\nThe n^th super ugly number is guaranteed to fit in a 32-bit signed integer.\nExample 1:\nInput: n = 12, primes = [2,7,13,19]\nOutput: 32\nExplanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\nExample 2:\nInput: n = 1, primes = [2,3,5]\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\nConstraints:\n\t1 <= n <= 10^5\n\t1 <= primes.length <= 100\n\t2 <= primes[i] <= 1000\n\tprimes[i] is guaranteed to be a prime number.\n\tAll the values of primes are unique and sorted in ascending order.",
        "topics": [
            "Array",
            "Math",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/super-ugly-number/",
        "givenPythonCode": "/**\n * @param {number} n\n * @param {number[]} primes\n * @return {number}\n */\nvar nthSuperUglyNumber = function(n, primes) {\n    \n};",
        "givenJsCode": "class Solution:\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int nthSuperUglyNumber(int n, int[] primes) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.\nFor each move, you could choose any m (1 <= m <= n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\nGiven an integer array machines representing the number of dresses in each washing machine from left to right on the line, return the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\nExample 1:\nInput: machines = [1,0,5]\nOutput: 3\nExplanation:\n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n3rd move:    2     1 <-- 3    =>    2     2     2\nExample 2:\nInput: machines = [0,3,0]\nOutput: 2\nExplanation:\n1st move:    0 <-- 3     0    =>    1     2     0\n2nd move:    1     2 --> 0    =>    1     1     1\nExample 3:\nInput: machines = [0,2,0]\nOutput: -1\nExplanation:\nIt's impossible to make all three washing machines have the same number of dresses.\nConstraints:\n\tn == machines.length\n\t1 <= n <= 10^4\n\t0 <= machines[i] <= 10^5",
        "topics": [
            "Array",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/super-washing-machines/",
        "givenPythonCode": "class Solution:\n    def findMinMoves(self, machines: List[int]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int findMinMoves(int[] machines) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {number[]} machines\n * @return {number}\n */\nvar findMinMoves = function(machines) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid.\nA code snippet is valid if all the following rules hold:\n\tThe code must be wrapped in a valid closed tag. Otherwise, the code is invalid.\n\tA closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.\n\tA valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.\n\tA valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid.\n\tA start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\n\tA < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME (not necessarily valid).\n\tThe cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.\n\tCDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.\nExample 1:\nInput: code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\nOutput: true\nExplanation: \nThe code is wrapped in a closed tag : <DIV> and </DIV>. \nThe TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. \nAlthough CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag.\nSo TAG_CONTENT is valid, and then the code is valid. Thus return true.\nExample 2:\nInput: code = \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"\nOutput: true\nExplanation:\nWe first separate the code into : start_tag|tag_content|end_tag.\nstart_tag -> \"<DIV>\"\nend_tag -> \"</DIV>\"\ntag_content could also be separated into : text1|cdata|text2.\ntext1 -> \">>  ![cdata[]] \"\ncdata -> \"<![CDATA[<div>]>]]>\", where the CDATA_CONTENT is \"<div>]>\"\ntext2 -> \"]]>>]\"\nThe reason why start_tag is NOT \"<DIV>>>\" is because of the rule 6.\nThe reason why cdata is NOT \"<![CDATA[<div>]>]]>]]>\" is because of the rule 7.\nExample 3:\nInput: code = \"<A>  <B> </A>   </B>\"\nOutput: false\nExplanation: Unbalanced. If \"<A>\" is closed, then \"<B>\" must be unmatched, and vice versa.\nConstraints:\n\t1 <= code.length <= 500\n\tcode consists of English letters, digits, '<', '>', '/', '!', '[', ']', '.', and ' '.",
        "topics": [
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/tag-validator/",
        "givenPythonCode": "class Solution:\n    def isValid(self, code: str) -> bool:\n        ",
        "givenJsCode": "class Solution {\n    public boolean isValid(String code) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} code\n * @return {boolean}\n */\nvar isValid = function(code) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\n\tFor example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\".\nReturn the number of different expressions that you can build, which evaluates to target.\nExample 1:\nInput: nums = [1,1,1,1,1], target = 3\nOutput: 5\nExplanation: There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\nExample 2:\nInput: nums = [1], target = 1\nOutput: 1\nConstraints:\n\t1 <= nums.length <= 20\n\t0 <= nums[i] <= 1000\n\t0 <= sum(nums[i]) <= 1000\n\t-1000 <= target <= 1000",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Backtracking"
        ],
        "url": "https://leetcode.com/problems/target-sum/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar findTargetSumWays = function(nums, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.\nYou are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.\nReturn the total number of seconds that Ashe is poisoned.\nExample 1:\nInput: timeSeries = [1,4], duration = 2\nOutput: 4\nExplanation: Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\nAshe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.\nExample 2:\nInput: timeSeries = [1,2], duration = 2\nOutput: 3\nExplanation: Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\nAshe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.\nConstraints:\n\t1 <= timeSeries.length <= 10^4\n\t0 <= timeSeries[i], duration <= 10^7\n\ttimeSeries is sorted in non-decreasing order.",
        "topics": [
            "Array",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/teemo-attacking/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} timeSeries\n * @param {number} duration\n * @return {number}\n */\nvar findPoisonedDuration = function(timeSeries, duration) {\n    \n};",
        "givenJsCode": "class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int findPoisonedDuration(int[] timeSeries, int duration) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:\n\tA word is defined as a character sequence consisting of non-space characters only.\n\tEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n\tThe input array words contains at least one word.\nExample 1:\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\nExample 2:\nInput: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\nExample 3:\nInput: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\nConstraints:\n\t1 <= words.length <= 300\n\t1 <= words[i].length <= 20\n\twords[i] consists of only English letters and symbols.\n\t1 <= maxWidth <= 100\n\twords[i].length <= maxWidth",
        "topics": [
            "Array",
            "String",
            "Simulation"
        ],
        "url": "https://leetcode.com/problems/text-justification/",
        "givenPythonCode": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        ",
        "givenJsCode": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string[]} words\n * @param {number} maxWidth\n * @return {string[]}\n */\nvar fullJustify = function(words, maxWidth) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.\nExample 1:\nInput: nums = [3,2,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.\nExample 2:\nInput: nums = [1,2]\nOutput: 2\nExplanation:\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.\nExample 3:\nInput: nums = [2,2,3,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1.\nConstraints:\n\t1 <= nums.length <= 10^4\n\t-2^31 <= nums[i] <= 2^31 - 1\nFollow up: Can you find an O(n) solution?",
        "topics": [
            "Array",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/third-maximum-number/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar thirdMax = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int thirdMax(int[] nums) {\n        \n    }\n}"
    },
    {
        "excercise": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.\nExample 1:\nInput: nums = [4,14,2]\nOutput: 6\nExplanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\nshowing the four bits relevant in this case).\nThe answer will be:\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\nExample 2:\nInput: nums = [4,14,4]\nOutput: 4\nConstraints:\n\t1 <= nums.length <= 10^4\n\t0 <= nums[i] <= 10^9\n\tThe answer for the given input will fit in a 32-bit integer.",
        "topics": [
            "Array",
            "Math",
            "Bit Manipulation"
        ],
        "url": "https://leetcode.com/problems/total-hamming-distance/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar totalHammingDistance = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def totalHammingDistance(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int totalHammingDistance(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\nExample 1:\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\nExample 2:\nInput: triangle = [[-10]]\nOutput: -10\nConstraints:\n\t1 <= triangle.length <= 200\n\ttriangle[0].length == 1\n\ttriangle[i].length == triangle[i - 1].length + 1\n\t-10^4 <= triangle[i][j] <= 10^4\nFollow up: Could you do this using only O(n) extra space, where n is the total number of rows in the triangle?",
        "topics": [
            "Array",
            "Dynamic Programming"
        ],
        "url": "https://leetcode.com/problems/triangle/",
        "givenPythonCode": "/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n    \n};",
        "givenJsCode": "class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\nYour solution must use only constant extra space.\nExample 1:\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\nExample 2:\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\nExample 3:\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].\nConstraints:\n\t2 <= numbers.length <= 3 * 10^4\n\t-1000 <= numbers[i] <= 1000\n\tnumbers is sorted in non-decreasing order.\n\t-1000 <= target <= 1000\n\tThe tests are generated such that there is exactly one solution.",
        "topics": [
            "Array",
            "Two Pointers",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/",
        "givenPythonCode": "/**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(numbers, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\nConstraints:\n\t2 <= nums.length <= 10^4\n\t-10^9 <= nums[i] <= 10^9\n\t-10^9 <= target <= 10^9\n\tOnly one valid answer exists.\nFollow-up: Can you come up with an algorithm that is less than O(n^2) time complexity?",
        "topics": [
            "Array",
            "Hash Table"
        ],
        "url": "https://leetcode.com/problems/two-sum/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    \n};",
        "givenJsCode": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        ",
        "givenJavaCode": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        \n    }\n}"
    },
    {
        "excercise": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the n^th ugly number.\nExample 1:\nInput: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\nExample 2:\nInput: n = 1\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\nConstraints:\n\t1 <= n <= 1690",
        "topics": [
            "Hash Table",
            "Math",
            "Dynamic Programming",
            "Heap (Priority Queue)"
        ],
        "url": "https://leetcode.com/problems/ugly-number-ii/",
        "givenPythonCode": "/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    \n};",
        "givenJsCode": "class Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int nthUglyNumber(int n) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return true if n is an ugly number.\nExample 1:\nInput: n = 6\nOutput: true\nExplanation: 6 = 2 \u00c3\u2014 3\nExample 2:\nInput: n = 1\nOutput: true\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\nExample 3:\nInput: n = 14\nOutput: false\nExplanation: 14 is not ugly since it includes the prime factor 7.\nConstraints:\n\t-2^31 <= n <= 2^31 - 1",
        "topics": [
            "Math"
        ],
        "url": "https://leetcode.com/problems/ugly-number/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def isUgly(self, n: int) -> bool:\n        ",
        "givenJsCode": "/**\n * @param {number} n\n * @return {boolean}\n */\nvar isUgly = function(n) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public boolean isUgly(int n) {\n        \n    }\n}"
    },
    {
        "excercise": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\nConstraints:\n\t1 <= s.length, t.length <= 5 * 10^4\n\ts and t consist of lowercase English letters.\nFollow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",
        "topics": [
            "Hash Table",
            "String",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/valid-anagram/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isAnagram = function(s, t) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a string s, return whether s is a valid number.\nFor example, all the following are valid numbers: \"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\", while the following are not valid numbers: \"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\".\nFormally, a valid number is defined using one of the following definitions:\n\tAn integer number followed by an optional exponent.\n\tA decimal number followed by an optional exponent.\nAn integer number is defined with an optional sign '-' or '+' followed by digits.\nA decimal number is defined with an optional sign '-' or '+' followed by one of the following definitions:\n\tDigits followed by a dot '.'.\n\tDigits followed by a dot '.' followed by digits.\n\tA dot '.' followed by digits.\nAn exponent is defined with an exponent notation 'e' or 'E' followed by an integer number.\nThe digits are defined as one or more digits.\nExample 1:\nInput: s = \"0\"\nOutput: true\nExample 2:\nInput: s = \"e\"\nOutput: false\nExample 3:\nInput: s = \".\"\nOutput: false\nConstraints:\n\t1 <= s.length <= 20\n\ts consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/valid-number/",
        "givenPythonCode": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        ",
        "givenJsCode": "class Solution {\n    public boolean isNumber(String s) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isNumber = function(s) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\n\tOpen brackets must be closed by the same type of brackets.\n\tOpen brackets must be closed in the correct order.\n\tEvery close bracket has a corresponding open bracket of the same type.\nExample 1:\nInput: s = \"()\"\nOutput: true\nExample 2:\nInput: s = \"()[]{}\"\nOutput: true\nExample 3:\nInput: s = \"(]\"\nOutput: false\nConstraints:\n\t1 <= s.length <= 10^4\n\ts consists of parentheses only '()[]{}'.",
        "topics": [
            "String",
            "Stack"
        ],
        "url": "https://leetcode.com/problems/valid-parentheses/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isValid(self, s: str) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isValid(String s) {\n        \n    }\n}"
    },
    {
        "excercise": "Given a positive integer num, return true if num is a perfect square or false otherwise.\nA perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\nYou must not use any built-in library function, such as sqrt.\nExample 1:\nInput: num = 16\nOutput: true\nExplanation: We return true because 4 * 4 = 16 and 4 is an integer.\nExample 2:\nInput: num = 14\nOutput: false\nExplanation: We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.\nConstraints:\n\t1 <= num <= 2^31 - 1",
        "topics": [
            "Math",
            "Binary Search"
        ],
        "url": "https://leetcode.com/problems/valid-perfect-square/",
        "difficulty": "Easy",
        "givenPythonCode": "/**\n * @param {number} num\n * @return {boolean}\n */\nvar isPerfectSquare = function(num) {\n    \n};",
        "givenJsCode": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        ",
        "givenJavaCode": "class Solution {\n    public boolean isPerfectSquare(int num) {\n        \n    }\n}"
    },
    {
        "excercise": "Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\nExample 1:\nInput: nums = [2,2,3,4]\nOutput: 3\nExplanation: Valid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\nExample 2:\nInput: nums = [4,2,3,4]\nOutput: 4\nConstraints:\n\t1 <= nums.length <= 1000\n\t0 <= nums[i] <= 1000",
        "topics": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Greedy",
            "Sorting"
        ],
        "url": "https://leetcode.com/problems/valid-triangle-number/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar triangleNumber = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def triangleNumber(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int triangleNumber(int[] nums) {\n        \n    }\n}",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 address or \"Neither\" if IP is not a correct IP of any type.\nA valid IPv4 address is an IP in the form \"x1.x2.x3.x4\" where 0 <= xi <= 255 and xi cannot contain leading zeros. For example, \"192.168.1.1\" and \"192.168.1.0\" are valid IPv4 addresses while \"192.168.01.1\", \"192.168.1.00\", and \"192.168@1.1\" are invalid IPv4 addresses.\nA valid IPv6 address is an IP in the form \"x1:x2:x3:x4:x5:x6:x7:x8\" where:\n\t1 <= xi.length <= 4\n\txi is a hexadecimal string which may contain digits, lowercase English letter ('a' to 'f') and upper-case English letters ('A' to 'F').\n\tLeading zeros are allowed in xi.\nFor example, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\" and \"2001:db8:85a3:0:0:8A2E:0370:7334\" are valid IPv6 addresses, while \"2001:0db8:85a3::8A2E:037j:7334\" and \"02001:0db8:85a3:0000:0000:8a2e:0370:7334\" are invalid IPv6 addresses.\nExample 1:\nInput: queryIP = \"172.16.254.1\"\nOutput: \"IPv4\"\nExplanation: This is a valid IPv4 address, return \"IPv4\".\nExample 2:\nInput: queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\nOutput: \"IPv6\"\nExplanation: This is a valid IPv6 address, return \"IPv6\".\nExample 3:\nInput: queryIP = \"256.256.256.256\"\nOutput: \"Neither\"\nExplanation: This is neither a IPv4 address nor a IPv6 address.\nConstraints:\n\tqueryIP consists only of English letters, digits and the characters '.' and ':'.",
        "topics": [
            "String"
        ],
        "url": "https://leetcode.com/problems/validate-ip-address/",
        "givenPythonCode": "/**\n * @param {string} queryIP\n * @return {string}\n */\nvar validIPAddress = function(queryIP) {\n    \n};",
        "givenJsCode": "class Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        ",
        "givenJavaCode": "class Solution {\n    public String validIPAddress(String queryIP) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Return whether the total amount of water in both jugs may reach target using the following operations:\n\tFill either jug completely with water.\n\tCompletely empty either jug.\n\tPour water from one jug into another until the receiving jug is full, or the transferring jug is empty.\nExample 1: \nInput:   x = 3, y = 5, target = 4 \nOutput:   true \nExplanation:\nFollow these steps to reach a total of 4 liters:\n\tFill the 5-liter jug (0, 5).\n\tPour from the 5-liter jug into the 3-liter jug, leaving 2 liters (3, 2).\n\tEmpty the 3-liter jug (0, 2).\n\tTransfer the 2 liters from the 5-liter jug to the 3-liter jug (2, 0).\n\tFill the 5-liter jug again (2, 5).\n\tPour from the 5-liter jug into the 3-liter jug until the 3-liter jug is full. This leaves 4 liters in the 5-liter jug (3, 4).\n\tEmpty the 3-liter jug. Now, you have exactly 4 liters in the 5-liter jug (0, 4).\nReference: The Die Hard example.\nExample 2: \nInput:   x = 2, y = 6, target = 5 \nOutput:   false \nExample 3: \nInput:   x = 1, y = 2, target = 3 \nOutput:   true \nExplanation: Fill both jugs. The total amount of water in both jugs is equal to 3 now.\nConstraints:\n\t1 <= x, y, target <= 10^3",
        "topics": [
            "Math",
            "Depth-First Search",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/water-and-jug-problem/",
        "givenPythonCode": "class Solution:\n    def canMeasureWater(self, x: int, y: int, target: int) -> bool:\n        ",
        "givenJsCode": "/**\n * @param {number} x\n * @param {number} y\n * @param {number} target\n * @return {boolean}\n */\nvar canMeasureWater = function(x, y, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public boolean canMeasureWater(int x, int y, int target) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\tFor example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.\n\tIn contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\nA subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\nGiven an integer array nums, return the length of the longest wiggle subsequence of nums.\nExample 1:\nInput: nums = [1,7,4,9,2,5]\nOutput: 6\nExplanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\nExample 2:\nInput: nums = [1,17,5,10,13,15,10,5,16,8]\nOutput: 7\nExplanation: There are several subsequences that achieve this length.\nOne is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).\nExample 3:\nInput: nums = [1,2,3,4,5,6,7,8,9]\nOutput: 2\nConstraints:\n\t1 <= nums.length <= 1000\n\t0 <= nums[i] <= 1000\nFollow up: Could you solve this in O(n) time?",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "url": "https://leetcode.com/problems/wiggle-subsequence/",
        "givenPythonCode": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar wiggleMaxLength = function(nums) {\n    \n};",
        "givenJsCode": "class Solution:\n    def wiggleMaxLength(self, nums: List[int]) -> int:\n        ",
        "givenJavaCode": "class Solution {\n    public int wiggleMaxLength(int[] nums) {\n        \n    }\n}",
        "difficulty": "Medium"
    },
    {
        "excercise": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\tEvery adjacent pair of words differs by a single letter.\n\tEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n\tsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].\nExample 1:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\nExplanation: There are 2 shortest transformation sequences:\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"\nExample 2:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: []\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\nConstraints:\n\t1 <= beginWord.length <= 5\n\tendWord.length == beginWord.length\n\t1 <= wordList.length <= 500\n\twordList[i].length == beginWord.length\n\tbeginWord, endWord, and wordList[i] consist of lowercase English letters.\n\tbeginWord != endWord\n\tAll the words in wordList are unique.\n\tThe sum of all shortest transformation sequences does not exceed 10^5.",
        "topics": [
            "Hash Table",
            "String",
            "Backtracking",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/word-ladder-ii/",
        "givenPythonCode": "class Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        ",
        "givenJsCode": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {string[][]}\n */\nvar findLadders = function(beginWord, endWord, wordList) {\n    \n};",
        "difficulty": "Medium"
    },
    {
        "excercise": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\tEvery adjacent pair of words differs by a single letter.\n\tEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n\tsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\nExample 1:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\nExample 2:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: 0\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\nConstraints:\n\t1 <= beginWord.length <= 10\n\tendWord.length == beginWord.length\n\t1 <= wordList.length <= 5000\n\twordList[i].length == beginWord.length\n\tbeginWord, endWord, and wordList[i] consist of lowercase English letters.\n\tbeginWord != endWord\n\tAll the words in wordList are unique.",
        "topics": [
            "Hash Table",
            "String",
            "Breadth-First Search"
        ],
        "url": "https://leetcode.com/problems/word-ladder/",
        "givenPythonCode": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        ",
        "givenJsCode": "class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        \n    }\n}",
        "givenJavaCode": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n    \n};",
        "difficulty": "Hard"
    },
    {
        "excercise": "Given a pattern and a string s, find if s follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.\nExample 1:\nInput: pattern = \"abba\", s = \"dog cat cat dog\"\nOutput: true\nExample 2:\nInput: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nExample 3:\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false\nConstraints:\n\t1 <= pattern.length <= 300\n\tpattern contains only lower-case English letters.\n\t1 <= s.length <= 3000\n\ts contains only lowercase English letters and spaces ' '.\n\ts does not contain any leading or trailing spaces.\n\tAll the words in s are separated by a single space.",
        "topics": [
            "Hash Table",
            "String"
        ],
        "url": "https://leetcode.com/problems/word-pattern/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\n    def canMeasureWater(self, x: int, y: int, target: int) -> bool:\n        ",
        "givenJsCode": "/**\n * @param {number} x\n * @param {number} y\n * @param {number} target\n * @return {boolean}\n */\nvar canMeasureWater = function(x, y, target) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        \n    }\n}"
    },
    {
        "excercise": "You are given an integer array matchsticks where matchsticks[i] is the length of the i^th matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\nReturn true if you can make this square and false otherwise.\nExample 1:\nInput: matchsticks = [1,1,2,2,2]\nOutput: true\nExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.\nExample 2:\nInput: matchsticks = [3,3,3,3,4]\nOutput: false\nExplanation: You cannot find a way to form a square with all the matchsticks.\nConstraints:\n\t1 <= matchsticks.length <= 15\n\t1 <= matchsticks[i] <= 10^8",
        "topics": [
            "Array",
            "Dynamic Programming",
            "Backtracking",
            "Bit Manipulation",
            "Bitmask"
        ],
        "url": "https://leetcode.com/problems/matchsticks-to-square/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\n    def makesquare(self, matchsticks: List[int]) -> bool:\n        ",
        "givenJsCode": "/**\n * @param {number[]} matchsticks\n * @return {boolean}\n */\nvar makesquare = function(matchsticks) {\n    \n};",
        "givenJavaCode": "class Solution {\n    public boolean makesquare(int[] matchsticks) {\n        \n    }\n}"
    },
    {
        "excercise": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth\u00a0is the number of nodes along the longest path from the root node down to the farthest leaf node.\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\nExample 2:\nInput: root = [1,null,2]\nOutput: 2\nConstraints:\n\tThe number of nodes in the tree is in the range [0, 10^4].\n\t-100 <= Node.val <= 100",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, invert the tree, and return its root.\nExample 1:\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\nExample 2:\nInput: root = [2,1,3]\nOutput: [2,3,1]\nExample 3:\nInput: root = []\nOutput: []\nConstraints:\n\tThe number of nodes in the tree is in the range [0, 100].\n\t-100 <= Node.val <= 100",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/invert-binary-tree/description/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {TreeNode}\r\n */\r\nvar invertTree = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode invertTree(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, return all root-to-leaf paths in any order.\nA leaf is a node with no children.\nExample 1:\nInput: root = [1,2,3,null,5]\nOutput: [\"1->2->5\",\"1->3\"]\nExample 2:\nInput: root = [1]\nOutput: [\"1\"]\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 100].\n\t-100 <= Node.val <= 100",
        "topics": [
            "String",
            "Backtracking",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/binary-tree-paths/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {string[]}\r\n */\r\nvar binaryTreePaths = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<String> binaryTreePaths(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given row x col grid representing a map where grid[i][j] = 1 represents\u00a0land and grid[i][j] = 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\nExample 1:\nInput: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\nOutput: 16\nExplanation: The perimeter is the 16 yellow stripes in the image above.\nExample 2:\nInput: grid = [[1]]\nOutput: 4\nExample 3:\nInput: grid = [[1,0]]\nOutput: 4\nConstraints:\n\trow == grid.length\n\tcol == grid[i].length\n\t1 <= row, col <= 100\n\tgrid[i][j] is 0 or 1.\n\tThere is exactly one island in grid.",
        "topics": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/island-perimeter/",
        "difficulty": "Easy",
        "givenPythonCode": "class Solution:\r\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar islandPerimeter = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int islandPerimeter(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.\nExample 1:\nInput: root = [4,2,6,1,3]\nOutput: 1\nExample 2:\nInput: root = [1,0,48,null,null,12,49]\nOutput: 1\nConstraints:\n\tThe number of nodes in the tree is in the range [2, 10^4].\n\t0 <= Node.val <= 10^5\nNote: This question is the same as 783: https://leetcode.com/problems/minimum-distance-between-bst-nodes/",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/minimum-absolute-difference-in-bst/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar getMinimumDifference = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int getMinimumDifference(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, return the sum of every tree node's tilt.\nThe tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if the node does not have a right child.\nExample 1:\nInput: root = [1,2,3]\nOutput: 1\nExplanation: \nTilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1\nExample 2:\nInput: root = [4,2,9,3,5,null,7]\nOutput: 15\nExplanation: \nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\nExample 3:\nInput: root = [21,7,14,1,1,2,2,3,3]\nOutput: 9\nConstraints:\n\tThe number of nodes in the tree is in the range [0, 10^4].\n\t-1000 <= Node.val <= 1000",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/binary-tree-tilt/",
        "difficulty": "Easy",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def findTilt(self, root: Optional[TreeNode]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar findTilt = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int findTilt(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "A tree is an undirected graph in which any two vertices are connected by\u00a0exactly\u00a0one path. In other words, any connected graph without simple cycles is a tree.\nGiven a tree of n nodes\u00a0labelled from 0 to n - 1, and an array of\u00a0n - 1\u00a0edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes\u00a0ai and\u00a0bi in the tree,\u00a0you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))\u00a0 are called minimum height trees (MHTs).\nReturn a list of all MHTs' root labels.\u00a0You can return the answer in any order.\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\nExample 1:\nInput: n = 4, edges = [[1,0],[1,2],[1,3]]\nOutput: [1]\nExplanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\nExample 2:\nInput: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\nOutput: [3,4]\nConstraints:\n\t1 <= n <= 2 * 10^4\n\tedges.length == n - 1\n\t0 <= ai, bi < n\n\tai != bi\n\tAll the pairs (ai, bi) are distinct.\n\tThe given input is guaranteed to be a tree and there will be no repeated edges.",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "url": "https://leetcode.com/problems/minimum-height-trees/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} edges\r\n * @return {number[]}\r\n */\r\nvar findMinHeightTrees = function(n, edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\nExample 2:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\nExample 3:\nInput: root = [1,2], p = 1, q = 2\nOutput: 1\nConstraints:\n\tThe number of nodes in the tree is in the range [2, 10^5].\n\t-10^9 <= Node.val <= 10^9\n\tAll Node.val are unique.\n\tp != q\n\tp and q will exist in the tree.",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution:\r\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {TreeNode}\r\n */\r\nvar lowestCommonAncestor = function(root, p, q) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d\nExample 1:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA of nodes 2 and 8 is 6.\nExample 2:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\nExample 3:\nInput: root = [2,1], p = 2, q = 1\nOutput: 2\nConstraints:\n\tThe number of nodes in the tree is in the range [2, 10^5].\n\t-10^9 <= Node.val <= 10^9\n\tAll Node.val are unique.\n\tp != q\n\tp and q will exist in the BST.",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution:\r\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {TreeNode} root\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {TreeNode}\r\n */\r\nvar lowestCommonAncestor = function(root, p, q) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\n\r\nclass Solution {\r\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary search tree, and an integer k, return the k^th smallest value (1-indexed) of all the values of the nodes in the tree.\nExample 1:\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\nExample 2:\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\nConstraints:\n\tThe number of nodes in the tree is n.\n\t1 <= k <= n <= 10^4\n\t0 <= Node.val <= 10^4\nFollow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar kthSmallest = function(root, k) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int kthSmallest(TreeNode root, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\tFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\nExample 2:\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\nExample 3:\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\nConstraints:\n\t1 <= numCourses <= 2000\n\t0 <= prerequisites.length <= numCourses * (numCourses - 1)\n\tprerequisites[i].length == 2\n\t0 <= ai, bi < numCourses\n\tai != bi\n\tAll the pairs [ai, bi] are distinct.",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "url": "https://leetcode.com/problems/course-schedule-ii/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} numCourses\r\n * @param {number[][]} prerequisites\r\n * @return {number[]}\r\n */\r\nvar findOrder = function(numCourses, prerequisites) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExample 1:\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\nExample 2:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\nConstraints:\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 300\n\tgrid[i][j] is '0' or '1'.",
        "topics": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/number-of-islands/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def numIslands(self, grid: List[List[str]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {character[][]} grid\r\n * @return {number}\r\n */\r\nvar numIslands = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numIslands(char[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nExample 1:\nInput: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]\nExample 2:\nInput: root = [1,null,3]\nOutput: [1,3]\nExample 3:\nInput: root = []\nOutput: []\nConstraints:\n\tThe number of nodes in the tree is in the range [0, 100].\n\t-100 <= Node.val <= 100",
        "topics": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "url": "https://leetcode.com/problems/binary-tree-right-side-view/",
        "difficulty": "Medium",
        "givenPythonCode": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nvar rightSideView = function(root) {\r\n    \r\n};",
        "givenJavaCode": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<Integer> rightSideView(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.\nExample 1:\nInput: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\nOutput: 700\nExplanation:\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.\nExample 2:\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200\nExplanation:\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\nExample 3:\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500\nExplanation:\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\nConstraints:\n\t1 <= n <= 100\n\t0 <= flights.length <= (n * (n - 1) / 2)\n\tflights[i].length == 3\n\t0 <= fromi, toi < n\n\tfromi != toi\n\t1 <= pricei <= 10^4\n\tThere will not be any multiple flights between two cities.\n\t0 <= src, dst, k < n\n\tsrc != dst",
        "topics": [
            "Dynamic Programming",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Heap (Priority Queue)",
            "Shortest Path"
        ],
        "url": "https://leetcode.com/problems/cheapest-flights-within-k-stops/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} flights\r\n * @param {number} src\r\n * @param {number} dst\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar findCheapestPrice = function(n, flights, src, dst, k) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order.\nThe graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).\nExample 1:\nInput: graph = [[1,2],[3],[3],[]]\nOutput: [[0,1,3],[0,2,3]]\nExplanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.\nExample 2:\nInput: graph = [[4,3,1],[3,2,4],[3],[4],[]]\nOutput: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\nConstraints:\n\tn == graph.length\n\t2 <= n <= 15\n\t0 <= graph[i][j] < n\n\tgraph[i][j] != i (i.e., there will be no self-loops).\n\tAll the elements of graph[i] are unique.\n\tThe input graph is guaranteed to be a DAG.",
        "topics": [
            "Backtracking",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/all-paths-from-source-to-target/",
        "difficulty": "Medium",
        "givenPythonCode": "class Solution:\r\n    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} graph\r\n * @return {number[][]}\r\n */\r\nvar allPathsSourceTarget = function(graph) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].\nA node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).\nReturn an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.\nExample 1:\nInput: graph = [[1,2],[2,3],[5],[0],[5],[],[]]\nOutput: [2,4,5,6]\nExplanation: The given graph is shown above.\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\nExample 2:\nInput: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\nOutput: [4]\nExplanation:\nOnly node 4 is a terminal node, and every path starting at node 4 leads to node 4.\nConstraints:\n\tn == graph.length\n\t1 <= n <= 10^4\n\t0 <= graph[i].length <= n\n\t0 <= graph[i][j] <= n - 1\n\tgraph[i] is sorted in a strictly increasing order.\n\tThe graph may contain self-loops.\n\tThe number of edges in the graph will be in the range [1, 4 * 10^4].",
        "topics": [
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "url": "https://leetcode.com/problems/find-eventual-safe-states/",
        "difficulty": "LeetCode Logo\r\n0\r\n\r\navatar\r\nPremium\r\nDebugging...\r\nDebugging...\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nRun\r\nDescription\r\nEditorial\r\nEditorial\r\nSolutions\r\nSolutions\r\nSubmissions\r\nSubmissions\r\n\r\n\r\nCode\r\n\r\n\r\nTestcase\r\nTest Result\r\nTest Result\r\n802. Find Eventual Safe States\r\nMedium\r\nTopics\r\nCompanies\r\nThere is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].\r\n\r\nA node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).\r\n\r\nReturn an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nIllustration of graph\r\nInput: graph = [[1,2],[2,3],[5],[0],[5],[],[]]\r\nOutput: [2,4,5,6]\r\nExplanation: The given graph is shown above.\r\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\r\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\r\nExample 2:\r\n\r\nInput: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\r\nOutput: [4]\r\nExplanation:\r\nOnly node 4 is a terminal node, and every path starting at node 4 leads to node 4.\r\n \r\n\r\nConstraints:\r\n\r\nn == graph.length\r\n1 <= n <= 104\r\n0 <= graph[i].length <= n\r\n0 <= graph[i][j] <= n - 1\r\ngraph[i] is sorted in a strictly increasing order.\r\nThe graph may contain self-loops.\r\nThe number of edges in the graph will be in the range [1, 4 * 104].\r\nSeen this question in a real interview before?\r\n1/5\r\nYes\r\nNo\r\nAccepted\r\n267.6K\r\nSubmissions\r\n420.7K\r\nAcceptance Rate\r\n63.6%\r\nTopics\r\nCompanies\r\nSimilar Questions\r\nDiscussion (91)\r\n\r\nChoose a type\r\n\r\n\r\n\r\nCopyright \u00a9\ufe0f 2024 LeetCode All rights reserved\r\n\r\n5.8K\r\n\r\n\r\n91\r\n\r\n\r\n\r\n1\r\n[[1,2],[2,3],[5],[0],[5],[],[]]\r\n[[1,2,3,4],[1,2],[3,4],[0,4],[]]\r\n",
        "givenPythonCode": "class Solution:\r\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} graph\r\n * @return {number[]}\r\n */\r\nvar eventualSafeNodes = function(graph) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public List<Integer> eventualSafeNodes(int[][] graph) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\nReturn the size of the largest island in grid after applying this operation.\nAn island is a 4-directionally connected group of 1s.\nExample 1:\nInput: grid = [[1,0],[0,1]]\nOutput: 3\nExplanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\nExample 2:\nInput: grid = [[1,1],[1,0]]\nOutput: 4\nExplanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.\nExample 3:\nInput: grid = [[1,1],[1,1]]\nOutput: 4\nExplanation: Can't change any 0 to 1, only one island with area = 4.\nConstraints:\n\tn == grid.length\n\tn == grid[i].length\n\t1 <= n <= 500\n\tgrid[i][j] is either 0 or 1.",
        "topics": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Matrix"
        ],
        "url": "https://leetcode.com/problems/making-a-large-island/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def largestIsland(self, grid: List[List[int]]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar largestIsland = function(grid) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int largestIsland(int[][] grid) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\nYou are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nReturn an array answer of length n where answer[i] is the sum of the distances between the i^th node in the tree and all other nodes.\nExample 1:\nInput: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\nOutput: [8,12,6,10,10,10]\nExplanation: The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer[0] = 8, and so on.\nExample 2:\nInput: n = 1, edges = []\nOutput: [0]\nExample 3:\nInput: n = 2, edges = [[1,0]]\nOutput: [1,1]\nConstraints:\n\t1 <= n <= 3 * 10^4\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t0 <= ai, bi < n\n\tai != bi\n\tThe given input represents a valid tree.",
        "topics": [
            "Dynamic Programming",
            "Tree",
            "Depth-First Search",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/sum-of-distances-in-tree/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number} n\r\n * @param {number[][]} edges\r\n * @return {number[]}\r\n */\r\nvar sumOfDistancesInTree = function(n, edges) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int[] sumOfDistancesInTree(int n, int[][] edges) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "Two strings, X and Y, are considered similar if either they are identical or we can make them equivalent by swapping at most two letters (in distinct positions) within the string X.\nFor example, \"tars\"\u00a0and \"rats\"\u00a0are similar (swapping at positions 0 and 2), and \"rats\" and \"arts\" are similar, but \"star\" is not similar to \"tars\", \"rats\", or \"arts\".\nTogether, these form two connected groups by similarity: {\"tars\", \"rats\", \"arts\"} and {\"star\"}.\u00a0 Notice that \"tars\" and \"arts\" are in the same group even though they are not similar.\u00a0 Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\nWe are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?\nExample 1:\nInput: strs = [\"tars\",\"rats\",\"arts\",\"star\"]\nOutput: 2\nExample 2:\nInput: strs = [\"omv\",\"ovm\"]\nOutput: 1\nConstraints:\n\t1 <= strs.length <= 300\n\t1 <= strs[i].length <= 300\n\tstrs[i] consists of lowercase letters only.\n\tAll words in strs have the same length and are anagrams of each other.",
        "topics": [
            "Array",
            "Hash Table",
            "String",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find"
        ],
        "url": "https://leetcode.com/problems/similar-string-groups/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def numSimilarGroups(self, strs: List[str]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {string[]} strs\r\n * @return {number}\r\n */\r\nvar numSimilarGroups = function(strs) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int numSimilarGroups(String[] strs) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a network of n nodes represented as an n x n adjacency matrix graph, where the i^th node is directly connected to the j^th node if graph[i][j] == 1.\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial.\nReturn the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\nNote that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.\nExample 1:\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\nExample 2:\nInput: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]\nOutput: 0\nExample 3:\nInput: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]\nOutput: 1\nConstraints:\n\tn == graph.length\n\tn == graph[i].length\n\t2 <= n <= 300\n\tgraph[i][j] is 0 or 1.\n\tgraph[i][j] == graph[j][i]\n\tgraph[i][i] == 1\n\t1 <= initial.length <= n\n\t0 <= initial[i] <= n - 1\n\tAll the integers in initial are unique.",
        "topics": [
            "Array",
            "Hash Table",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/minimize-malware-spread/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} graph\r\n * @param {number[]} initial\r\n * @return {number}\r\n */\r\nvar minMalwareSpread = function(graph, initial) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minMalwareSpread(int[][] graph, int[] initial) {\r\n        \r\n    }\r\n}"
    },
    {
        "excercise": "You are given a network of n nodes represented as an n x n adjacency matrix graph, where the i^th node is directly connected to the j^th node if graph[i][j] == 1.\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops.\nWe will remove exactly one node from initial, completely removing it and any connections from this node to any other node.\nReturn the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\nExample 1:\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\nExample 2:\nInput: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]\nOutput: 1\nExample 3:\nInput: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]\nOutput: 1\nConstraints:\n\tn == graph.length\n\tn == graph[i].length\n\t2 <= n <= 300\n\tgraph[i][j] is 0 or 1.\n\tgraph[i][j] == graph[j][i]\n\tgraph[i][i] == 1\n\t1 <= initial.length <\u00a0n\n\t0 <= initial[i] <= n - 1\n\tAll the integers in initial are unique.",
        "topics": [
            "Array",
            "Hash Table",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "url": "https://leetcode.com/problems/minimize-malware-spread-ii/",
        "difficulty": "Hard",
        "givenPythonCode": "class Solution:\r\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\r\n        ",
        "givenJsCode": "/**\r\n * @param {number[][]} graph\r\n * @param {number[]} initial\r\n * @return {number}\r\n */\r\nvar minMalwareSpread = function(graph, initial) {\r\n    \r\n};",
        "givenJavaCode": "class Solution {\r\n    public int minMalwareSpread(int[][] graph, int[] initial) {\r\n        \r\n    }\r\n}"
    }
]